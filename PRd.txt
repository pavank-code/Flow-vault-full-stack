# FlowVault - Product Requirements Document (PRD)
## AI-Powered Developer Context Preservation System

**Version:** 1.0  
**Last Updated:** October 26, 2025  
**Document Owner:** Product Team  
**Status:** Ready for Development

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Product Overview](#product-overview)
3. [Technical Architecture](#technical-architecture)
4. [Electron Application Specifications](#electron-application-specifications)
5. [UI/UX Design System (Cluely-Inspired)](#uiux-design-system)
6. [Core Features - Detailed Specifications](#core-features)
7. [Advanced Features](#advanced-features)
8. [Data Models & Database Schema](#data-models)
9. [API Specifications](#api-specifications)
10. [Security & Privacy](#security-privacy)
11. [Performance Requirements](#performance-requirements)
12. [Integration Requirements](#integration-requirements)
13. [Analytics & Telemetry](#analytics-telemetry)
14. [Monetization Implementation](#monetization-implementation)
15. [Development Roadmap](#development-roadmap)

---

## 1. Executive Summary {#executive-summary}

FlowVault is an Electron-based desktop application that solves the $1.4 trillion context-switching problem in software development. It automatically captures, preserves, and restores complete developer working contexts, enabling instant recovery of flow states after interruptions.

**Key Metrics:**
- Target: 250,000 users in Year 1
- ARR Goal: $105M at 5% market penetration
- Technical Goal: <100ms context restoration latency
- Engagement Goal: 80% DAU/MAU ratio

---

## 2. Product Overview {#product-overview}

### 2.1 Product Vision

Create the world's first cognitive infrastructure for developers that eliminates context loss, enabling continuous flow states and 10x productivity improvements.

### 2.2 Core Value Propositions

1. **Instant Context Recovery**: Restore complete working state in <5 seconds
2. **Zero Mental Load**: Never worry about losing your place
3. **Team Knowledge Sharing**: Transfer context between team members effortlessly
4. **Focus Protection**: Intelligent interruption filtering
5. **Productivity Intelligence**: Data-driven insights into work patterns

### 2.3 Target Users

**Primary:**
- Senior Software Engineers (5+ years experience)
- Full-stack Developers working across multiple codebases
- Tech Leads managing multiple projects
- DevOps Engineers handling incidents

**Secondary:**
- Junior Developers (onboarding use case)
- Product Managers (understanding technical context)
- Engineering Managers (team productivity insights)

### 2.4 Success Metrics

**Adoption Metrics:**
- Daily Active Users (DAU): 80% of registered users
- Weekly Active Users (WAU): 95% of registered users
- Context Captures per User per Day: 15-25
- Context Restorations per User per Day: 8-15

**Engagement Metrics:**
- Average Session Duration: 6+ hours (running in background)
- Feature Usage Rate: 70% of users use 5+ features weekly
- Retention: 90% Week-1, 75% Month-1, 60% Month-6

**Business Metrics:**
- Free-to-Paid Conversion: 15% within 30 days
- Team Expansion Rate: 40% of Pro users upgrade to Team within 90 days
- Net Revenue Retention: 120% annually
- Customer Acquisition Cost (CAC): <$50
- Lifetime Value (LTV): >$2,000

---

## 3. Technical Architecture {#technical-architecture}

### 3.1 Overall System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FlowVault Electron App                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Overlay    â”‚  â”‚   Main UI    â”‚  â”‚  Background  â”‚      â”‚
â”‚  â”‚   Window     â”‚  â”‚   Window     â”‚  â”‚   Services   â”‚      â”‚
â”‚  â”‚  (Frameless) â”‚  â”‚  (Standard)  â”‚  â”‚  (Node.js)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚           IPC Communication Layer                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Context    â”‚  â”‚     AI       â”‚  â”‚   Plugin     â”‚      â”‚
â”‚  â”‚   Capture    â”‚  â”‚   Engine     â”‚  â”‚   System     â”‚      â”‚
â”‚  â”‚   Engine     â”‚  â”‚              â”‚  â”‚              â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Local DB   â”‚  â”‚   File       â”‚  â”‚   Cache      â”‚      â”‚
â”‚  â”‚  (SQLite)    â”‚  â”‚   System     â”‚  â”‚   Layer      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ HTTPS/WebSocket
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Backend Services (Cloud)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   API        â”‚  â”‚   AI         â”‚  â”‚   Sync       â”‚      â”‚
â”‚  â”‚   Gateway    â”‚  â”‚   Service    â”‚  â”‚   Service    â”‚      â”‚
â”‚  â”‚  (Node.js)   â”‚  â”‚  (Python)    â”‚  â”‚  (Node.js)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  PostgreSQL  â”‚  â”‚   Redis      â”‚  â”‚  S3/Object   â”‚      â”‚
â”‚  â”‚  (Primary)   â”‚  â”‚   Cache      â”‚  â”‚   Storage    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Analytics   â”‚  â”‚   Queue      â”‚  â”‚   Search     â”‚      â”‚
â”‚  â”‚  (ClickHouse)â”‚  â”‚  (RabbitMQ)  â”‚  â”‚(Elasticsearch)â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Technology Stack

**Electron Application:**
- **Framework**: Electron 28.x (latest stable)
- **Renderer**: React 18.x with TypeScript 5.x
- **State Management**: Zustand + React Query
- **Styling**: Tailwind CSS 3.x + Framer Motion
- **Build Tool**: Vite 5.x
- **Testing**: Vitest + Playwright

**Backend Services:**
- **API Gateway**: Node.js 20.x + Express.js + tRPC
- **AI Service**: Python 3.11 + FastAPI + LangChain
- **Database**: PostgreSQL 16 (primary) + SQLite (local)
- **Cache**: Redis 7.x
- **Message Queue**: RabbitMQ 3.12
- **Search**: Elasticsearch 8.x
- **Object Storage**: AWS S3 / MinIO (self-hosted option)
- **Analytics**: ClickHouse 23.x

**AI/ML Stack:**
- **LLM Provider**: OpenAI GPT-4 Turbo (primary), Anthropic Claude (fallback)
- **Embeddings**: OpenAI text-embedding-3-large
- **Vector Database**: Pinecone / Weaviate
- **Local LLM**: Ollama (for offline mode)

**Infrastructure:**
- **Container Orchestration**: Kubernetes (AWS EKS / GCP GKE)
- **CI/CD**: GitHub Actions
- **Monitoring**: Datadog / Prometheus + Grafana
- **Error Tracking**: Sentry
- **CDN**: CloudFlare

### 3.3 Electron Architecture (Detailed)

#### 3.3.1 Multi-Window Architecture

**Main Window (Standard BrowserWindow):**
```typescript
// Specifications
{
  width: 1400,
  height: 900,
  minWidth: 1200,
  minHeight: 700,
  frame: true,
  titleBarStyle: 'hiddenInset', // macOS
  backgroundColor: '#0A0A0B',
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true,
    preload: path.join(__dirname, 'preload.js'),
    webSecurity: true
  }
}
```

**Overlay Window (Frameless BrowserWindow):**
```typescript
// Specifications for always-on-top overlay
{
  width: 400,
  height: 600,
  frame: false,
  transparent: true,
  alwaysOnTop: true,
  skipTaskbar: true,
  resizable: false,
  movable: true,
  hasShadow: false,
  type: 'panel', // macOS, toolbar on Windows
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true,
    preload: path.join(__dirname, 'overlay-preload.js')
  }
}
```

**Mini Widget (System Tray Extension):**
```typescript
// Compact widget for quick actions
{
  width: 320,
  height: 480,
  frame: false,
  transparent: true,
  alwaysOnTop: true,
  skipTaskbar: true,
  show: false, // shown on tray click
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true
  }
}
```

#### 3.3.2 IPC Communication Architecture

**Bidirectional IPC Channels:**

```typescript
// Main Process â†’ Renderer
enum MainToRendererChannels {
  CONTEXT_CAPTURED = 'context:captured',
  CONTEXT_UPDATED = 'context:updated',
  AI_RESPONSE = 'ai:response',
  SYNC_STATUS = 'sync:status',
  NOTIFICATION = 'notification:show',
  FOCUS_CHANGE = 'focus:changed',
  PLUGIN_EVENT = 'plugin:event'
}

// Renderer â†’ Main Process
enum RendererToMainChannels {
  CAPTURE_CONTEXT = 'context:capture',
  RESTORE_CONTEXT = 'context:restore',
  AI_QUERY = 'ai:query',
  OPEN_FILE = 'file:open',
  SYNC_REQUEST = 'sync:request',
  SETTINGS_UPDATE = 'settings:update'
}

// IPC Implementation with type safety
interface IPCInvokeHandlers {
  'context:capture': (options: CaptureOptions) => Promise<Context>;
  'context:restore': (contextId: string) => Promise<void>;
  'context:list': (filters: ContextFilters) => Promise<Context[]>;
  'ai:query': (query: string, contextId?: string) => Promise<AIResponse>;
  'settings:get': () => Promise<Settings>;
  'settings:update': (settings: Partial<Settings>) => Promise<void>;
  'file:read': (path: string) => Promise<string>;
  'plugin:execute': (pluginId: string, action: string, params: any) => Promise<any>;
}
```

#### 3.3.3 Process Architecture

**Main Process Responsibilities:**
- Window lifecycle management
- Native OS integration (file system, notifications, shortcuts)
- SQLite database operations
- Background services coordination
- IPC orchestration
- Auto-updater management
- System tray management

**Renderer Process Responsibilities:**
- UI rendering and user interactions
- State management (Zustand stores)
- Real-time data updates (WebSocket)
- Client-side routing
- Form validation
- Local caching (IndexedDB)

**Worker Processes (via fork):**
- Context capture engine (CPU-intensive)
- AI request processing
- File system monitoring
- Screenshot/screen recording
- Data synchronization

### 3.4 Context Capture Engine Architecture

```typescript
class ContextCaptureEngine {
  // Core components
  private fileSystemWatcher: FileSystemWatcher;
  private applicationMonitor: ApplicationMonitor;
  private browserExtensionBridge: BrowserBridge;
  private ideIntegration: IDEIntegration;
  private terminalMonitor: TerminalMonitor;
  private clipboardMonitor: ClipboardMonitor;
  
  // Capture pipeline
  async captureContext(): Promise<Context> {
    // Parallel capture for performance
    const [
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState,
      applicationWindows,
      clipboardHistory,
      screenshots
    ] = await Promise.all([
      this.captureActiveFiles(),
      this.captureBrowserTabs(),
      this.captureTerminalSessions(),
      this.captureIDEState(),
      this.captureApplicationWindows(),
      this.captureClipboardHistory(),
      this.captureScreenshots()
    ]);
    
    // AI-powered context analysis
    const contextSummary = await this.aiAnalyzeContext({
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState
    });
    
    // Assemble complete context
    return {
      id: generateUUID(),
      timestamp: Date.now(),
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState,
      applicationWindows,
      clipboardHistory,
      screenshots,
      aiSummary: contextSummary,
      metadata: this.extractMetadata()
    };
  }
}
```

**File System Capture:**
```typescript
interface FileCaptureResult {
  path: string;
  content: string; // Full content for small files
  contentHash: string; // SHA-256 hash
  excerpt: string; // First/last N lines for large files
  language: string;
  cursorPosition: { line: number; column: number };
  selections: Array<{ start: Position; end: Position }>;
  scrollPosition: number;
  folds: number[]; // Collapsed line numbers
  breakpoints: number[];
  bookmarks: Bookmark[];
  fileSize: number;
  lastModified: number;
  gitStatus?: {
    branch: string;
    changes: number;
    staged: boolean;
  };
}
```

**Browser Tab Capture:**
```typescript
interface BrowserTabCapture {
  url: string;
  title: string;
  favicon: string;
  screenshot?: string; // Base64 thumbnail
  scrollPosition: number;
  formData?: Record<string, string>; // For unsaved forms
  selectedText?: string;
  openTime: number;
  lastActiveTime: number;
  category: 'documentation' | 'stackoverflow' | 'github' | 'other';
  relevanceScore: number; // AI-calculated
}
```

**Terminal Session Capture:**
```typescript
interface TerminalCapture {
  sessionId: string;
  workingDirectory: string;
  history: string[]; // Last 100 commands
  output: string; // Last 1000 lines
  environmentVariables: Record<string, string>;
  activeProcesses: Process[];
  shell: string;
  tabs: TerminalTab[];
}
```

**IDE State Capture:**
```typescript
interface IDEStateCapture {
  type: 'vscode' | 'intellij' | 'pycharm' | 'webstorm' | 'vim' | 'emacs';
  openProjects: Project[];
  workspace: {
    folders: string[];
    settings: Record<string, any>;
  };
  extensions: Extension[];
  debugSessions: DebugSession[];
  runConfigurations: RunConfig[];
  searchHistory: string[];
  recentFiles: string[];
  pinnedFiles: string[];
  splitLayout: SplitLayoutConfig;
  editorGroups: EditorGroup[];
}
```

### 3.5 AI Engine Architecture

```typescript
class AIContextEngine {
  private openai: OpenAI;
  private vectorStore: VectorStore;
  private embeddingCache: Map<string, number[]>;
  
  // Generate context summary
  async generateContextSummary(context: Context): Promise<string> {
    const prompt = this.buildContextPrompt(context);
    
    const completion = await this.openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: `You are an expert software developer analyzing a colleague's working context.
          Generate a concise, actionable summary that captures:
          1. The primary task/problem being worked on
          2. Current progress and approach
          3. Key files and their purposes
          4. Any blockers or questions
          5. Next steps
          
          Format the summary to enable instant context restoration.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 500,
      temperature: 0.3
    });
    
    return completion.choices[0].message.content;
  }
  
  // Semantic context search
  async searchSimilarContexts(query: string, limit: number = 10): Promise<Context[]> {
    // Generate query embedding
    const queryEmbedding = await this.generateEmbedding(query);
    
    // Vector similarity search
    const similarContextIds = await this.vectorStore.search(
      queryEmbedding,
      limit
    );
    
    // Fetch full contexts
    return await this.fetchContextsByIds(similarContextIds);
  }
  
  // AI chat interface
  async chatWithContext(
    message: string,
    contextId: string,
    conversationHistory: ChatMessage[]
  ): Promise<string> {
    const context = await this.fetchContext(contextId);
    
    const systemPrompt = `You are FlowVault's AI assistant with access to the developer's complete working context.
    
    Current Context:
    ${JSON.stringify(context, null, 2)}
    
    Answer questions about this context, help debug issues, suggest next steps, and provide insights.`;
    
    const messages = [
      { role: "system", content: systemPrompt },
      ...conversationHistory,
      { role: "user", content: message }
    ];
    
    const response = await this.openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages,
      max_tokens: 1000,
      temperature: 0.7,
      stream: true // Enable streaming for real-time responses
    });
    
    return this.streamResponse(response);
  }
}
```

### 3.6 Data Synchronization Architecture

**Hybrid Sync Strategy:**
- Local-first with SQLite
- Background sync to cloud
- Conflict resolution using Last-Write-Wins + Vector Clocks
- Differential sync (only changed data)
- Compression for network efficiency

```typescript
class SyncEngine {
  private localDB: SQLiteDB;
  private remoteAPI: APIClient;
  private syncQueue: Queue<SyncOperation>;
  private websocket: WebSocket;
  
  async syncContext(context: Context): Promise<void> {
    // 1. Save locally first (fast)
    await this.localDB.saveContext(context);
    
    // 2. Queue for background sync
    this.syncQueue.add({
      type: 'context:create',
      payload: context,
      priority: 'normal'
    });
    
    // 3. Process sync queue
    await this.processSyncQueue();
  }
  
  private async processSyncQueue(): Promise<void> {
    while (!this.syncQueue.isEmpty()) {
      const operation = this.syncQueue.dequeue();
      
      try {
        // Compress payload
        const compressed = await this.compress(operation.payload);
        
        // Send to backend
        await this.remoteAPI.post('/sync', {
          operation: operation.type,
          data: compressed,
          timestamp: Date.now(),
          deviceId: this.deviceId
        });
        
        // Mark as synced
        await this.localDB.markSynced(operation.id);
      } catch (error) {
        // Retry with exponential backoff
        this.syncQueue.addWithDelay(operation, this.calculateBackoff());
      }
    }
  }
  
  // Real-time sync via WebSocket
  private setupRealtimeSync(): void {
    this.websocket.on('context:updated', async (data) => {
      // Merge remote changes
      await this.mergeRemoteContext(data);
      
      // Notify UI
      this.emit('sync:completed', data);
    });
  }
}
```

### 3.7 Plugin System Architecture

```typescript
interface Plugin {
  id: string;
  name: string;
  version: string;
  author: string;
  description: string;
  
  // Lifecycle hooks
  onActivate(context: PluginContext): Promise<void>;
  onDeactivate(): Promise<void>;
  
  // Event handlers
  onContextCapture?(context: Context): Promise<Context>;
  onContextRestore?(context: Context): Promise<void>;
  onFileOpen?(file: string): Promise<void>;
  
  // Custom commands
  commands?: PluginCommand[];
  
  // UI extensions
  uiExtensions?: {
    sidebar?: React.ComponentType;
    statusBar?: React.ComponentType;
    contextMenu?: MenuItem[];
  };
}

class PluginManager {
  private plugins: Map<string, Plugin>;
  private sandboxes: Map<string, VM>;
  
  async loadPlugin(pluginPath: string): Promise<void> {
    // Create isolated sandbox
    const sandbox = new VM({
      timeout: 5000,
      sandbox: {
        console,
        require: this.createRequireProxy(),
        flowvault: this.createPluginAPI()
      }
    });
    
    // Load and validate plugin
    const plugin = await sandbox.run(
      fs.readFileSync(pluginPath, 'utf8')
    );
    
    // Execute onActivate hook
    await plugin.onActivate(this.createPluginContext());
    
    this.plugins.set(plugin.id, plugin);
    this.sandboxes.set(plugin.id, sandbox);
  }
  
  private createPluginAPI(): PluginAPI {
    return {
      // Safe APIs exposed to plugins
      contexts: {
        getCurrent: () => this.getCurrentContext(),
        list: (filters) => this.listContexts(filters),
        create: (context) => this.createContext(context)
      },
      ui: {
        showNotification: (message) => this.showNotification(message),
        showDialog: (options) => this.showDialog(options)
      },
      storage: {
        get: (key) => this.pluginStorage.get(key),
        set: (key, value) => this.pluginStorage.set(key, value)
      }
    };
  }
}
```

---

## 4. Electron Application Specifications {#electron-application-specifications}

### 4.1 Build Configuration

**electron-builder configuration:**

```json
{
  "appId": "com.flowvault.app",
  "productName": "FlowVault",
  "copyright": "Copyright Â© 2025 FlowVault Inc.",
  "directories": {
    "output": "dist",
    "buildResources": "build"
  },
  "files": [
    "dist-electron/**/*",
    "dist/**/*",
    "package.json"
  ],
  "mac": {
    "category": "public.app-category.developer-tools",
    "target": ["dmg", "zip"],
    "hardenedRuntime": true,
    "gatekeeperAssess": false,
    "entitlements": "build/entitlements.mac.plist",
    "entitlementsInherit": "build/entitlements.mac.plist",
    "icon": "build/icon.icns",
    "minimumSystemVersion": "10.15.0",
    "darkModeSupport": true
  },
  "win": {
    "target": ["nsis", "portable"],
    "icon": "build/icon.ico",
    "publisherName": "FlowVault Inc.",
    "verifyUpdateCodeSignature": true
  },
  "linux": {
    "target": ["AppImage", "deb", "rpm"],
    "category": "Development",
    "icon": "build/icons",
    "maintainer": "support@flowvault.com"
  },
  "nsis": {
    "oneClick": false,
    "allowToChangeInstallationDirectory": true,
    "createDesktopShortcut": true,
    "createStartMenuShortcut": true
  },
  "publish": {
    "provider": "github",
    "owner": "flowvault",
    "repo": "flowvault-app"
  }
}
```

### 4.2 Auto-Update Implementation

```typescript
import { autoUpdater } from 'electron-updater';

class AutoUpdateManager {
  constructor() {
    autoUpdater.autoDownload = false;
    autoUpdater.autoInstallOnAppQuit = true;
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers(): void {
    autoUpdater.on('update-available', (info) => {
      // Notify user
      this.showUpdateNotification(info);
    });
    
    autoUpdater.on('download-progress', (progress) => {
      // Show download progress in UI
      this.updateDownloadProgress(progress);
    });
    
    autoUpdater.on('update-downloaded', () => {
      // Prompt to restart
      this.showRestartDialog();
    });
  }
  
  async checkForUpdates(): Promise<void> {
    await autoUpdater.checkForUpdates();
  }
  
  async downloadUpdate(): Promise<void> {
    await autoUpdater.downloadUpdate();
  }
  
  quitAndInstall(): void {
    autoUpdater.quitAndInstall(false, true);
  }
}
```

### 4.3 Native OS Integration

**macOS:**
```typescript
// Touch Bar support
const { TouchBar } = require('electron');

const touchBar = new TouchBar({
  items: [
    new TouchBar.TouchBarButton({
      label: 'ðŸ“¸ Capture',
      click: () => this.captureContext()
    }),
    new TouchBar.TouchBarButton({
      label: 'ðŸ”„ Restore',
      click: () => this.showRestoreMenu()
    }),
    new TouchBar.TouchBarSpacer({ size: 'flexible' }),
    new TouchBar.TouchBarButton({
      label: 'ðŸ¤– AI Chat',
      click: () => this.openAIChat()
    })
  ]
});

mainWindow.setTouchBar(touchBar);

// Menu bar integration
const { Tray } = require('electron');

const tray = new Tray('icon-template.png');
tray.setToolTip('FlowVault');
tray.on('click', () => {
  this.toggleOverlay();
});
```

**Windows:**
```typescript
// Jump list
app.setUserTasks([
  {
    program: process.execPath,
    arguments: '--capture',
    iconPath: process.execPath,
    iconIndex: 0,
    title: 'Quick Capture',
    description: 'Capture current context'
  },
  {
    program: process.execPath,
    arguments: '--restore',
    iconPath: process.execPath,
    iconIndex: 0,
    title: 'Restore Context',
    description: 'Restore last context'
  }
]);

// Thumbnail toolbar
mainWindow.setThumbarButtons([
  {
    tooltip: 'Capture',
    icon: 'capture-icon.png',
    click() { captureContext(); }
  },
  {
    tooltip: 'AI Chat',
    icon: 'ai-icon.png',
    click() { openAIChat(); }
  }
]);
```

**Linux:**
```typescript
// Desktop notification
const { Notification } = require('electron');

new Notification({
  title: 'Context Captured',
  body: 'Working on authentication bug',
  icon: 'icon.png',
  actions: [
    { type: 'button', text: 'View' },
    { type: 'button', text: 'Restore' }
  ]
}).show();
```

### 4.4 Global Keyboard Shortcuts

```typescript
import { globalShortcut } from 'electron';

class ShortcutManager {
  registerShortcuts(): void {
    // Quick capture
    globalShortcut.register('CommandOrControl+Shift+C', () => {
      this.captureContext();
    });
    
    // Quick restore
    globalShortcut.register('CommandOrControl+Shift+R', () => {
      this.showRestoreMenu();
    });
    
    // Toggle overlay
    globalShortcut.register('CommandOrControl+Shift+O', () => {
      this.toggleOverlay();
    });
    
    // AI chat
    globalShortcut.register('CommandOrControl+Shift+A', () => {
      this.openAIChat();
    });
    
    // Focus mode
    globalShortcut.register('CommandOrControl+Shift+F', () => {
      this.toggleFocusMode();
    });
  }
  
  unregisterAll(): void {
    globalShortcut.unregisterAll();
  }
}
```

### 4.5 Performance Optimizations

**Memory Management:**
```typescript
// Automatic garbage collection
setInterval(() => {
  if (global.gc) {
    global.gc();
  }
}, 60000); // Every minute

// Limit renderer processes memory
app.commandLine.appendSwitch('js-flags', '--max-old-space-size=4096');

// Disable hardware acceleration if GPU issues
if (process.platform === 'linux') {
  app.disableHardwareAcceleration();
}
```

**Lazy Loading:**
```typescript
// Load heavy components on demand
const loadHeavyComponent = () => import('./HeavyComponent');

// Use React.lazy for code splitting
const ContextTimeline = React.lazy(() => import('./ContextTimeline'));
const AIChat = React.lazy(() => import('./AIChat'));
const Analytics = React.lazy(() => import('./Analytics'));
```

**Efficient IPC:**
```typescript
// Batch IPC calls
class IPCBatcher {
  private queue: IPCMessage[] = [];
  private timer: NodeJS.Timeout | null = null;
  private readonly BATCH_INTERVAL = 16; // 60fps
  
  send(channel: string, data: any): void {
    this.queue.push({ channel, data });
    
    if (!this.timer) {
      this.timer = setTimeout(() => {
        this.flush();
      }, this.BATCH_INTERVAL);
    }
  }
  
  private flush(): void {
    if (this.queue.length > 0) {
      ipcRenderer.send('batch', this.queue);
      this.queue = [];
    }
    this.timer = null;
  }
}

// Use MessagePorts for high-frequency communication
const { port1, port2 } = new MessageChannel();
port1.onmessage = (event) => {
  // Handle high-frequency updates
  this.handleRealtimeUpdate(event.data);
};
```

---

## 5. UI/UX Design System (Cluely-Inspired) {#uiux-design-system}

### 5.1 Design Philosophy

**Core Principles:**
1. **Dark-First Design**: Premium dark aesthetic with subtle gradients
2. **Glassmorphism**: Frosted glass effects for depth and hierarchy
3. **Micro-Interactions**: Smooth animations for every interaction
4. **Information Density**: Maximum information with minimal clutter
5. **Accessibility**: WCAG 2.1 AAA compliant

### 5.2 Color Palette

```typescript
const colorSystem = {
  // Base colors (Cluely-inspired)
  background: {
    primary: '#0A0A0B',      // Deep black
    secondary: '#121214',    // Card background
    tertiary: '#1A1A1D',     // Elevated surfaces
    overlay: 'rgba(18, 18, 20, 0.85)', // Glass effect
  },
  
  // Accent colors
  accent: {
    primary: '#6366F1',      // Indigo (primary actions)
    secondary: '#8B5CF6',    // Purple (secondary actions)
    success: '#10B981',      // Green (success states)
    warning: '#F59E0B',      // Amber (warnings)
    error: '#EF4444',        // Red (errors)
    info: '#3B82F6',         // Blue (info)
  },
  
  // Gradient definitions
  gradients: {
    primary: 'linear-gradient(135deg, #6366F1 0%, #8B5CF6 100%)',
    success: 'linear-gradient(135deg, #10B981 0%, #059669 100%)',
    danger: 'linear-gradient(135deg, #EF4444 0%, #DC2626 100%)',
    neural: 'linear-gradient(135deg, #8B5CF6 0%, #EC4899 100%)',
    context: 'linear-gradient(135deg, #3B82F6 0%, #6366F1 100%)',
  },
  
  // Text colors
  text: {
    primary: '#F9FAFB',      // White (headings, important text)
    secondary: '#D1D5DB',    // Light gray (body text)
    tertiary: '#9CA3AF',     // Medium gray (muted text)
    disabled: '#6B7280',     // Dark gray (disabled)
    inverse: '#0A0A0B',      // For light backgrounds
  },
  
  // Border colors
  border: {
    subtle: 'rgba(255, 255, 255, 0.05)',
    default: 'rgba(255, 255, 255, 0.1)',
    strong: 'rgba(255, 255, 255, 0.2)',
    accent: 'rgba(99, 102, 241, 0.3)',
  },
  
  // Status colors
  status: {
    active: '#10B981',
    idle: '#F59E0B',
    offline: '#6B7280',
    syncing: '#3B82F6',
    error: '#EF4444',
  },
  
  // Semantic colors
  semantic: {
    code: '#7C3AED',
    file: '#3B82F6',
    terminal: '#10B981',
    browser: '#F59E0B',
    ai: '#EC4899',
  }
};
```

### 5.3 Typography System

```typescript
const typography = {
  fontFamily: {
    primary: '"Inter", -apple-system, BlinkMacSystemFont, sans-serif',
    mono: '"JetBrains Mono", "Fira Code", monospace',
    display: '"Cal Sans", "Inter", sans-serif', // For hero text
  },
  
  fontSize: {
    xs: '0.75rem',    // 12px
    sm: '0.875rem',   // 14px
    base: '1rem',     // 16px
    lg: '1.125rem',   // 18px
    xl: '1.25rem',    // 20px
    '2xl': '1.5rem',  // 24px
    '3xl': '1.875rem', // 30px
    '4xl': '2.25rem', // 36px
    '5xl': '3rem',    // 48px
  },
  
  fontWeight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
  },
  
  lineHeight: {
    tight: 1.25,
    normal: 1.5,
    relaxed: 1.75,
  },
  
  letterSpacing: {
    tight: '-0.02em',
    normal: '0',
    wide: '0.02em',
  }
};
```

### 5.4 Component Design Specifications

#### 5.4.1 Overlay Window Design

```typescript
// Overlay component structure
interface OverlayProps {
  position: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
  isExpanded: boolean;
  isDragging: boolean;
}

const OverlayWindow: React.FC<OverlayProps> = ({ position, isExpanded }) => {
  return (
    <div className="overlay-container">
      {/* Glass effect background */}
      <div className="glass-backdrop" />
      
      {/* Header with drag handle */}
      <div className="overlay-header">
        <div className="drag-handle">
          <GripVertical size={16} />
        </div>
        <StatusIndicator status="active" />
        <QuickActions />
      </div>
      
      {/* Main content area */}
      <div className="overlay-content">
        {isExpanded ? (
          <ExpandedView />
        ) : (
          <CompactView />
        )}
      </div>
      
      {/* Quick action buttons */}
      <div className="overlay-footer">
        <QuickCaptureButton />
        <AIAssistButton />
        <ContextListButton />
      </div>
    </div>
  );
};
```

**CSS Styles (Tailwind + Custom):**
```css
.overlay-container {
  @apply relative w-full h-full;
  @apply rounded-2xl overflow-hidden;
  @apply shadow-2xl shadow-black/50;
  backdrop-filter: blur(40px) saturate(180%);
  background: rgba(18, 18, 20, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.glass-backdrop {
  @apply absolute inset-0 -z-10;
  background: linear-gradient(
    135deg,
    rgba(99, 102, 241, 0.05) 0%,
    rgba(139, 92, 246, 0.05) 100%
  );
}

.overlay-header {
  @apply flex items-center gap-3 p-4;
  @apply border-b border-white/5;
  @apply bg-gradient-to-r from-transparent via-white/[0.02] to-transparent;
}

.drag-handle {
  @apply cursor-move text-gray-500 hover:text-gray-300;
  @apply transition-colors duration-200;
}

.overlay-content {
  @apply p-4 overflow-y-auto;
  @apply scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent;
  max-height: calc(100% - 120px);
}

.overlay-footer {
  @apply absolute bottom-0 left-0 right-0;
  @apply flex items-center justify-around gap-2 p-3;
  @apply border-t border-white/5;
  @apply bg-gradient-to-t from-black/20 to-transparent;
}
```

#### 5.4.2 Context Card Design

```typescript
interface ContextCardProps {
  context: Context;
  isActive: boolean;
  onRestore: () => void;
  onDelete: () => void;
}

const ContextCard: React.FC<ContextCardProps> = ({
  context,
  isActive,
  onRestore,
  onDelete
}) => {
  return (
    <motion.div
      className={`context-card ${isActive ? 'active' : ''}`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, scale: 0.95 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2 }}
    >
      {/* Card header */}
      <div className="card-header">
        <div className="flex items-center gap-3">
          <ContextIcon type={context.type} />
          <div className="flex-1">
            <h3 className="card-title">{context.title}</h3>
            <p className="card-subtitle">
              {formatRelativeTime(context.timestamp)}
            </p>
          </div>
          <ContextBadge status={context.status} />
        </div>
      </div>
      
      {/* AI Summary */}
      <div className="card-summary">
        <AISparkle className="summary-icon" />
        <p className="summary-text">{context.aiSummary}</p>
      </div>
      
      {/* Context metadata */}
      <div className="card-metadata">
        <MetadataItem
          icon={<FileCode />}
          label="Files"
          value={context.fileCount}
        />
        <MetadataItem
          icon={<Globe />}
          label="Tabs"
          value={context.browserTabCount}
        />
        <MetadataItem
          icon={<Terminal />}
          label="Terminal"
          value={context.terminalSessionCount}
        />
      </div>
      
      {/* Action buttons */}
      <div className="card-actions">
        <Button
          variant="primary"
          onClick={onRestore}
          className="flex-1"
        >
          <Play size={16} />
          Restore
        </Button>
        <IconButton
          variant="ghost"
          onClick={onDelete}
          icon={<Trash2 size={16} />}
        />
      </div>
      
      {/* Hover overlay for preview */}
      <div className="card-hover-overlay">
        <PreviewThumbnail context={context} />
      </div>
    </motion.div>
  );
};
```

**Context Card Styles:**
```css
.context-card {
  @apply relative p-5 rounded-xl;
  @apply bg-gradient-to-br from-gray-900/50 to-gray-900/30;
  @apply border border-white/5;
  @apply transition-all duration-300;
  @apply hover:border-indigo-500/30;
  @apply hover:shadow-lg hover:shadow-indigo-500/10;
}

.context-card.active {
  @apply border-indigo-500/50;
  @apply bg-gradient-to-br from-indigo-900/20 to-purple-900/10;
  @apply shadow-xl shadow-indigo-500/20;
}

.card-header {
  @apply mb-4;
}

.card-title {
  @apply text-base font-semibold text-gray-100;
  @apply truncate;
}

.card-subtitle {
  @apply text-sm text-gray-400;
}

.card-summary {
  @apply flex items-start gap-3 mb-4 p-3;
  @apply rounded-lg bg-black/20;
  @apply border border-white/5;
}

.summary-icon {
  @apply flex-shrink-0 text-purple-400;
  animation: pulse-glow 2s ease-in-out infinite;
}

.summary-text {
  @apply text-sm text-gray-300 leading-relaxed;
  @apply line-clamp-3;
}

.card-metadata {
  @apply flex items-center gap-4 mb-4;
  @apply text-sm text-gray-400;
}

.card-actions {
  @apply flex items-center gap-2;
}

.card-hover-overlay {
  @apply absolute inset-0 opacity-0 pointer-events-none;
  @apply transition-opacity duration-300;
  @apply bg-black/90 backdrop-blur-sm;
  @apply rounded-xl overflow-hidden;
}

.context-card:hover .card-hover-overlay {
  @apply opacity-100;
}

@keyframes pulse-glow {
  0%, 100% {
    opacity: 1;
    filter: drop-shadow(0 0 2px currentColor);
  }
  50% {
    opacity: 0.7;
    filter: drop-shadow(0 0 8px currentColor);
  }
}
```

#### 5.4.3 AI Chat Interface

```typescript
const AIChatInterface: React.FC = () => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  
  return (
    <div className="ai-chat-container">
      {/* Chat header */}
      <div className="chat-header">
        <div className="flex items-center gap-3">
          <div className="ai-avatar">
            <Sparkles className="ai-icon" />
          </div>
          <div>
            <h3 className="chat-title">AI Assistant</h3>
            <p className="chat-status">
              <span className="status-dot" />
              Ready to help
            </p>
          </div>
        </div>
        <ContextSelector />
      </div>
      
      {/* Messages area */}
      <div className="chat-messages">
        <AnimatePresence>
          {messages.map((message) => (
            <ChatMessage
              key={message.id}
              message={message}
              isUser={message.role === 'user'}
            />
          ))}
        </AnimatePresence>
        
        {isTyping && <TypingIndicator />}
        
        {/* Suggested prompts */}
        {messages.length === 0 && (
          <SuggestedPrompts onSelect={setInput} />
        )}
      </div>
      
      {/* Input area */}
      <div className="chat-input-container">
        <div className="chat-input-wrapper">
          <TextareaAutosize
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask about your context..."
            className="chat-input"
            maxRows={6}
            onKeyDown={handleKeyDown}
          />
          <div className="input-actions">
            <IconButton
              icon={<Paperclip />}
              tooltip="Attach file"
              onClick={handleAttach}
            />
            <Button
              variant="primary"
              size="sm"
              onClick={handleSend}
              disabled={!input.trim()}
            >
              <Send size={16} />
            </Button>
          </div>
        </div>
        
        {/* Token counter */}
        <div className="token-counter">
          <Zap size={12} />
          <span>{tokenCount} / 4000 tokens</span>
        </div>
      </div>
    </div>
  );
};

const ChatMessage: React.FC<{ message: ChatMessage; isUser: boolean }> = ({
  message,
  isUser
}) => {
  return (
    <motion.div
      className={`chat-message ${isUser ? 'user' : 'assistant'}`}
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <div className="message-avatar">
        {isUser ? (
          <User size={20} />
        ) : (
          <Sparkles size={20} className="ai-icon-animated" />
        )}
      </div>
      
      <div className="message-content">
        <div className="message-header">
          <span className="message-sender">
            {isUser ? 'You' : 'AI Assistant'}
          </span>
          <span className="message-time">
            {formatTime(message.timestamp)}
          </span>
        </div>
        
        <div className="message-body">
          <ReactMarkdown
            components={{
              code: CodeBlock,
              pre: PreBlock,
            }}
          >
            {message.content}
          </ReactMarkdown>
        </div>
        
        {!isUser && (
          <div className="message-actions">
            <IconButton
              icon={<Copy />}
              tooltip="Copy"
              size="xs"
              onClick={() => copyToClipboard(message.content)}
            />
            <IconButton
              icon={<ThumbsUp />}
              tooltip="Good response"
              size="xs"
            />
            <IconButton
              icon={<ThumbsDown />}
              tooltip="Bad response"
              size="xs"
            />
          </div>
        )}
      </div>
    </motion.div>
  );
};
```

**AI Chat Styles:**
```css
.ai-chat-container {
  @apply flex flex-col h-full;
  @apply bg-gradient-to-b from-gray-900 to-black;
}

.chat-header {
  @apply flex items-center justify-between p-4;
  @apply border-b border-white/10;
  @apply bg-gradient-to-r from-indigo-900/10 via-purple-900/10 to-pink-900/10;
}

.ai-avatar {
  @apply w-10 h-10 rounded-full;
  @apply bg-gradient-to-br from-indigo-500 to-purple-500;
  @apply flex items-center justify-center;
  @apply shadow-lg shadow-indigo-500/50;
}

.ai-icon {
  @apply text-white;
  animation: rotate-slow 4s linear infinite;
}

.chat-title {
  @apply text-base font-semibold text-gray-100;
}

.chat-status {
  @apply flex items-center gap-2 text-sm text-gray-400;
}

.status-dot {
  @apply w-2 h-2 rounded-full bg-green-500;
  animation: pulse 2s ease-in-out infinite;
}

.chat-messages {
  @apply flex-1 overflow-y-auto p-4 space-y-4;
  @apply scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent;
}

.chat-message {
  @apply flex gap-3;
}

.chat-message.user {
  @apply flex-row-reverse;
}

.message-avatar {
  @apply w-8 h-8 rounded-full flex-shrink-0;
  @apply flex items-center justify-center;
  @apply bg-gray-800 text-gray-400;
}

.chat-message.assistant .message-avatar {
  @apply bg-gradient-to-br from-indigo-500 to-purple-500;
  @apply text-white;
}

.message-content {
  @apply flex-1 max-w-2xl;
}

.chat-message.user .message-content {
  @apply flex flex-col items-end;
}

.message-body {
  @apply p-4 rounded-2xl;
  @apply bg-gray-800/50 text-gray-200;
  @apply border border-white/5;
}

.chat-message.user .message-body {
  @apply bg-gradient-to-br from-indigo-600 to-purple-600;
  @apply text-white border-0;
}

.message-actions {
  @apply flex items-center gap-1 mt-2;
}

.chat-input-container {
  @apply p-4 border-t border-white/10;
  @apply bg-gradient-to-t from-black/50 to-transparent;
}

.chat-input-wrapper {
  @apply relative rounded-xl;
  @apply bg-gray-900/50 border border-white/10;
  @apply focus-within:border-indigo-500/50;
  @apply transition-colors duration-200;
}

.chat-input {
  @apply w-full px-4 py-3 bg-transparent;
  @apply text-gray-200 placeholder-gray-500;
  @apply resize-none outline-none;
}

.input-actions {
  @apply absolute right-2 bottom-2;
  @apply flex items-center gap-2;
}

.token-counter {
  @apply flex items-center gap-2 mt-2;
  @apply text-xs text-gray-500;
}

@keyframes rotate-slow {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
```

#### 5.4.4 Context Timeline Visualization

```typescript
const ContextTimeline: React.FC = () => {
  const contexts = useContextStore(state => state.contexts);
  const [selectedDate, setSelectedDate] = useState(new Date());
  
  return (
    <div className="timeline-container">
      {/* Timeline header with date navigation */}
      <div className="timeline-header">
        <h2 className="timeline-title">Context Timeline</h2>
        <DateNavigator
          selectedDate={selectedDate}
          onChange={setSelectedDate}
        />
      </div>
      
      {/* Timeline visualization */}
      <div className="timeline-content">
        {/* Time axis */}
        <div className="time-axis">
          {Array.from({ length: 24 }, (_, i) => (
            <div key={i} className="time-mark">
              <span>{i}:00</span>
            </div>
          ))}
        </div>
        
        {/* Context blocks */}
        <div className="timeline-blocks">
          {contexts.map((context) => (
            <TimelineBlock
              key={context.id}
              context={context}
              onClick={() => handleContextClick(context)}
            />
          ))}
        </div>
        
        {/* Flow state indicator */}
        <FlowStateOverlay contexts={contexts} />
      </div>
      
      {/* Statistics panel */}
      <div className="timeline-stats">
        <StatCard
          icon={<Zap />}
          label="Flow Sessions"
          value={calculateFlowSessions(contexts)}
          trend="+12%"
        />
        <StatCard
          icon={<GitBranch />}
          label="Context Switches"
          value={contexts.length}
          trend="-8%"
        />
        <StatCard
          icon={<Clock />}
          label="Deep Work"
          value={calculateDeepWork(contexts)}
          trend="+23%"
        />
      </div>
    </div>
  );
};

const TimelineBlock: React.FC<{ context: Context }> = ({ context, onClick }) => {
  const startPos = calculatePosition(context.startTime);
  const duration = calculateDuration(context.startTime, context.endTime);
  
  return (
    <motion.div
      className="timeline-block"
      style={{
        left: `${startPos}%`,
        width: `${duration}%`,
      }}
      initial={{ scale: 0, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      whileHover={{ scale: 1.05, zIndex: 10 }}
      onClick={onClick}
    >
      <div className="block-content">
        <ContextIcon type={context.type} size={16} />
        <span className="block-label">{context.title}</span>
      </div>
      
      {/* Flow state indicator */}
      <div
        className="flow-indicator"
        style={{
          background: getFlowStateColor(context.flowDepth)
        }}
      />
      
      {/* Tooltip on hover */}
      <div className="block-tooltip">
        <p className="tooltip-title">{context.title}</p>
        <p className="tooltip-time">
          {formatTime(context.startTime)} - {formatTime(context.endTime)}
        </p>
        <p className="tooltip-summary">{context.aiSummary}</p>
      </div>
    </motion.div>
  );
};
```

**Timeline Styles:**
```css
.timeline-container {
  @apply flex flex-col h-full p-6;
  @apply bg-gradient-to-br from-gray-900 via-black to-gray-900;
}

.timeline-header {
  @apply flex items-center justify-between mb-6;
}

.timeline-title {
  @apply text-2xl font-bold;
  @apply bg-gradient-to-r from-indigo-400 to-purple-400;
  @apply bg-clip-text text-transparent;
}

.timeline-content {
  @apply relative flex-1 mb-6;
  @apply rounded-xl p-4;
  @apply bg-black/30 border border-white/5;
}

.time-axis {
  @apply flex justify-between mb-4;
  @apply text-xs text-gray-500;
  @apply border-b border-white/5 pb-2;
}

.timeline-blocks {
  @apply relative h-64;
}

.timeline-block {
  @apply absolute h-12 rounded-lg cursor-pointer;
  @apply bg-gradient-to-r from-indigo-600/80 to-purple-600/80;
  @apply border border-white/10;
  @apply transition-all duration-200;
  @apply hover:shadow-lg hover:shadow-indigo-500/50;
}

.block-content {
  @apply flex items-center gap-2 h-full px-3;
  @apply text-white text-sm font-medium;
}

.flow-indicator {
  @apply absolute bottom-0 left-0 right-0 h-1;
  @apply rounded-b-lg;
}

.block-tooltip {
  @apply absolute left-0 top-full mt-2 w-64;
  @apply p-4 rounded-lg;
  @apply bg-gray-900 border border-white/10;
  @apply shadow-xl opacity-0 pointer-events-none;
  @apply transition-opacity duration-200;
  @apply z-50;
}

.timeline-block:hover .block-tooltip {
  @apply opacity-100;
}

.timeline-stats {
  @apply grid grid-cols-3 gap-4;
}

.stat-card {
  @apply p-4 rounded-xl;
  @apply bg-gradient-to-br from-gray-800/50 to-gray-900/50;
  @apply border border-white/5;
}
```

#### 5.4.5 Button Component System

```typescript
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'ghost' | 'danger' | 'success';
  size: 'xs' | 'sm' | 'md' | 'lg';
  isLoading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  isLoading,
  leftIcon,
  rightIcon,
  children,
  onClick,
  disabled
}) => {
  return (
    <motion.button
      className={`btn btn-${variant} btn-${size}`}
      onClick={onClick}
      disabled={disabled || isLoading}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
    >
      {isLoading ? (
        <Loader className="animate-spin" size={16} />
      ) : (
        <>
          {leftIcon && <span className="btn-icon-left">{leftIcon}</span>}
          <span className="btn-text">{children}</span>
          {rightIcon && <span className="btn-icon-right">{rightIcon}</span>}
        </>
      )}
    </motion.button>
  );
};
```

**Button Styles:**
```css
.btn {
  @apply inline-flex items-center justify-center gap-2;
  @apply font-medium rounded-lg;
  @apply transition-all duration-200;
  @apply focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-black;
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
}

/* Sizes */
.btn-xs { @apply px-2 py-1 text-xs; }
.btn-sm { @apply px-3 py-1.5 text-sm; }
.btn-md { @apply px-4 py-2 text-base; }
.btn-lg { @apply px-6 py-3 text-lg; }

/* Variants */
.btn-primary {
  @apply bg-gradient-to-r from-indigo-600 to-purple-600;
  @apply text-white;
  @apply hover:from-indigo-700 hover:to-purple-700;
  @apply focus:ring-indigo-500;
  @apply shadow-lg shadow-indigo-500/20;
}

.btn-secondary {
  @apply bg-gray-800 text-gray-200;
  @apply hover:bg-gray-700;
  @apply border border-white/10;
  @apply focus:ring-gray-500;
}

.btn-ghost {
  @apply bg-transparent text-gray-400;
  @apply hover:bg-gray-800 hover:text-gray-200;
  @apply focus:ring-gray-500;
}

.btn-danger {
  @apply bg-gradient-to-r from-red-600 to-pink-600;
  @apply text-white;
  @apply hover:from-red-700 hover:to-pink-700;
  @apply focus:ring-red-500;
  @apply shadow-lg shadow-red-500/20;
}

.btn-success {
  @apply bg-gradient-to-r from-green-600 to-emerald-600;
  @apply text-white;
  @apply hover:from-green-700 hover:to-emerald-700;
  @apply focus:ring-green-500;
  @apply shadow-lg shadow-green-500/20;
}
```

---

## 6. Core Features - Detailed Specifications {#core-features}

### 6.1 Automatic Context Capture

**Feature ID:** F001  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.1.1 Technical Requirements

```typescript
interface CaptureOptions {
  includeFiles: boolean;
  includeTerminal: boolean;
  includeBrowser: boolean;
  includeScreenshots: boolean;
  captureDepth: 'minimal' | 'standard' | 'comprehensive';
  aiAnalysis: boolean;
}

interface Context {
  id: string;
  userId: string;
  timestamp: number;
  title: string;
  aiSummary: string;
  type: 'manual' | 'auto' | 'scheduled';
  tags: string[];
  
  // Captured data
  files: FileCaptureResult[];
  browserTabs: BrowserTabCapture[];
  terminalSessions: TerminalCapture[];
  ideState: IDEStateCapture;
  applicationWindows: ApplicationWindow[];
  clipboardHistory: ClipboardEntry[];
  screenshots: Screenshot[];
  
  // Metadata
  projectId?: string;
  branch?: string;
  commitHash?: string;
  focusDepth: number; // 0-100 score
  interruptionCount: number;
  duration: number; // milliseconds
  
  // Relationships
  parentContextId?: string; // For context chains
  relatedContextIds: string[];
  
  // Sync status
  syncStatus: 'pending' | 'synced' | 'error';
  lastSyncTime?: number;
  
  // Privacy
  excludedPaths: string[];
  redactedContent: boolean;
}
```

#### 6.1.2 Capture Triggers

1. **Time-Based Triggers:**
   - Every 15 minutes during active work (configurable)
   - Before system sleep/shutdown
   - At end of work day (configurable time)

2. **Event-Based Triggers:**
   - Project switch detected
   - Git branch change
   - IDE workspace change
   - Terminal directory change
   - Before closing 5+ browser tabs
   - Manual capture via hotkey (Cmd+Shift+C)

3. **Smart Triggers:**
   - Focus session completion (2+ hours uninterrupted)
   - Before/after meetings (calendar integration)
   - Context switch detected by AI
   - When opening new project/repository

#### 6.1.3 Capture Pipeline Implementation

```typescript
class ContextCaptureService {
  private captureQueue: PriorityQueue<CaptureTask>;
  private isCapturing: boolean = false;
  
  async captureContext(options: CaptureOptions): Promise<Context> {
    if (this.isCapturing) {
      throw new Error('Capture already in progress');
    }
    
    this.isCapturing = true;
    const startTime = Date.now();
    
    try {
      // Step 1: Gather raw data in parallel
      const [
        files,
        browser,
        terminal,
        ide,
        apps,
        clipboard,
        screenshots
      ] = await Promise.all([
        this.captureFiles(options),
        this.captureBrowser(options),
        this.captureTerminal(options),
        this.captureIDE(options),
        this.captureApplications(options),
        this.captureClipboard(options),
        this.captureScreenshots(options)
      ]);
      
      // Step 2: Process and filter data
      const processedData = await this.processRawCapture({
        files,
        browser,
        terminal,
        ide,
        apps,
        clipboard,
        screenshots
      });
      
      // Step 3: AI analysis
      const aiSummary = await this.aiEngine.generateContextSummary(
        processedData
      );
      
      // Step 4: Extract metadata
      const metadata = this.extractMetadata(processedData);
      
      // Step 5: Calculate focus depth score
      const focusDepth = this.calculateFocusDepth(processedData);
      
      // Step 6: Detect related contexts
      const relatedContexts = await this.findRelatedContexts(
        processedData,
        aiSummary
      );
      
      // Step 7: Assemble context object
      const context: Context = {
        id: generateUUID(),
        userId: this.userId,
        timestamp: startTime,
        title: metadata.title || 'Untitled Context',
        aiSummary,
        type: options.manual ? 'manual' : 'auto',
        tags: metadata.tags,
        
        files: processedData.files,
        browserTabs: processedData.browser,
        terminalSessions: processedData.terminal,
        ideState: processedData.ide,
        applicationWindows: processedData.apps,
        clipboardHistory: processedData.clipboard,
        screenshots: processedData.screenshots,
        
        projectId: metadata.projectId,
        branch: metadata.branch,
        commitHash: metadata.commitHash,
        focusDepth,
        interruptionCount: 0,
        duration: 0,
        
        relatedContextIds: relatedContexts,
        syncStatus: 'pending',
        excludedPaths: options.excludePaths || [],
        redactedContent: false
      };
      
      // Step 8: Save to local DB
      await this.localDB.saveContext(context);
      
      // Step 9: Queue for sync
      this.syncService.queueSync(context);
      
      // Step 10: Update UI
      this.events.emit('context:captured', context);
      
      // Analytics
      this.analytics.track('context_captured', {
        duration: Date.now() - startTime,
        fileCount: files.length,
        tabCount: browser.length,
        captureType: context.type
      });
      
      return context;
      
    } catch (error) {
      this.logger.error('Context capture failed', error);
      throw error;
    } finally {
      this.isCapturing = false;
    }
  }
  
  private async captureFiles(options: CaptureOptions): Promise<FileCaptureResult[]> {
    const activeFiles: FileCaptureResult[] = [];
    
    // Get files from all supported IDEs
    const ideFiles = await Promise.all([
      this.vscodeIntegration.getOpenFiles(),
      this.intellijIntegration.getOpenFiles(),
      this.sublimeIntegration.getOpenFiles()
    ]);
    
    for (const file of ideFiles.flat()) {
      // Skip excluded paths
      if (this.isExcluded(file.path, options.excludePaths)) {
        continue;
      }
      
      // Read file content
      let content = '';
      let contentHash = '';
      
      try {
        if (file.size < 1024 * 1024) { // < 1MB
          content = await fs.readFile(file.path, 'utf-8');
          contentHash = this.hashContent(content);
        } else {
          // For large files, capture excerpts
          content = await this.captureExcerpt(file.path);
          contentHash = this.hashFile(file.path);
        }
      } catch (error) {
        this.logger.warn(`Failed to read file: ${file.path}`, error);
        continue;
      }
      
      // Extract language
      const language = this.detectLanguage(file.path);
      
      // Get cursor position and selections
      const editorState = await this.getEditorState(file.path);
      
      // Get git status
      const gitStatus = await this.getGitStatus(file.path);
      
      activeFiles.push({
        path: file.path,
        content,
        contentHash,
        excerpt: content.substring(0, 500),
        language,
        cursorPosition: editorState.cursor,
        selections: editorState.selections,
        scrollPosition: editorState.scroll,
        folds: editorState.folds,
        breakpoints: editorState.breakpoints,
        bookmarks: editorState.bookmarks,
        fileSize: file.size,
        lastModified: file.mtime,
        gitStatus
      });
    }
    
    return activeFiles;
  }
  
  private async captureBrowser(options: CaptureOptions): Promise<BrowserTabCapture[]> {
    const tabs: BrowserTabCapture[] = [];
    
    // Connect to browser extension
    const browserTabs = await this.browserExtension.getAllTabs();
    
    for (const tab of browserTabs) {
      // Calculate relevance score using AI
      const relevanceScore = await this.aiEngine.scoreTabRelevance(tab);
      
      // Skip low-relevance tabs
      if (relevanceScore < 0.3) continue;
      
      // Categorize tab
      const category = this.categorizeTab(tab.url);
      
      // Capture screenshot thumbnail
      let screenshot: string | undefined;
      if (options.includeScreenshots) {
        screenshot = await this.browserExtension.captureTab(tab.id);
      }
      
      // Extract form data for unsaved work
      let formData: Record<string, string> | undefined;
      if (this.isFormPage(tab.url)) {
        formData = await this.browserExtension.extractFormData(tab.id);
      }
      
      tabs.push({
        url: tab.url,
        title: tab.title,
        favicon: tab.favicon,
        screenshot,
        scrollPosition: await this.browserExtension.getScrollPosition(tab.id),
        formData,
        selectedText: await this.browserExtension.getSelection(tab.id),
        openTime: tab.openTime,
        lastActiveTime: tab.lastActiveTime,
        category,
        relevanceScore
      });
    }
    
    // Sort by relevance
    return tabs.sort((a, b) => b.relevanceScore - a.relevanceScore);
  }
  
  private async captureTerminal(options: CaptureOptions): Promise<TerminalCapture[]> {
    const sessions: TerminalCapture[] = [];
    
    // Get terminal sessions from all supported terminals
    const terminalApps = [
      'iTerm2',
      'Terminal',
      'Hyper',
      'Warp',
      'Alacritty',
      'Windows Terminal'
    ];
    
    for (const app of terminalApps) {
      const appSessions = await this.terminalIntegration.getSessions(app);
      
      for (const session of appSessions) {
        // Capture command history
        const history = await this.terminalIntegration.getHistory(
          session.id,
          100 // last 100 commands
        );
        
        // Capture output
        const output = await this.terminalIntegration.getOutput(
          session.id,
          1000 // last 1000 lines
        );
        
        // Get environment variables (filtered)
        const envVars = await this.terminalIntegration.getEnvVars(session.id);
        const filteredEnv = this.filterSensitiveEnv(envVars);
        
        // Get active processes
        const processes = await this.terminalIntegration.getProcesses(session.id);
        
        sessions.push({
          sessionId: session.id,
          workingDirectory: session.cwd,
          history: this.redactSensitiveCommands(history),
          output: this.redactSensitiveOutput(output),
          environmentVariables: filteredEnv,
          activeProcesses: processes,
          shell: session.shell,
          tabs: session.tabs
        });
      }
    }
    
    return sessions;
  }
  
  private calculateFocusDepth(data: ProcessedCaptureData): number {
    let score = 0;
    
    // More open files = higher focus
    score += Math.min(data.files.length * 5, 30);
    
    // Relevant browser tabs = higher focus
    const relevantTabs = data.browser.filter(t => t.relevanceScore > 0.7);
    score += Math.min(relevantTabs.length * 3, 20);
    
    // Terminal activity = higher focus
    score += data.terminal.length > 0 ? 15 : 0;
    
    // Breakpoints/debugging = deep focus
    const hasBreakpoints = data.files.some(f => f.breakpoints.length > 0);
    score += hasBreakpoints ? 15 : 0;
    
    // Long file selections = deep reading
    const hasLongSelections = data.files.some(
      f => f.selections.some(s => this.getSelectionLength(s) > 100)
    );
    score += hasLongSelections ? 10 : 0;
    
    // Active test runs = focused development
    const hasTests = data.terminal.some(t => 
      t.history.some(cmd => cmd.includes('test') || cmd.includes('jest'))
    );
    score += hasTests ? 10 : 0;
    
    return Math.min(score, 100);
  }
}
```

### 6.2 One-Click Context Restoration

**Feature ID:** F002  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.2.1 Restoration Pipeline

```typescript
class ContextRestorationService {
  async restoreContext(contextId: string): Promise<void> {
    const startTime = Date.now();
    
    try {
      // Step 1: Fetch context
      const context = await this.localDB.getContext(contextId);
      if (!context) {
        throw new Error('Context not found');
      }
      
      // Step 2: Show restoration UI
      this.showRestorationProgress(context);
      
      // Step 3: Restore in parallel
      const results = await Promise.allSettled([
        this.restoreFiles(context.files),
        this.restoreBrowserTabs(context.browserTabs),
        this.restoreTerminal(context.terminalSessions),
        this.restoreIDE(context.ideState),
        this.restoreApplications(context.applicationWindows)
      ]);
      
      // Step 4: Check for failures
      const failures = results.filter(r => r.status === 'rejected');
      if (failures.length > 0) {
        this.logger.warn('Some restoration steps failed', failures);
        this.showPartialRestoreNotification(failures);
      }
      
      // Step 5: Update context metadata
      await this.localDB.updateContext(contextId, {
        lastRestoredAt: Date.now(),
        restorationCount: context.restorationCount + 1
      });
      
      // Step 6: Show AI summary
      this.showContextSummary(context);
      
      // Step 7: Track analytics
      this.analytics.track('context_restored', {
        contextId,
        duration: Date.now() - startTime,
        fileCount: context.files.length,
        tabCount: context.browserTabs.length,
        failures: failures.length
      });
      
      // Step 8: Show success notification
      this.showSuccessNotification(context);
      
    } catch (error) {
      this.logger.error('Context restoration failed', error);
      this.showErrorNotification(error);
      throw error;
    }
  }
  
  private async restoreFiles(files: FileCaptureResult[]): Promise<void> {
    // Open files in appropriate IDEs
    const filesByIDE = this.groupFilesByIDE(files);
    
    for (const [ide, ideFiles] of Object.entries(filesByIDE)) {
      const integration = this.getIDEIntegration(ide);
      
      for (const file of ideFiles) {
        try {
          // Open file
          await integration.openFile(file.path);
          
          // Restore cursor position
          await integration.setCursorPosition(
            file.path,
            file.cursorPosition
          );
          
          // Restore selections
          for (const selection of file.selections) {
            await integration.addSelection(file.path, selection);
          }
          
          // Restore scroll position
          await integration.setScrollPosition(
            file.path,
            file.scrollPosition
          );
          
          // Restore folds
          await integration.setFolds(file.path, file.folds);
          
          // Restore breakpoints
          for (const breakpoint of file.breakpoints) {
            await integration.addBreakpoint(file.path, breakpoint);
          }
          
        } catch (error) {
          this.logger.error(`Failed to restore file: ${file.path}`, error);
        }
      }
    }
  }
  
  private async restoreBrowserTabs(tabs: BrowserTabCapture[]): Promise<void> {
    // Sort tabs by relevance
    const sortedTabs = tabs.sort((a, b) => b.relevanceScore - a.relevanceScore);
    
    // Open tabs in batches to avoid overwhelming the browser
    const batchSize = 5;
    for (let i = 0; i < sortedTabs.length; i += batchSize) {
      const batch = sortedTabs.slice(i, i + batchSize);
      
      await Promise.all(batch.map(async (tab) => {
        try {
          // Open tab
          const tabId = await this.browserExtension.openTab(tab.url);
          
          // Wait for page load
          await this.browserExtension.waitForLoad(tabId);
          
          // Restore scroll position
          await this.browserExtension.setScrollPosition(
            tabId,
            tab.scrollPosition
          );
          
          // Restore form data if exists
          if (tab.formData) {
            await this.browserExtension.fillForm(tabId, tab.formData);
          }
          
        } catch (error) {
          this.logger.error(`Failed to restore tab: ${tab.url}`, error);
        }
      }));
      
      // Small delay between batches
      await this.sleep(500);
    }
  }
  
  private async restoreTerminal(sessions: TerminalCapture[]): Promise<void> {
    for (const session of sessions) {
      try {
        // Create new terminal session
        const terminalId = await this.terminalIntegration.createSession(
          session.shell
        );
        
        // Set working directory
        await this.terminalIntegration.changeDirectory(
          terminalId,
          session.workingDirectory
        );
        
        // Optionally restore environment variables
        if (this.settings.restoreEnvVars) {
          await this.terminalIntegration.setEnvVars(
            terminalId,
            session.environmentVariables
          );
        }
        
        // Show command history context
        await this.terminalIntegration.sendComment(
          terminalId,
          `# Restored context - Previous commands:\n# ${session.history.slice(-5).join('\n# ')}`
        );
        
      } catch (error) {
        this.logger.error('Failed to restore terminal session', error);
      }
    }
  }
  
  private showContextSummary(context: Context): void {
    // Show overlay with AI summary
    this.overlayService.show({
      type: 'context-summary',
      content: {
        title: context.title,
        summary: context.aiSummary,
        timestamp: context.timestamp,
        files: context.files.length,
        tabs: context.browserTabs.length,
        focusDepth: context.focusDepth
      },
      duration: 10000, // 10 seconds
      position: 'top-right'
    });
  }
}
```

### 6.3 AI Context Assistant

**Feature ID:** F003  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.3.1 AI Assistant Implementation

```typescript
class AIAssistantService {
  private openai: OpenAI;
  private conversationHistory: Map<string, ChatMessage[]>;
  private vectorStore: VectorStore;
  
  async chat(
    message: string,
    contextId?: string,
    userId?: string
  ): Promise<AsyncIterableIterator<string>> {
    // Get conversation history
    const history = this.conversationHistory.get(userId || 'default') || [];
    
    // Get current context if provided
    let contextData = null;
    if (contextId) {
      contextData = await this.localDB.getContext(contextId);
    } else {
      // Use active context
      contextData = await this.getActiveContext();
    }
    
    // Build system prompt with context
    const systemPrompt = this.buildSystemPrompt(contextData);
    
    // Prepare messages
    const messages = [
      { role: 'system', content: systemPrompt },
      ...history,
      { role: 'user', content: message }
    ];
    
    // Stream response
    const stream = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages,
      stream: true,
      temperature: 0.7,
      max_tokens: 2000
    });
    
    // Track conversation
    history.push({ role: 'user', content: message });
    
    return this.streamWithHistory(stream, history, userId);
  }
  
  private buildSystemPrompt(context: Context | null): string {
    let prompt = `You are FlowVault's AI Assistant, an expert software development companion.

Your role is to:
1. Help developers understand their working context
2. Answer questions about code, files, and browser tabs in the current context
3. Suggest next steps and debugging strategies
4. Explain code patterns and architectural decisions
5. Help restore mental models after interruptions

Guidelines:
- Be concise but thorough
- Use code examples when helpful
- Reference specific files and line numbers from the context
- Proactively suggest relevant actions
- Maintain a friendly, collaborative tone
`;
    
    if (context) {
      prompt += `\n\nCurrent Context:
Title: ${context.title}
Summary: ${context.aiSummary}
Focus Depth: ${context.focusDepth}/100

Open Files (${context.files.length}):
${context.files.slice(0, 10).map(f => `- ${f.path} (${f.language})`).join('\n')}

Browser Tabs (${context.browserTabs.length}):
${context.browserTabs.slice(0, 5).map(t => `- ${t.title} (${t.url})`).join('\n')}

Recent Terminal Commands:
${context.terminalSessions[0]?.history.slice(-5).join('\n') || 'None'}
`;
    }
    
    return prompt;
  }
  
  async* streamWithHistory(
    stream: AsyncIterable<any>,
    history: ChatMessage[],
    userId: string
  ): AsyncIterableIterator<string> {
    let fullResponse = '';
    
    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || '';
      fullResponse += content;
      yield content;
    }
    
    // Save to history
    history.push({ role: 'assistant', content: fullResponse });
    this.conversationHistory.set(userId, history.slice(-20)); // Keep last 20 messages
  }
  
  // Proactive AI suggestions
  async getSuggestions(context: Context): Promise<string[]> {
    const suggestions: string[] = [];
    
    // Analyze context for suggestions
    const analysis = await this.analyzeContext(context);
    
    if (analysis.hasUncommittedChanges) {
      suggestions.push("You have uncommitted changes in 3 files. Would you like to review them?");
    }
    
    if (analysis.hasFailingTests) {
      suggestions.push("I noticed some tests are failing. Want me to help debug?");
    }
    
    if (analysis.hasOpenStackOverflow) {
      suggestions.push("You have Stack Overflow tabs open about async/await. Need help understanding that concept?");
    }
    
    if (analysis.hasLongFocusSession) {
      suggestions.push("You've been in flow for 2+ hours. Great work! Want to capture this context before taking a break?");
    }
    
    return suggestions;
  }
}
```

### 6.4 Team Context Sharing

**Feature ID:** F004  
**Priority:** P1 (High)  
**Complexity:** Medium

#### 6.4.1 Sharing Implementation

```typescript
interface SharedContext {
  id: string;
  contextId: string;
  sharedBy: string;
  sharedWith: string[]; // User IDs or 'team'
  shareType: 'view' | 'clone' | 'collaborate';
  expiresAt?: number;
  accessCount: number;
  comments: ContextComment[];
  reactions: ContextReaction[];
}

class ContextSharingService {
  async shareContext(
    contextId: string,
    shareWith: string[],
    options: ShareOptions
  ): Promise<string> {
    const context = await this.localDB.getContext(contextId);
    
    // Redact sensitive information
    const sanitizedContext = await this.sanitizeContext(context, options);
    
    // Create share record
    const share: SharedContext = {
      id: generateUUID(),
      contextId: context.id,
      sharedBy: this.userId,
      sharedWith: shareWith,
      shareType: options.type,
      expiresAt: options.expiresAt,
      accessCount: 0,
      comments: [],
      reactions: []
    };
    
    // Upload to backend
    const shareUrl = await this.api.post('/contexts/share', {
      context: sanitizedContext,
      share
    });
    
    // Notify recipients
    await this.notifyRecipients(shareWith, {
      senderName: this.getUserName(),
      contextTitle: context.title,
      shareUrl
    });
    
    return shareUrl;
  }
  
  async cloneSharedContext(shareId: string): Promise<Context> {
    // Fetch shared context
    const shared = await this.api.get(`/contexts/shared/${shareId}`);
    
    // Create local copy
    const localContext = {
      ...shared.context,
      id: generateUUID(),
      userId: this.userId,
      type: 'cloned',
      parentContextId: shared.context.id
    };
    
    // Save locally
    await this.localDB.saveContext(localContext);
    
    // Track access
    await this.api.post(`/contexts/shared/${shareId}/access`);
    
    return localContext;
  }
}
```

### 6.5 Focus Mode & Interruption Filtering

**Feature ID:** F005  
**Priority:** P1 (High)  
**Complexity:** Medium

```typescript
class FocusModeService {
  private isActive: boolean = false;
  private startTime: number = 0;
  private blockedNotifications: Notification[] = [];
  
  async enableFocusMode(duration?: number): Promise<void> {
    this.isActive = true;
    this.startTime = Date.now();
    
    // Configure notification filtering
    await this.configureNotificationFilters();
    
    // Set system Do Not Disturb
    await this.setSystemDND(true);
    
    // Show focus mode indicator
    this.overlayService.showFocusIndicator(duration);
    
    // Schedule auto-disable if duration specified
    if (duration) {
      setTimeout(() => this.disableFocusMode(), duration);
    }
    
    // Track focus session
    this.analytics.track('focus_mode_enabled', {
      duration,
      timestamp: this.startTime
    });
  }
  
  async disableFocusMode(): Promise<void> {
    if (!this.isActive) return;
    
    const sessionDuration = Date.now() - this.startTime;
    this.isActive = false;
    
    // Restore notifications
    await this.setSystemDND(false);
    
    // Show blocked notifications summary
    if (this.blockedNotifications.length > 0) {
      this.showBlockedNotificationsSummary();
    }
    
    // Track focus session completion
    this.analytics.track('focus_session_completed', {
      duration: sessionDuration,
      blockedNotifications: this.blockedNotifications.length
    });
    
    // Clear blocked notifications
    this.blockedNotifications = [];
  }
  
  shouldBlockNotification(notification: Notification): boolean {
    if (!this.isActive) return false;
    
    // Always allow critical notifications
    if (notification.priority === 'critical') {
      return false;
    }
    
    // Block based on source
    const blockedSources = this.settings.focusMode.blockedSources;
    if (blockedSources.includes(notification.source)) {
      this.blockedNotifications.push(notification);
      return true;
    }
    
    // Use AI to determine importance
    const importance = this.aiEngine.scoreNotificationImportance(
      notification,
      this.getActiveContext()
    );
    
    if (importance < 0.7) {
      this.blockedNotifications.push(notification);
      return true;
    }
    
    return false;
  }
}
```

---

## 7. Advanced Features {#advanced-features}

### 7.1 Context Search & Discovery

```typescript
class ContextSearchService {
  async search(query: string, filters?: SearchFilters): Promise<SearchResult[]> {
    // Generate query embedding
    const queryEmbedding = await this.embeddings.generate(query);
    
    // Vector similarity search
    const semanticResults = await this.vectorStore.search(
      queryEmbedding,
      filters?.limit || 20
    );
    
    // Traditional keyword search
    const keywordResults = await this.localDB.searchContexts(query, filters);
    
    // Merge and rank results
    const mergedResults = this.mergeResults(semanticResults, keywordResults);
    
    return mergedResults;
  }
  
  async findSimilarContexts(contextId: string): Promise<Context[]> {
    const context = await this.localDB.getContext(contextId);
    const embedding = await this.embeddings.generate(context.aiSummary);
    
    const similar = await this.vectorStore.search(embedding, 10);
    return similar.filter(c => c.id !== contextId);
  }
}
```

### 7.2 Context Analytics & Insights

```typescript
interface ProductivityInsights {
  // Time analytics
  totalWorkTime: number;
  deepWorkTime: number;
  fragmentedTime: number;
  
  // Context metrics
  contextSwitches: number;
  averageContextDuration: number;
  longestFlowSession: number;
  
  // Focus analytics
  focusScore: number; // 0-100
  interruptionRate: number;
  recoveryTime: number;
  
  // Project analytics
  projectDistribution: Record<string, number>;
  topProjects: Array<{ project: string; time: number }>;
  
  // Technology analytics
  languageDistribution: Record<string, number>;
  toolUsage: Record<string, number>;
  
  // Patterns
  peakProductivityHours: number[];
  contextSwitchPatterns: Array<{ from: string; to: string; frequency: number }>;
  
  // Trends
  weekOverWeekChange: number;
  monthOverMonthChange: number;
}

class AnalyticsService {
  async generateInsights(
    userId: string,
    timeRange: TimeRange
  ): Promise<ProductivityInsights> {
    const contexts = await this.localDB.getContextsInRange(userId, timeRange);
    
    // Calculate time metrics
    const timeMetrics = this.calculateTimeMetrics(contexts);
    
    // Calculate focus metrics
    const focusMetrics = this.calculateFocusMetrics(contexts);
    
    // Calculate project distribution
    const projectMetrics = this.calculateProjectMetrics(contexts);
    
    // Calculate technology usage
    const techMetrics = this.calculateTechnologyMetrics(contexts);
    
    // Detect patterns
    const patterns = await this.detectPatterns(contexts);
    
    // Calculate trends
    const trends = await this.calculateTrends(userId, timeRange);
    
    return {
      ...timeMetrics,
      ...focusMetrics,
      ...projectMetrics,
      ...techMetrics,
      ...patterns,
      ...trends
    };
  }
  
  private calculateTimeMetrics(contexts: Context[]): TimeMetrics {
    let totalWorkTime = 0;
    let deepWorkTime = 0;
    let fragmentedTime = 0;
    
    for (const context of contexts) {
      totalWorkTime += context.duration;
      
      if (context.focusDepth > 70) {
        deepWorkTime += context.duration;
      } else if (context.focusDepth < 30) {
        fragmentedTime += context.duration;
      }
    }
    
    return {
      totalWorkTime,
      deepWorkTime,
      fragmentedTime,
      contextSwitches: contexts.length,
      averageContextDuration: totalWorkTime / contexts.length,
      longestFlowSession: Math.max(...contexts.map(c => c.duration))
    };
  }
  
  async detectPatterns(contexts: Context[]): Promise<Patterns> {
    // Analyze context switches
    const switches: Array<{ from: string; to: string }> = [];
    
    for (let i = 1; i < contexts.length; i++) {
      switches.push({
        from: contexts[i - 1].projectId || 'unknown',
        to: contexts[i].projectId || 'unknown'
      });
    }
    
    // Group and count
    const switchFrequency = new Map<string, number>();
    switches.forEach(s => {
      const key = `${s.from}â†’${s.to}`;
      switchFrequency.set(key, (switchFrequency.get(key) || 0) + 1);
    });
    
    // Analyze peak hours
    const hourlyActivity = new Array(24).fill(0);
    contexts.forEach(c => {
      const hour = new Date(c.timestamp).getHours();
      hourlyActivity[hour] += c.duration;
    });
    
    const peakHours = hourlyActivity
      .map((activity, hour) => ({ hour, activity }))
      .sort((a, b) => b.activity - a.activity)
      .slice(0, 5)
      .map(h => h.hour);
    
    return {
      contextSwitchPatterns: Array.from(switchFrequency.entries())
        .map(([pattern, frequency]) => {
          const [from, to] = pattern.split('â†’');
          return { from, to, frequency };
        })
        .sort((a, b) => b.frequency - a.frequency)
        .slice(0, 10),
      peakProductivityHours: peakHours
    };
  }
}
```

### 7.3 Smart Notifications & Suggestions

```typescript
class SmartNotificationService {
  async generateNotifications(): Promise<Notification[]> {
    const notifications: Notification[] = [];
    const activeContext = await this.getActiveContext();
    const insights = await this.analytics.getCurrentInsights();
    
    // Long context without capture
    if (activeContext && Date.now() - activeContext.timestamp > 3600000) {
      notifications.push({
        id: generateUUID(),
        type: 'suggestion',
        priority: 'medium',
        title: 'Capture your progress?',
        message: "You've been working for over an hour. Save this context to preserve your flow state.",
        action: {
          label: 'Capture Now',
          handler: () => this.captureContext()
        }
      });
    }
    
    // Focus session achievement
    if (insights.longestFlowSession > 7200000) { // 2 hours
      notifications.push({
        type: 'achievement',
        priority: 'low',
        title: 'ðŸŽ‰ Flow Master!',
        message: 'You just completed a 2+ hour deep work session!',
        action: {
          label: 'View Stats',
          handler: () => this.showAnalytics()
        }
      });
    }
    
    // Context switch warning
    if (insights.contextSwitches > 20 && insights.deepWorkTime < 3600000) {
      notifications.push({
        type: 'insight',
        priority: 'medium',
        title: 'High context switching detected',
        message: 'You switched contexts 20+ times today with limited deep work. Try Focus Mode?',
        action: {
          label: 'Enable Focus Mode',
          handler: () => this.enableFocusMode()
        }
      });
    }
    
    // Similar past context
    const similar = await this.findSimilarPastContext(activeContext);
    if (similar) {
      notifications.push({
        type: 'suggestion',
        priority: 'high',
        title: 'Related context found',
        message: `You worked on something similar 2 days ago: "${similar.title}"`,
        action: {
          label: 'View Context',
          handler: () => this.viewContext(similar.id)
        }
      });
    }
    
    return notifications;
  }
  
  // Proactive context suggestions
  async suggestContextRestore(): Promise<Context | null> {
    const currentTime = new Date().getHours();
    const currentDay = new Date().getDay();
    
    // Find contexts at similar time/day in the past
    const historicalContexts = await this.localDB.getContextsByTimePattern({
      hour: currentTime,
      dayOfWeek: currentDay,
      limit: 10
    });
    
    if (historicalContexts.length === 0) return null;
    
    // Use AI to pick the most relevant
    const relevanceScores = await Promise.all(
      historicalContexts.map(async c => ({
        context: c,
        score: await this.aiEngine.scoreContextRelevance(c)
      }))
    );
    
    const best = relevanceScores.sort((a, b) => b.score - a.score)[0];
    
    if (best.score > 0.7) {
      return best.context;
    }
    
    return null;
  }
}
```

### 7.4 Collaborative Features

```typescript
interface CollaborationSession {
  id: string;
  contextId: string;
  participants: Participant[];
  startTime: number;
  endTime?: number;
  sharedCursor: CursorPosition[];
  chat: ChatMessage[];
  activities: Activity[];
}

class CollaborationService {
  private websocket: WebSocket;
  
  async startCollaboration(contextId: string): Promise<string> {
    const context = await this.localDB.getContext(contextId);
    
    // Create collaboration session
    const session: CollaborationSession = {
      id: generateUUID(),
      contextId,
      participants: [
        {
          userId: this.userId,
          name: this.userName,
          role: 'host',
          joinedAt: Date.now()
        }
      ],
      startTime: Date.now(),
      sharedCursor: [],
      chat: [],
      activities: []
    };
    
    // Start WebSocket connection
    await this.websocket.send('collab:start', session);
    
    // Share invite link
    const inviteLink = await this.generateInviteLink(session.id);
    
    return inviteLink;
  }
  
  async joinCollaboration(sessionId: string): Promise<void> {
    // Join WebSocket room
    await this.websocket.send('collab:join', {
      sessionId,
      userId: this.userId,
      userName: this.userName
    });
    
    // Listen for events
    this.websocket.on('collab:cursor', (data) => {
      this.updateRemoteCursor(data);
    });
    
    this.websocket.on('collab:activity', (data) => {
      this.handleRemoteActivity(data);
    });
    
    this.websocket.on('collab:chat', (data) => {
      this.handleChatMessage(data);
    });
  }
  
  async shareCursorPosition(position: CursorPosition): Promise<void> {
    await this.websocket.send('collab:cursor', {
      userId: this.userId,
      position
    });
  }
  
  async shareActivity(activity: Activity): Promise<void> {
    await this.websocket.send('collab:activity', {
      userId: this.userId,
      activity
    });
  }
}
```

### 7.5 Context Automation & Workflows

```typescript
interface Workflow {
  id: string;
  name: string;
  trigger: WorkflowTrigger;
  actions: WorkflowAction[];
  enabled: boolean;
}

interface WorkflowTrigger {
  type: 'time' | 'event' | 'condition';
  config: any;
}

interface WorkflowAction {
  type: 'capture' | 'restore' | 'notify' | 'sync' | 'custom';
  config: any;
}

class WorkflowService {
  private workflows: Map<string, Workflow> = new Map();
  
  async createWorkflow(workflow: Workflow): Promise<void> {
    this.workflows.set(workflow.id, workflow);
    
    // Register trigger
    this.registerTrigger(workflow);
    
    await this.localDB.saveWorkflow(workflow);
  }
  
  private registerTrigger(workflow: Workflow): void {
    switch (workflow.trigger.type) {
      case 'time':
        this.registerTimeTrigger(workflow);
        break;
      case 'event':
        this.registerEventTrigger(workflow);
        break;
      case 'condition':
        this.registerConditionTrigger(workflow);
        break;
    }
  }
  
  private registerTimeTrigger(workflow: Workflow): void {
    const { schedule } = workflow.trigger.config;
    
    // Use cron-like scheduling
    cron.schedule(schedule, async () => {
      if (workflow.enabled) {
        await this.executeWorkflow(workflow);
      }
    });
  }
  
  private registerEventTrigger(workflow: Workflow): void {
    const { event } = workflow.trigger.config;
    
    this.events.on(event, async (data) => {
      if (workflow.enabled && this.evaluateConditions(workflow, data)) {
        await this.executeWorkflow(workflow, data);
      }
    });
  }
  
  private async executeWorkflow(
    workflow: Workflow,
    data?: any
  ): Promise<void> {
    this.logger.info(`Executing workflow: ${workflow.name}`);
    
    for (const action of workflow.actions) {
      try {
        await this.executeAction(action, data);
      } catch (error) {
        this.logger.error(`Workflow action failed: ${action.type}`, error);
      }
    }
    
    this.analytics.track('workflow_executed', {
      workflowId: workflow.id,
      workflowName: workflow.name
    });
  }
  
  private async executeAction(action: WorkflowAction, data?: any): Promise<void> {
    switch (action.type) {
      case 'capture':
        await this.contextCapture.captureContext(action.config);
        break;
        
      case 'restore':
        await this.contextRestore.restoreContext(action.config.contextId);
        break;
        
      case 'notify':
        await this.notifications.show(action.config);
        break;
        
      case 'sync':
        await this.sync.syncAll();
        break;
        
      case 'custom':
        await this.pluginManager.executePlugin(
          action.config.pluginId,
          action.config.action,
          data
        );
        break;
    }
  }
}

// Example workflows
const exampleWorkflows: Workflow[] = [
  {
    id: 'auto-capture-eod',
    name: 'Auto-capture at end of day',
    trigger: {
      type: 'time',
      config: { schedule: '0 18 * * *' } // 6 PM daily
    },
    actions: [
      {
        type: 'capture',
        config: { captureDepth: 'comprehensive' }
      },
      {
        type: 'notify',
        config: {
          title: 'Context saved',
          message: 'Your end-of-day context has been captured'
        }
      }
    ],
    enabled: true
  },
  {
    id: 'restore-morning',
    name: 'Restore yesterday\'s context in the morning',
    trigger: {
      type: 'time',
      config: { schedule: '0 9 * * *' } // 9 AM daily
    },
    actions: [
      {
        type: 'restore',
        config: { contextId: 'last' }
      }
    ],
    enabled: true
  },
  {
    id: 'focus-mode-deep-work',
    name: 'Enable focus mode during deep work hours',
    trigger: {
      type: 'time',
      config: { schedule: '0 10-12,14-16 * * *' } // 10 AM-12 PM, 2-4 PM
    },
    actions: [
      {
        type: 'custom',
        config: {
          pluginId: 'focus-mode',
          action: 'enable',
          duration: 7200000 // 2 hours
        }
      }
    ],
    enabled: false
  }
];
```

### 7.6 Context Templates

```typescript
interface ContextTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  icon: string;
  files: string[]; // File paths or patterns
  browserTabs: string[]; // URLs
  terminalCommands: string[];
  ideConfig: any;
  tags: string[];
}

class TemplateService {
  async createFromContext(contextId: string): Promise<ContextTemplate> {
    const context = await this.localDB.getContext(contextId);
    
    const template: ContextTemplate = {
      id: generateUUID(),
      name: `${context.title} Template`,
      description: context.aiSummary,
      category: this.detectCategory(context),
      icon: this.selectIcon(context),
      files: context.files.map(f => this.generalizePath(f.path)),
      browserTabs: context.browserTabs.map(t => t.url),
      terminalCommands: context.terminalSessions[0]?.history.slice(-5) || [],
      ideConfig: context.ideState,
      tags: context.tags
    };
    
    await this.localDB.saveTemplate(template);
    
    return template;
  }
  
  async applyTemplate(templateId: string): Promise<Context> {
    const template = await this.localDB.getTemplate(templateId);
    
    // Create new context from template
    const context: Context = {
      id: generateUUID(),
      userId: this.userId,
      timestamp: Date.now(),
      title: template.name,
      aiSummary: template.description,
      type: 'manual',
      tags: template.tags,
      files: [],
      browserTabs: [],
      terminalSessions: [],
      // ... other fields
    };
    
    // Apply file patterns
    for (const pattern of template.files) {
      const matchedFiles = await this.findMatchingFiles(pattern);
      for (const file of matchedFiles) {
        await this.ideIntegration.openFile(file);
      }
    }
    
    // Open browser tabs
    for (const url of template.browserTabs) {
      await this.browserExtension.openTab(url);
    }
    
    // Execute terminal commands
    if (template.terminalCommands.length > 0) {
      const terminalId = await this.terminalIntegration.createSession();
      for (const command of template.terminalCommands) {
        await this.terminalIntegration.sendCommand(terminalId, command);
      }
    }
    
    // Capture the applied template as a context
    await this.sleep(2000); // Wait for everything to open
    return await this.contextCapture.captureContext({
      includeFiles: true,
      includeBrowser: true,
      includeTerminal: true,
      captureDepth: 'standard',
      aiAnalysis: true
    });
  }
}

// Built-in templates
const builtInTemplates: ContextTemplate[] = [
  {
    id: 'react-dev',
    name: 'React Development',
    description: 'Set up for React component development',
    category: 'frontend',
    icon: 'âš›ï¸',
    files: [
      'src/components/**/*.tsx',
      'src/App.tsx',
      'package.json'
    ],
    browserTabs: [
      'http://localhost:3000',
      'https://react.dev/reference',
      'https://tailwindcss.com/docs'
    ],
    terminalCommands: [
      'npm run dev'
    ],
    ideConfig: {},
    tags: ['react', 'frontend', 'typescript']
  },
  {
    id: 'debugging',
    name: 'Debugging Session',
    description: 'Set up for debugging with logs and breakpoints',
    category: 'debugging',
    icon: 'ðŸ›',
    files: [
      'src/**/*.log',
      'tests/**/*.test.ts'
    ],
    browserTabs: [
      'http://localhost:3000/debug',
      'https://stackoverflow.com'
    ],
    terminalCommands: [
      'npm run test:debug',
      'tail -f logs/error.log'
    ],
    ideConfig: {
      enableBreakpoints: true,
      openDebugConsole: true
    },
    tags: ['debugging', 'testing']
  },
  {
    id: 'api-dev',
    name: 'API Development',
    description: 'Backend API development setup',
    category: 'backend',
    icon: 'ðŸ”Œ',
    files: [
      'src/routes/**/*.ts',
      'src/controllers/**/*.ts',
      'src/models/**/*.ts'
    ],
    browserTabs: [
      'http://localhost:8000/docs',
      'https://expressjs.com/en/api.html'
    ],
    terminalCommands: [
      'npm run dev',
      'curl http://localhost:8000/health'
    ],
    ideConfig: {},
    tags: ['backend', 'api', 'nodejs']
  }
];
```

---

## 8. Data Models & Database Schema {#data-models}

### 8.1 SQLite Schema (Local Database)

```sql
-- Users table
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  avatar_url TEXT,
  settings TEXT, -- JSON
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Contexts table
CREATE TABLE contexts (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  title TEXT NOT NULL,
  ai_summary TEXT,
  type TEXT NOT NULL, -- 'manual', 'auto', 'scheduled'
  tags TEXT, -- JSON array
  project_id TEXT,
  branch TEXT,
  commit_hash TEXT,
  focus_depth INTEGER,
  interruption_count INTEGER DEFAULT 0,
  duration INTEGER DEFAULT 0,
  parent_context_id TEXT,
  related_context_ids TEXT, -- JSON array
  sync_status TEXT DEFAULT 'pending',
  last_sync_time INTEGER,
  excluded_paths TEXT, -- JSON array
  redacted_content INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (parent_context_id) REFERENCES contexts(id)
);

CREATE INDEX idx_contexts_user_id ON contexts(user_id);
CREATE INDEX idx_contexts_timestamp ON contexts(timestamp);
CREATE INDEX idx_contexts_project_id ON contexts(project_id);
CREATE INDEX idx_contexts_sync_status ON contexts(sync_status);

-- Files table
CREATE TABLE files (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  path TEXT NOT NULL,
  content TEXT,
  content_hash TEXT NOT NULL,
  excerpt TEXT,
  language TEXT,
  cursor_line INTEGER,
  cursor_column INTEGER,
  selections TEXT, -- JSON
  scroll_position INTEGER,
  folds TEXT, -- JSON array
  breakpoints TEXT, -- JSON array
  bookmarks TEXT, -- JSON
  file_size INTEGER,
  last_modified INTEGER,
  git_branch TEXT,
  git_changes INTEGER,
  git_staged INTEGER,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_files_context_id ON files(context_id);
CREATE INDEX idx_files_path ON files(path);

-- Browser tabs table
CREATE TABLE browser_tabs (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  url TEXT NOT NULL,
  title TEXT,
  favicon TEXT,
  screenshot TEXT, -- Base64 or URL
  scroll_position INTEGER,
  form_data TEXT, -- JSON
  selected_text TEXT,
  open_time INTEGER,
  last_active_time INTEGER,
  category TEXT,
  relevance_score REAL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_browser_tabs_context_id ON browser_tabs(context_id);

-- Terminal sessions table
CREATE TABLE terminal_sessions (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  working_directory TEXT,
  history TEXT, -- JSON array
  output TEXT,
  environment_variables TEXT, -- JSON
  active_processes TEXT, -- JSON array
  shell TEXT,
  tabs TEXT, -- JSON array
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_terminal_sessions_context_id ON terminal_sessions(context_id);

-- IDE state table
CREATE TABLE ide_states (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  type TEXT NOT NULL,
  open_projects TEXT, -- JSON array
  workspace TEXT, -- JSON
  extensions TEXT, -- JSON array
  debug_sessions TEXT, -- JSON array
  run_configurations TEXT, -- JSON array
  search_history TEXT, -- JSON array
  recent_files TEXT, -- JSON array
  pinned_files TEXT, -- JSON array
  split_layout TEXT, -- JSON
  editor_groups TEXT, -- JSON array
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_ide_states_context_id ON ide_states(context_id);

-- Context embeddings table (for semantic search)
CREATE TABLE context_embeddings (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  embedding BLOB NOT NULL, -- Vector embedding
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_context_embeddings_context_id ON context_embeddings(context_id);

-- Workflows table
CREATE TABLE workflows (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  trigger_type TEXT NOT NULL,
  trigger_config TEXT, -- JSON
  actions TEXT, -- JSON array
  enabled INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_workflows_user_id ON workflows(user_id);

-- Templates table
CREATE TABLE templates (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT,
  icon TEXT,
  files TEXT, -- JSON array
  browser_tabs TEXT, -- JSON array
  terminal_commands TEXT, -- JSON array
  ide_config TEXT, -- JSON
  tags TEXT, -- JSON array
  is_public INTEGER DEFAULT 0,
  usage_count INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_templates_user_id ON templates(user_id);
CREATE INDEX idx_templates_category ON templates(category);

-- Analytics events table
CREATE TABLE analytics_events (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  event_name TEXT NOT NULL,
  event_data TEXT, -- JSON
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_analytics_events_user_id ON analytics_events(user_id);
CREATE INDEX idx_analytics_events_timestamp ON analytics_events(timestamp);

-- Settings table
CREATE TABLE settings (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  key TEXT NOT NULL,
  value TEXT, -- JSON
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE(user_id, key)
);

CREATE INDEX idx_settings_user_id ON settings(user_id);
```

### 8.2 PostgreSQL Schema (Backend Database)

```sql
-- Users table (backend)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255),
  avatar_url TEXT,
  password_hash VARCHAR(255),
  subscription_tier VARCHAR(50) DEFAULT 'free',
  subscription_status VARCHAR(50),
  stripe_customer_id VARCHAR(255),
  settings JSONB,
  last_login_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_subscription_tier ON users(subscription_tier);

-- Contexts table (cloud storage)
CREATE TABLE contexts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  local_id VARCHAR(255), -- ID from client
  timestamp BIGINT NOT NULL,
  title TEXT NOT NULL,
  ai_summary TEXT,
  type VARCHAR(50) NOT NULL,
  tags JSONB,
  project_id VARCHAR(255),
  branch VARCHAR(255),
  commit_hash VARCHAR(255),
  focus_depth INTEGER,
  interruption_count INTEGER DEFAULT 0,
  duration INTEGER DEFAULT 0,
  parent_context_id UUID,
  related_context_ids JSONB,
  excluded_paths JSONB,
  redacted_content BOOLEAN DEFAULT FALSE,
  data JSONB, -- Full context data
  embedding vector(1536), -- For vector similarity search
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_context_id) REFERENCES contexts(id)
);

CREATE INDEX idx_contexts_user_id ON contexts(user_id);
CREATE INDEX idx_contexts_timestamp ON contexts(timestamp);
CREATE INDEX idx_contexts_project_id ON contexts(project_id);
CREATE INDEX idx_contexts_embedding ON contexts USING ivfflat (embedding vector_cosine_ops);

-- Shared contexts table
CREATE TABLE shared_contexts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  context_id UUID NOT NULL,
  shared_by UUID NOT NULL,
  share_type VARCHAR(50) NOT NULL, -- 'view', 'clone', 'collaborate'
  expires_at TIMESTAMP,
  access_count INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE,
  FOREIGN KEY (shared_by) REFERENCES users(id)
);

CREATE INDEX idx_shared_contexts_context_id ON shared_contexts(context_id);

-- Shared context access table
CREATE TABLE shared_context_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shared_context_id UUID NOT NULL,
  user_id UUID,
  share_token VARCHAR(255),
  accessed_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (shared_context_id) REFERENCES shared_contexts(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Teams table
CREATE TABLE teams (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  owner_id UUID NOT NULL,
  subscription_tier VARCHAR(50) DEFAULT 'team',
  settings JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (owner_id) REFERENCES users(id)
);

-- Team members table
CREATE TABLE team_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  team_id UUID NOT NULL,
  user_id UUID NOT NULL,
  role VARCHAR(50) DEFAULT 'member', -- 'admin', 'member'
  joined_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE(team_id, user_id)
);

-- Subscriptions table
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID,
  team_id UUID,
  stripe_subscription_id VARCHAR(255) UNIQUE,
  plan VARCHAR(50) NOT NULL,
  status VARCHAR(50) NOT NULL,
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,

-- Subscriptions table
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID,
  team_id UUID,
  stripe_subscription_id VARCHAR(255) UNIQUE,
  plan VARCHAR(50) NOT NULL,
  status VARCHAR(50) NOT NULL,
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE
);

-- Analytics aggregations table
CREATE TABLE analytics_aggregations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  date DATE NOT NULL,
  total_work_time INTEGER DEFAULT 0,
  deep_work_time INTEGER DEFAULT 0,
  fragmented_time INTEGER DEFAULT 0,
  context_switches INTEGER DEFAULT 0,
  focus_score INTEGER DEFAULT 0,
  metrics JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE(user_id, date)
);

CREATE INDEX idx_analytics_user_date ON analytics_aggregations(user_id, date);

-- API usage tracking
CREATE TABLE api_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  endpoint VARCHAR(255) NOT NULL,
  method VARCHAR(10) NOT NULL,
  status_code INTEGER,
  response_time INTEGER,
  timestamp TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_api_usage_user_id ON api_usage(user_id);
CREATE INDEX idx_api_usage_timestamp ON api_usage(timestamp);
```

### 8.3 Data Access Layer

```typescript
class DatabaseService {
  private sqlite: Database;
  private postgres: Pool;
  
  constructor() {
    this.sqlite = new Database(path.join(app.getPath('userData'), 'flowvault.db'));
    this.initializeSQLite();
  }
  
  private async initializeSQLite(): Promise<void> {
    // Run migrations
    await this.sqlite.exec(SQLITE_SCHEMA);
    
    // Enable WAL mode for better concurrency
    await this.sqlite.exec('PRAGMA journal_mode=WAL');
    
    // Enable foreign keys
    await this.sqlite.exec('PRAGMA foreign_keys=ON');
  }
  
  // Context operations
  async saveContext(context: Context): Promise<void> {
    const stmt = this.sqlite.prepare(`
      INSERT INTO contexts (
        id, user_id, timestamp, title, ai_summary, type, tags,
        project_id, branch, commit_hash, focus_depth, 
        interruption_count, duration, parent_context_id,
        related_context_ids, sync_status, excluded_paths,
        redacted_content, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    await stmt.run(
      context.id,
      context.userId,
      context.timestamp,
      context.title,
      context.aiSummary,
      context.type,
      JSON.stringify(context.tags),
      context.projectId,
      context.branch,
      context.commitHash,
      context.focusDepth,
      context.interruptionCount,
      context.duration,
      context.parentContextId,
      JSON.stringify(context.relatedContextIds),
      context.syncStatus,
      JSON.stringify(context.excludedPaths),
      context.redactedContent ? 1 : 0,
      Date.now(),
      Date.now()
    );
    
    // Save related data
    await this.saveFiles(context.id, context.files);
    await this.saveBrowserTabs(context.id, context.browserTabs);
    await this.saveTerminalSessions(context.id, context.terminalSessions);
    await this.saveIDEState(context.id, context.ideState);
  }
  
  async getContext(contextId: string): Promise<Context | null> {
    const contextRow = await this.sqlite.get(
      'SELECT * FROM contexts WHERE id = ?',
      contextId
    );
    
    if (!contextRow) return null;
    
    // Load related data
    const [files, browserTabs, terminalSessions, ideState] = await Promise.all([
      this.getFiles(contextId),
      this.getBrowserTabs(contextId),
      this.getTerminalSessions(contextId),
      this.getIDEState(contextId)
    ]);
    
    return this.mapToContext(contextRow, {
      files,
      browserTabs,
      terminalSessions,
      ideState
    });
  }
  
  async searchContexts(
    query: string,
    filters?: SearchFilters
  ): Promise<Context[]> {
    let sql = `
      SELECT * FROM contexts
      WHERE user_id = ?
      AND (
        title LIKE ? OR
        ai_summary LIKE ? OR
        tags LIKE ?
      )
    `;
    
    const params: any[] = [
      filters?.userId || this.currentUserId,
      `%${query}%`,
      `%${query}%`,
      `%${query}%`
    ];
    
    if (filters?.projectId) {
      sql += ' AND project_id = ?';
      params.push(filters.projectId);
    }
    
    if (filters?.startDate) {
      sql += ' AND timestamp >= ?';
      params.push(filters.startDate);
    }
    
    if (filters?.endDate) {
      sql += ' AND timestamp <= ?';
      params.push(filters.endDate);
    }
    
    sql += ' ORDER BY timestamp DESC LIMIT ?';
    params.push(filters?.limit || 50);
    
    const rows = await this.sqlite.all(sql, ...params);
    
    return Promise.all(
      rows.map(row => this.getContext(row.id))
    );
  }
  
  // Batch operations for performance
  async saveFiles(contextId: string, files: FileCaptureResult[]): Promise<void> {
    const stmt = this.sqlite.prepare(`
      INSERT INTO files (
        id, context_id, path, content, content_hash, excerpt,
        language, cursor_line, cursor_column, selections,
        scroll_position, folds, breakpoints, bookmarks,
        file_size, last_modified, git_branch, git_changes,
        git_staged, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    const insert = this.sqlite.transaction((files: FileCaptureResult[]) => {
      for (const file of files) {
        stmt.run(
          generateUUID(),
          contextId,
          file.path,
          file.content,
          file.contentHash,
          file.excerpt,
          file.language,
          file.cursorPosition.line,
          file.cursorPosition.column,
          JSON.stringify(file.selections),
          file.scrollPosition,
          JSON.stringify(file.folds),
          JSON.stringify(file.breakpoints),
          JSON.stringify(file.bookmarks),
          file.fileSize,
          file.lastModified,
          file.gitStatus?.branch,
          file.gitStatus?.changes,
          file.gitStatus?.staged ? 1 : 0,
          Date.now()
        );
      }
    });
    
    insert(files);
  }
}
```

---

## 9. API Specifications {#api-specifications}

### 9.1 REST API Endpoints

```typescript
// Base URL: https://api.flowvault.com/v1

interface APIEndpoints {
  // Authentication
  'POST /auth/register': {
    request: { email: string; password: string; name: string };
    response: { userId: string; token: string };
  };
  
  'POST /auth/login': {
    request: { email: string; password: string };
    response: { userId: string; token: string; refreshToken: string };
  };
  
  'POST /auth/refresh': {
    request: { refreshToken: string };
    response: { token: string };
  };
  
  // Contexts
  'POST /contexts': {
    request: { context: Context };
    response: { contextId: string };
  };
  
  'GET /contexts/:id': {
    response: { context: Context };
  };
  
  'GET /contexts': {
    query: { 
      limit?: number; 
      offset?: number;
      projectId?: string;
      startDate?: number;
      endDate?: number;
    };
    response: { contexts: Context[]; total: number };
  };
  
  'PUT /contexts/:id': {
    request: { context: Partial<Context> };
    response: { success: boolean };
  };
  
  'DELETE /contexts/:id': {
    response: { success: boolean };
  };
  
  // Context Search
  'POST /contexts/search': {
    request: { 
      query: string; 
      filters?: SearchFilters;
      semantic?: boolean;
    };
    response: { results: SearchResult[] };
  };
  
  // Context Sharing
  'POST /contexts/:id/share': {
    request: { 
      shareWith: string[];
      shareType: 'view' | 'clone' | 'collaborate';
      expiresAt?: number;
    };
    response: { shareUrl: string; shareId: string };
  };
  
  'GET /contexts/shared/:shareId': {
    response: { context: Context; share: SharedContext };
  };
  
  'POST /contexts/shared/:shareId/access': {
    response: { success: boolean };
  };
  
  // AI
  'POST /ai/chat': {
    request: { 
      message: string; 
      contextId?: string;
      conversationId?: string;
    };
    response: { 
      response: string; 
      conversationId: string;
    };
  };
  
  'POST /ai/summarize': {
    request: { contextId: string };
    response: { summary: string };
  };
  
  'POST /ai/suggest': {
    request: { contextId: string };
    response: { suggestions: string[] };
  };
  
  // Analytics
  'GET /analytics/insights': {
    query: { 
      startDate: number; 
      endDate: number;
      granularity?: 'day' | 'week' | 'month';
    };
    response: { insights: ProductivityInsights };
  };
  
  'GET /analytics/trends': {
    query: { period: 'week' | 'month' | 'quarter' };
    response: { trends: TrendData };
  };
  
  // Sync
  'POST /sync/contexts': {
    request: { contexts: Context[] };
    response: { synced: string[]; failed: string[] };
  };
  
  'GET /sync/status': {
    response: { 
      lastSyncTime: number;
      pendingCount: number;
      status: 'synced' | 'pending' | 'error';
    };
  };
  
  // Teams
  'POST /teams': {
    request: { name: string };
    response: { teamId: string };
  };
  
  'POST /teams/:id/members': {
    request: { userIds: string[]; role: 'admin' | 'member' };
    response: { success: boolean };
  };
  
  'GET /teams/:id/contexts': {
    query: { limit?: number; offset?: number };
    response: { contexts: Context[]; total: number };
  };
  
  // Subscriptions
  'POST /subscriptions/checkout': {
    request: { plan: 'pro' | 'team'; interval: 'month' | 'year' };
    response: { checkoutUrl: string };
  };
  
  'POST /subscriptions/portal': {
    response: { portalUrl: string };
  };
  
  'GET /subscriptions/current': {
    response: { subscription: Subscription };
  };
}
```

### 9.2 WebSocket Events

```typescript
// WebSocket URL: wss://ws.flowvault.com

interface WebSocketEvents {
  // Client â†’ Server
  'context:capture': { context: Context };
  'context:update': { contextId: string; updates: Partial<Context> };
  'sync:request': { since: number };
  
  // Server â†’ Client
  'context:captured': { context: Context };
  'context:updated': { contextId: string; updates: Partial<Context> };
  'sync:completed': { contexts: Context[] };
  'sync:error': { error: string };
  
  // Collaboration
  'collab:start': { session: CollaborationSession };
  'collab:join': { sessionId: string; participant: Participant };
  'collab:leave': { sessionId: string; userId: string };
  'collab:cursor': { sessionId: string; userId: string; position: CursorPosition };
  'collab:activity': { sessionId: string; userId: string; activity: Activity };
  'collab:chat': { sessionId: string; message: ChatMessage };
  
  // Real-time notifications
  'notification:new': { notification: Notification };
  'notification:read': { notificationId: string };
}
```

### 9.3 Rate Limiting

```typescript
const rateLimits = {
  free: {
    'POST /contexts': { limit: 100, window: '1h' },
    'POST /ai/chat': { limit: 50, window: '1d' },
    'POST /contexts/search': { limit: 200, window: '1h' },
    'GET *': { limit: 1000, window: '1h' }
  },
  pro: {
    'POST /contexts': { limit: 500, window: '1h' },
    'POST /ai/chat': { limit: 500, window: '1d' },
    'POST /contexts/search': { limit: 1000, window: '1h' },
    'GET *': { limit: 5000, window: '1h' }
  },
  team: {
    'POST /contexts': { limit: 2000, window: '1h' },
    'POST /ai/chat': { limit: 2000, window: '1d' },
    'POST /contexts/search': { limit: 5000, window: '1h' },
    'GET *': { limit: 20000, window: '1h' }
  }
};
```

---

## 10. Security & Privacy {#security-privacy}

### 10.1 Data Encryption

```typescript
class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private keyDerivation = 'pbkdf2';
  
  // Encrypt sensitive data before storage
  async encrypt(data: string, password: string): Promise<EncryptedData> {
    const salt = crypto.randomBytes(32);
    const key = await this.deriveKey(password, salt);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipheriv(this.algorithm, key, iv);
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      salt: salt.toString('hex'),
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }
  
  async decrypt(encryptedData: EncryptedData, password: string): Promise<string> {
    const key = await this.deriveKey(
      password,
      Buffer.from(encryptedData.salt, 'hex')
    );
    
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      key,
      Buffer.from(encryptedData.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  
  private async deriveKey(password: string, salt: Buffer): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      crypto.pbkdf2(password, salt, 100000, 32, 'sha256', (err, key) => {
        if (err) reject(err);
        else resolve(key);
      });
    });
  }
}
```

### 10.2 Privacy Controls

```typescript
interface PrivacySettings {
  encryptLocalData: boolean;
  encryptSyncedData: boolean;
  excludePatterns: string[]; // File patterns to exclude
  redactPatterns: string[]; // Patterns to redact (API keys, passwords)
  excludeApplications: string[]; // Apps to exclude from capture
  excludeUrls: string[]; // URL patterns to exclude
  anonymizeScreenshots: boolean;
  retentionPeriod: number; // Days to keep data
  allowTelemetry: boolean;
  shareUsageData: boolean;
}

class PrivacyService {
  async applyPrivacySettings(
    context: Context,
    settings: PrivacySettings
  ): Promise<Context> {
    const sanitizedContext = { ...context };
    
    // Filter files by exclude patterns
    sanitizedContext.files = context.files.filter(file => 
      !this.matchesExcludePattern(file.path, settings.excludePatterns)
    );
    
    // Redact sensitive content
    for (const file of sanitizedContext.files) {
      file.content = await this.redactSensitiveContent(
        file.content,
        settings.redactPatterns
      );
    }
    
    // Filter browser tabs
    sanitizedContext.browserTabs = context.browserTabs.filter(tab =>
      !this.matchesExcludePattern(tab.url, settings.excludeUrls)
    );
    
    // Redact terminal history
    for (const session of sanitizedContext.terminalSessions) {
      session.history = session.history.map(cmd =>
        this.redactCommand(cmd, settings.redactPatterns)
      );
      session.environmentVariables = this.filterEnvVars(
        session.environmentVariables
      );
    }
    
    // Anonymize screenshots if enabled
    if (settings.anonymizeScreenshots) {
      sanitizedContext.screenshots = await this.anonymizeScreenshots(
        context.screenshots
      );
    }
    
    return sanitizedContext;
  }
  
  private async redactSensitiveContent(
    content: string,
    patterns: string[]
  ): Promise<string> {
    let redacted = content;
    
    // Common patterns
    const sensitivePatterns = [
      /api[_-]?key[:\s=]+['"]?([a-zA-Z0-9_-]+)['"]?/gi,
      /password[:\s=]+['"]?([^\s'"]+)['"]?/gi,
      /token[:\s=]+['"]?([a-zA-Z0-9._-]+)['"]?/gi,
      /secret[:\s=]+['"]?([a-zA-Z0-9_-]+)['"]?/gi,
      ...patterns.map(p => new RegExp(p, 'gi'))
    ];
    
    for (const pattern of sensitivePatterns) {
      redacted = redacted.replace(pattern, (match) => {
        return match.replace(/[a-zA-Z0-9]/g, '*');
      });
    }
    
    return redacted;
  }
  
  private filterEnvVars(
    envVars: Record<string, string>
  ): Record<string, string> {
    const filtered: Record<string, string> = {};
    const allowedVars = ['PATH', 'HOME', 'USER', 'SHELL', 'LANG'];
    
    for (const [key, value] of Object.entries(envVars)) {
      if (allowedVars.includes(key) || !this.isSensitiveEnvVar(key)) {
        filtered[key] = value;
      }
    }
    
    return filtered;
  }
  
  private isSensitiveEnvVar(key: string): boolean {
    const sensitiveKeywords = [
      'KEY',
      'SECRET',
      'TOKEN',
      'PASSWORD',
      'CREDENTIAL',
      'AUTH'
    ];
    
    return sensitiveKeywords.some(keyword => 
      key.toUpperCase().includes(keyword)
    );
  }
}
```

### 10.3 Authentication & Authorization

```typescript
class AuthService {
  async authenticate(email: string, password: string): Promise<AuthResult> {
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Verify credentials
    const user = await this.db.getUserByEmail(email);
    if (!user || !await bcrypt.compare(password, user.passwordHash)) {
      throw new Error('Invalid credentials');
    }
    
    // Generate tokens
    const accessToken = this.generateAccessToken(user.id);
    const refreshToken = this.generateRefreshToken(user.id);
    
    // Store refresh token
    await this.storeRefreshToken(user.id, refreshToken);
    
    return {
      userId: user.id,
      accessToken,
      refreshToken,
      expiresIn: 3600 // 1 hour
    };
  }
  
  private generateAccessToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'access' },
      process.env.JWT_SECRET!,
      { expiresIn: '1h' }
    );
  }
  
  private generateRefreshToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET!,
      { expiresIn: '30d' }
    );
  }
  
  async verifyToken(token: string): Promise<TokenPayload> {
    try {
      const payload = jwt.verify(token, process.env.JWT_SECRET!) as TokenPayload;
      return payload;
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
}

// Middleware for protected routes
const requireAuth = async (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const payload = await authService.verifyToken(token);
    req.userId = payload.userId;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};
```

---

## 11. Performance Requirements {#performance-requirements}

### 11.1 Performance Targets

```typescript
interface PerformanceTargets {
  // Capture performance
  contextCaptureTime: {
    p50: 2000,      // 2 seconds
    p95: 5000,      // 5 seconds
    p99: 10000      // 10 seconds
  };
  
  // Restoration performance
  contextRestoreTime: {
    p50: 3000,      // 3 seconds
    p95: 8000,      // 8 seconds
    p99: 15000      // 15 seconds
  };
  
  // UI responsiveness
  uiInteraction: {
    p50: 50,        // 50ms
    p95: 100,       // 100ms
    p99: 200        // 200ms
  };
  
  // Search performance
  searchLatency: {
    p50: 200,       // 200ms
    p95: 500,       // 500ms
    p99: 1000       // 1 second
  };
  
  // AI response time
  aiResponseTime: {
    firstToken: 500,    // 500ms to first token
    p50: 2000,          // 2 seconds total
    p95: 5000           // 5 seconds total
  };
  
  // Memory usage
  memoryUsage: {
    idle: 200,          // 200MB idle
    active: 500,        // 500MB active capture
    max: 1000           // 1GB maximum
  };
  
  // CPU usage
  cpuUsage: {
    idle: 5,            // 5% idle
    active: 30,         // 30% during capture
    max: 80             // 80% maximum
  };
  
  // Startup time
  startupTime: {
    cold: 3000,         // 3 seconds cold start
    warm: 1000          // 1 second warm start
  };
}
```

### 11.2 Performance Monitoring

```typescript
class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric> = new Map();
  
  startMeasure(label: string): void {
    this.metrics.set(label, {
      label,
      startTime: performance.now(),
      endTime: 0,
      duration: 0
    });
  }
  
  endMeasure(label: string): number {
    const metric = this.metrics.get(label);
    if (!metric) return 0;
    
    metric.endTime = performance.now();
    metric.duration = metric.endTime - metric.startTime;
    
    // Log to analytics
    this.analytics.track('performance_metric', {
      label,
      duration: metric.duration,
      timestamp: Date.now()
    });
    
    // Alert if exceeds threshold
    if (this.exceedsThreshold(label, metric.duration)) {
      this.alertSlowPerformance(label, metric.duration);
    }
    
    return metric.duration;
  }
  
  private exceedsThreshold(label: string, duration: number): boolean {
    const thresholds: Record<string, number> = {
      'context_capture': 10000,
      'context_restore': 15000,
      'ui_interaction': 200,
      'search': 1000,
      'ai_response': 5000
    };
    
    return duration > (thresholds[label] || 5000);
  }
  
  async getPerformanceReport(): Promise<PerformanceReport> {
    const metrics = Array.from(this.metrics.values());
    
    return {
      captureTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'context_capture')
      ),
      restoreTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'context_restore')
      ),
      searchTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'search')
      ),
      aiResponseTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'ai_response')
      ),
      memoryUsage: await this.getMemoryUsage(),
      cpuUsage: await this.getCPUUsage()
    };
  }
  
  private calculatePercentiles(metrics: PerformanceMetric[]): Percentiles {
    const durations = metrics.map(m => m.duration).sort((a, b) => a - b);
    
    return {
      p50: durations[Math.floor(durations.length * 0.5)],
      p95: durations[Math.floor(durations.length * 0.95)],
      p99: durations[Math.floor(durations.length * 0.99)]
    };
  }
}
```

### 11.3 Optimization Strategies

```typescript
class OptimizationService {
  // Lazy loading for heavy components
  async lazyLoadComponent(componentName: string): Promise<React.ComponentType> {
    return import(`./components/${componentName}`).then(m => m.default);
  }
  
  // Debounce expensive operations
  debouncedCapture = debounce(async () => {
    await this.captureContext();
  }, 5000);
  
  // Throttle high-frequency events
  throttledSync = throttle(async () => {
    await this.syncService.sync();
  }, 10000);
  
  // Memoize expensive computations
  @memoize
  async calculateInsights(userId: string, timeRange: TimeRange): Promise<ProductivityInsights> {
    // Expensive calculation
    return await this.analytics.generateInsights(userId, timeRange);
  }
  
  // Virtual scrolling for long lists
  renderContextList(contexts: Context[]): JSX.Element {
    return (
      <VirtualList
        height={600}
        itemCount={contexts.length}
        itemSize={120}
        renderItem={(index) => (
          <ContextCard context={contexts[index]} />
        )}
      />
    );
  }
  
  // Web Workers for heavy computations
  async processInWorker<T>(data: any): Promise<T> {
    return new Promise((resolve, reject) => {
      const worker = new Worker('./worker.js');
      
      worker.postMessage(data);
      
      worker.onmessage = (e) => {
        resolve(e.data);
        worker.terminate();
      };
      
      worker.onerror = (e) => {
        reject(e);
        worker.terminate();
      };
    });
  }
  
  // IndexedDB for large datasets
  async cacheToIndexedDB(key: string, data: any): Promise<void> {
    const db = await this.openIndexedDB();
    const tx = db.transaction('cache', 'readwrite');
    await tx.objectStore('cache').put({ key, data, timestamp: Date.now() });
  }
  
  async getFromIndexedDB(key: string): Promise<any> {
    const db = await this.openIndexedDB();
    const tx = db.transaction('cache', 'readonly');
    const result = await tx.objectStore('cache').get(key);
    return result?.data;
  }
}
```

---

## 12. Integration Requirements {#integration-requirements}

### 12.1 IDE Integrations

**VS Code Extension:**
```typescript
// VS Code Extension API
import * as vscode from 'vscode';

export class FlowVaultExtension {
  private statusBarItem: vscode.StatusBarItem;
  
  async activate(context: vscode.ExtensionContext) {
    // Register commands
    context.subscriptions.push(
      vscode.commands.registerCommand('flowvault.captureContext', () => {
        this.captureContext();
      })
    );
    
    // Create status bar item
    this.statusBarItem = vscode.window.createStatusBarItem(
      vscode.StatusBarAlignment.Right,
      100
    );
    this.statusBarItem.text = '$(database) FlowVault';
    this.statusBarItem.command = 'flowvault.showMenu';
    this.statusBarItem.show();
    
    // Listen for file changes# FlowVault - Product Requirements Document (PRD)
## AI-Powered Developer Context Preservation System

**Version:** 1.0  
**Last Updated:** October 26, 2025  
**Document Owner:** Product Team  
**Status:** Ready for Development

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Product Overview](#product-overview)
3. [Technical Architecture](#technical-architecture)
4. [Electron Application Specifications](#electron-application-specifications)
5. [UI/UX Design System (Cluely-Inspired)](#uiux-design-system)
6. [Core Features - Detailed Specifications](#core-features)
7. [Advanced Features](#advanced-features)
8. [Data Models & Database Schema](#data-models)
9. [API Specifications](#api-specifications)
10. [Security & Privacy](#security-privacy)
11. [Performance Requirements](#performance-requirements)
12. [Integration Requirements](#integration-requirements)
13. [Analytics & Telemetry](#analytics-telemetry)
14. [Monetization Implementation](#monetization-implementation)
15. [Development Roadmap](#development-roadmap)

---

## 1. Executive Summary {#executive-summary}

FlowVault is an Electron-based desktop application that solves the $1.4 trillion context-switching problem in software development. It automatically captures, preserves, and restores complete developer working contexts, enabling instant recovery of flow states after interruptions.

**Key Metrics:**
- Target: 250,000 users in Year 1
- ARR Goal: $105M at 5% market penetration
- Technical Goal: <100ms context restoration latency
- Engagement Goal: 80% DAU/MAU ratio

---

## 2. Product Overview {#product-overview}

### 2.1 Product Vision

Create the world's first cognitive infrastructure for developers that eliminates context loss, enabling continuous flow states and 10x productivity improvements.

### 2.2 Core Value Propositions

1. **Instant Context Recovery**: Restore complete working state in <5 seconds
2. **Zero Mental Load**: Never worry about losing your place
3. **Team Knowledge Sharing**: Transfer context between team members effortlessly
4. **Focus Protection**: Intelligent interruption filtering
5. **Productivity Intelligence**: Data-driven insights into work patterns

### 2.3 Target Users

**Primary:**
- Senior Software Engineers (5+ years experience)
- Full-stack Developers working across multiple codebases
- Tech Leads managing multiple projects
- DevOps Engineers handling incidents

**Secondary:**
- Junior Developers (onboarding use case)
- Product Managers (understanding technical context)
- Engineering Managers (team productivity insights)

### 2.4 Success Metrics

**Adoption Metrics:**
- Daily Active Users (DAU): 80% of registered users
- Weekly Active Users (WAU): 95% of registered users
- Context Captures per User per Day: 15-25
- Context Restorations per User per Day: 8-15

**Engagement Metrics:**
- Average Session Duration: 6+ hours (running in background)
- Feature Usage Rate: 70% of users use 5+ features weekly
- Retention: 90% Week-1, 75% Month-1, 60% Month-6

**Business Metrics:**
- Free-to-Paid Conversion: 15% within 30 days
- Team Expansion Rate: 40% of Pro users upgrade to Team within 90 days
- Net Revenue Retention: 120% annually
- Customer Acquisition Cost (CAC): <$50
- Lifetime Value (LTV): >$2,000

---

## 3. Technical Architecture {#technical-architecture}

### 3.1 Overall System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FlowVault Electron App                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Overlay    â”‚  â”‚   Main UI    â”‚  â”‚  Background  â”‚      â”‚
â”‚  â”‚   Window     â”‚  â”‚   Window     â”‚  â”‚   Services   â”‚      â”‚
â”‚  â”‚  (Frameless) â”‚  â”‚  (Standard)  â”‚  â”‚  (Node.js)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚           IPC Communication Layer                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Context    â”‚  â”‚     AI       â”‚  â”‚   Plugin     â”‚      â”‚
â”‚  â”‚   Capture    â”‚  â”‚   Engine     â”‚  â”‚   System     â”‚      â”‚
â”‚  â”‚   Engine     â”‚  â”‚              â”‚  â”‚              â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Local DB   â”‚  â”‚   File       â”‚  â”‚   Cache      â”‚      â”‚
â”‚  â”‚  (SQLite)    â”‚  â”‚   System     â”‚  â”‚   Layer      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ HTTPS/WebSocket
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Backend Services (Cloud)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   API        â”‚  â”‚   AI         â”‚  â”‚   Sync       â”‚      â”‚
â”‚  â”‚   Gateway    â”‚  â”‚   Service    â”‚  â”‚   Service    â”‚      â”‚
â”‚  â”‚  (Node.js)   â”‚  â”‚  (Python)    â”‚  â”‚  (Node.js)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  PostgreSQL  â”‚  â”‚   Redis      â”‚  â”‚  S3/Object   â”‚      â”‚
â”‚  â”‚  (Primary)   â”‚  â”‚   Cache      â”‚  â”‚   Storage    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Analytics   â”‚  â”‚   Queue      â”‚  â”‚   Search     â”‚      â”‚
â”‚  â”‚  (ClickHouse)â”‚  â”‚  (RabbitMQ)  â”‚  â”‚(Elasticsearch)â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Technology Stack

**Electron Application:**
- **Framework**: Electron 28.x (latest stable)
- **Renderer**: React 18.x with TypeScript 5.x
- **State Management**: Zustand + React Query
- **Styling**: Tailwind CSS 3.x + Framer Motion
- **Build Tool**: Vite 5.x
- **Testing**: Vitest + Playwright

**Backend Services:**
- **API Gateway**: Node.js 20.x + Express.js + tRPC
- **AI Service**: Python 3.11 + FastAPI + LangChain
- **Database**: PostgreSQL 16 (primary) + SQLite (local)
- **Cache**: Redis 7.x
- **Message Queue**: RabbitMQ 3.12
- **Search**: Elasticsearch 8.x
- **Object Storage**: AWS S3 / MinIO (self-hosted option)
- **Analytics**: ClickHouse 23.x

**AI/ML Stack:**
- **LLM Provider**: OpenAI GPT-4 Turbo (primary), Anthropic Claude (fallback)
- **Embeddings**: OpenAI text-embedding-3-large
- **Vector Database**: Pinecone / Weaviate
- **Local LLM**: Ollama (for offline mode)

**Infrastructure:**
- **Container Orchestration**: Kubernetes (AWS EKS / GCP GKE)
- **CI/CD**: GitHub Actions
- **Monitoring**: Datadog / Prometheus + Grafana
- **Error Tracking**: Sentry
- **CDN**: CloudFlare

### 3.3 Electron Architecture (Detailed)

#### 3.3.1 Multi-Window Architecture

**Main Window (Standard BrowserWindow):**
```typescript
// Specifications
{
  width: 1400,
  height: 900,
  minWidth: 1200,
  minHeight: 700,
  frame: true,
  titleBarStyle: 'hiddenInset', // macOS
  backgroundColor: '#0A0A0B',
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true,
    preload: path.join(__dirname, 'preload.js'),
    webSecurity: true
  }
}
```

**Overlay Window (Frameless BrowserWindow):**
```typescript
// Specifications for always-on-top overlay
{
  width: 400,
  height: 600,
  frame: false,
  transparent: true,
  alwaysOnTop: true,
  skipTaskbar: true,
  resizable: false,
  movable: true,
  hasShadow: false,
  type: 'panel', // macOS, toolbar on Windows
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true,
    preload: path.join(__dirname, 'overlay-preload.js')
  }
}
```

**Mini Widget (System Tray Extension):**
```typescript
// Compact widget for quick actions
{
  width: 320,
  height: 480,
  frame: false,
  transparent: true,
  alwaysOnTop: true,
  skipTaskbar: true,
  show: false, // shown on tray click
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true
  }
}
```

#### 3.3.2 IPC Communication Architecture

**Bidirectional IPC Channels:**

```typescript
// Main Process â†’ Renderer
enum MainToRendererChannels {
  CONTEXT_CAPTURED = 'context:captured',
  CONTEXT_UPDATED = 'context:updated',
  AI_RESPONSE = 'ai:response',
  SYNC_STATUS = 'sync:status',
  NOTIFICATION = 'notification:show',
  FOCUS_CHANGE = 'focus:changed',
  PLUGIN_EVENT = 'plugin:event'
}

// Renderer â†’ Main Process
enum RendererToMainChannels {
  CAPTURE_CONTEXT = 'context:capture',
  RESTORE_CONTEXT = 'context:restore',
  AI_QUERY = 'ai:query',
  OPEN_FILE = 'file:open',
  SYNC_REQUEST = 'sync:request',
  SETTINGS_UPDATE = 'settings:update'
}

// IPC Implementation with type safety
interface IPCInvokeHandlers {
  'context:capture': (options: CaptureOptions) => Promise<Context>;
  'context:restore': (contextId: string) => Promise<void>;
  'context:list': (filters: ContextFilters) => Promise<Context[]>;
  'ai:query': (query: string, contextId?: string) => Promise<AIResponse>;
  'settings:get': () => Promise<Settings>;
  'settings:update': (settings: Partial<Settings>) => Promise<void>;
  'file:read': (path: string) => Promise<string>;
  'plugin:execute': (pluginId: string, action: string, params: any) => Promise<any>;
}
```

#### 3.3.3 Process Architecture

**Main Process Responsibilities:**
- Window lifecycle management
- Native OS integration (file system, notifications, shortcuts)
- SQLite database operations
- Background services coordination
- IPC orchestration
- Auto-updater management
- System tray management

**Renderer Process Responsibilities:**
- UI rendering and user interactions
- State management (Zustand stores)
- Real-time data updates (WebSocket)
- Client-side routing
- Form validation
- Local caching (IndexedDB)

**Worker Processes (via fork):**
- Context capture engine (CPU-intensive)
- AI request processing
- File system monitoring
- Screenshot/screen recording
- Data synchronization

### 3.4 Context Capture Engine Architecture

```typescript
class ContextCaptureEngine {
  // Core components
  private fileSystemWatcher: FileSystemWatcher;
  private applicationMonitor: ApplicationMonitor;
  private browserExtensionBridge: BrowserBridge;
  private ideIntegration: IDEIntegration;
  private terminalMonitor: TerminalMonitor;
  private clipboardMonitor: ClipboardMonitor;
  
  // Capture pipeline
  async captureContext(): Promise<Context> {
    // Parallel capture for performance
    const [
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState,
      applicationWindows,
      clipboardHistory,
      screenshots
    ] = await Promise.all([
      this.captureActiveFiles(),
      this.captureBrowserTabs(),
      this.captureTerminalSessions(),
      this.captureIDEState(),
      this.captureApplicationWindows(),
      this.captureClipboardHistory(),
      this.captureScreenshots()
    ]);
    
    // AI-powered context analysis
    const contextSummary = await this.aiAnalyzeContext({
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState
    });
    
    // Assemble complete context
    return {
      id: generateUUID(),
      timestamp: Date.now(),
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState,
      applicationWindows,
      clipboardHistory,
      screenshots,
      aiSummary: contextSummary,
      metadata: this.extractMetadata()
    };
  }
}
```

**File System Capture:**
```typescript
interface FileCaptureResult {
  path: string;
  content: string; // Full content for small files
  contentHash: string; // SHA-256 hash
  excerpt: string; // First/last N lines for large files
  language: string;
  cursorPosition: { line: number; column: number };
  selections: Array<{ start: Position; end: Position }>;
  scrollPosition: number;
  folds: number[]; // Collapsed line numbers
  breakpoints: number[];
  bookmarks: Bookmark[];
  fileSize: number;
  lastModified: number;
  gitStatus?: {
    branch: string;
    changes: number;
    staged: boolean;
  };
}
```

**Browser Tab Capture:**
```typescript
interface BrowserTabCapture {
  url: string;
  title: string;
  favicon: string;
  screenshot?: string; // Base64 thumbnail
  scrollPosition: number;
  formData?: Record<string, string>; // For unsaved forms
  selectedText?: string;
  openTime: number;
  lastActiveTime: number;
  category: 'documentation' | 'stackoverflow' | 'github' | 'other';
  relevanceScore: number; // AI-calculated
}
```

**Terminal Session Capture:**
```typescript
interface TerminalCapture {
  sessionId: string;
  workingDirectory: string;
  history: string[]; // Last 100 commands
  output: string; // Last 1000 lines
  environmentVariables: Record<string, string>;
  activeProcesses: Process[];
  shell: string;
  tabs: TerminalTab[];
}
```

**IDE State Capture:**
```typescript
interface IDEStateCapture {
  type: 'vscode' | 'intellij' | 'pycharm' | 'webstorm' | 'vim' | 'emacs';
  openProjects: Project[];
  workspace: {
    folders: string[];
    settings: Record<string, any>;
  };
  extensions: Extension[];
  debugSessions: DebugSession[];
  runConfigurations: RunConfig[];
  searchHistory: string[];
  recentFiles: string[];
  pinnedFiles: string[];
  splitLayout: SplitLayoutConfig;
  editorGroups: EditorGroup[];
}
```

### 3.5 AI Engine Architecture

```typescript
class AIContextEngine {
  private openai: OpenAI;
  private vectorStore: VectorStore;
  private embeddingCache: Map<string, number[]>;
  
  // Generate context summary
  async generateContextSummary(context: Context): Promise<string> {
    const prompt = this.buildContextPrompt(context);
    
    const completion = await this.openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: `You are an expert software developer analyzing a colleague's working context.
          Generate a concise, actionable summary that captures:
          1. The primary task/problem being worked on
          2. Current progress and approach
          3. Key files and their purposes
          4. Any blockers or questions
          5. Next steps
          
          Format the summary to enable instant context restoration.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 500,
      temperature: 0.3
    });
    
    return completion.choices[0].message.content;
  }
  
  // Semantic context search
  async searchSimilarContexts(query: string, limit: number = 10): Promise<Context[]> {
    // Generate query embedding
    const queryEmbedding = await this.generateEmbedding(query);
    
    // Vector similarity search
    const similarContextIds = await this.vectorStore.search(
      queryEmbedding,
      limit
    );
    
    // Fetch full contexts
    return await this.fetchContextsByIds(similarContextIds);
  }
  
  // AI chat interface
  async chatWithContext(
    message: string,
    contextId: string,
    conversationHistory: ChatMessage[]
  ): Promise<string> {
    const context = await this.fetchContext(contextId);
    
    const systemPrompt = `You are FlowVault's AI assistant with access to the developer's complete working context.
    
    Current Context:
    ${JSON.stringify(context, null, 2)}
    
    Answer questions about this context, help debug issues, suggest next steps, and provide insights.`;
    
    const messages = [
      { role: "system", content: systemPrompt },
      ...conversationHistory,
      { role: "user", content: message }
    ];
    
    const response = await this.openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages,
      max_tokens: 1000,
      temperature: 0.7,
      stream: true // Enable streaming for real-time responses
    });
    
    return this.streamResponse(response);
  }
}
```

### 3.6 Data Synchronization Architecture

**Hybrid Sync Strategy:**
- Local-first with SQLite
- Background sync to cloud
- Conflict resolution using Last-Write-Wins + Vector Clocks
- Differential sync (only changed data)
- Compression for network efficiency

```typescript
class SyncEngine {
  private localDB: SQLiteDB;
  private remoteAPI: APIClient;
  private syncQueue: Queue<SyncOperation>;
  private websocket: WebSocket;
  
  async syncContext(context: Context): Promise<void> {
    // 1. Save locally first (fast)
    await this.localDB.saveContext(context);
    
    // 2. Queue for background sync
    this.syncQueue.add({
      type: 'context:create',
      payload: context,
      priority: 'normal'
    });
    
    // 3. Process sync queue
    await this.processSyncQueue();
  }
  
  private async processSyncQueue(): Promise<void> {
    while (!this.syncQueue.isEmpty()) {
      const operation = this.syncQueue.dequeue();
      
      try {
        // Compress payload
        const compressed = await this.compress(operation.payload);
        
        // Send to backend
        await this.remoteAPI.post('/sync', {
          operation: operation.type,
          data: compressed,
          timestamp: Date.now(),
          deviceId: this.deviceId
        });
        
        // Mark as synced
        await this.localDB.markSynced(operation.id);
      } catch (error) {
        // Retry with exponential backoff
        this.syncQueue.addWithDelay(operation, this.calculateBackoff());
      }
    }
  }
  
  // Real-time sync via WebSocket
  private setupRealtimeSync(): void {
    this.websocket.on('context:updated', async (data) => {
      // Merge remote changes
      await this.mergeRemoteContext(data);
      
      // Notify UI
      this.emit('sync:completed', data);
    });
  }
}
```

### 3.7 Plugin System Architecture

```typescript
interface Plugin {
  id: string;
  name: string;
  version: string;
  author: string;
  description: string;
  
  // Lifecycle hooks
  onActivate(context: PluginContext): Promise<void>;
  onDeactivate(): Promise<void>;
  
  // Event handlers
  onContextCapture?(context: Context): Promise<Context>;
  onContextRestore?(context: Context): Promise<void>;
  onFileOpen?(file: string): Promise<void>;
  
  // Custom commands
  commands?: PluginCommand[];
  
  // UI extensions
  uiExtensions?: {
    sidebar?: React.ComponentType;
    statusBar?: React.ComponentType;
    contextMenu?: MenuItem[];
  };
}

class PluginManager {
  private plugins: Map<string, Plugin>;
  private sandboxes: Map<string, VM>;
  
  async loadPlugin(pluginPath: string): Promise<void> {
    // Create isolated sandbox
    const sandbox = new VM({
      timeout: 5000,
      sandbox: {
        console,
        require: this.createRequireProxy(),
        flowvault: this.createPluginAPI()
      }
    });
    
    // Load and validate plugin
    const plugin = await sandbox.run(
      fs.readFileSync(pluginPath, 'utf8')
    );
    
    // Execute onActivate hook
    await plugin.onActivate(this.createPluginContext());
    
    this.plugins.set(plugin.id, plugin);
    this.sandboxes.set(plugin.id, sandbox);
  }
  
  private createPluginAPI(): PluginAPI {
    return {
      // Safe APIs exposed to plugins
      contexts: {
        getCurrent: () => this.getCurrentContext(),
        list: (filters) => this.listContexts(filters),
        create: (context) => this.createContext(context)
      },
      ui: {
        showNotification: (message) => this.showNotification(message),
        showDialog: (options) => this.showDialog(options)
      },
      storage: {
        get: (key) => this.pluginStorage.get(key),
        set: (key, value) => this.pluginStorage.set(key, value)
      }
    };
  }
}
```

---

## 4. Electron Application Specifications {#electron-application-specifications}

### 4.1 Build Configuration

**electron-builder configuration:**

```json
{
  "appId": "com.flowvault.app",
  "productName": "FlowVault",
  "copyright": "Copyright Â© 2025 FlowVault Inc.",
  "directories": {
    "output": "dist",
    "buildResources": "build"
  },
  "files": [
    "dist-electron/**/*",
    "dist/**/*",
    "package.json"
  ],
  "mac": {
    "category": "public.app-category.developer-tools",
    "target": ["dmg", "zip"],
    "hardenedRuntime": true,
    "gatekeeperAssess": false,
    "entitlements": "build/entitlements.mac.plist",
    "entitlementsInherit": "build/entitlements.mac.plist",
    "icon": "build/icon.icns",
    "minimumSystemVersion": "10.15.0",
    "darkModeSupport": true
  },
  "win": {
    "target": ["nsis", "portable"],
    "icon": "build/icon.ico",
    "publisherName": "FlowVault Inc.",
    "verifyUpdateCodeSignature": true
  },
  "linux": {
    "target": ["AppImage", "deb", "rpm"],
    "category": "Development",
    "icon": "build/icons",
    "maintainer": "support@flowvault.com"
  },
  "nsis": {
    "oneClick": false,
    "allowToChangeInstallationDirectory": true,
    "createDesktopShortcut": true,
    "createStartMenuShortcut": true
  },
  "publish": {
    "provider": "github",
    "owner": "flowvault",
    "repo": "flowvault-app"
  }
}
```

### 4.2 Auto-Update Implementation

```typescript
import { autoUpdater } from 'electron-updater';

class AutoUpdateManager {
  constructor() {
    autoUpdater.autoDownload = false;
    autoUpdater.autoInstallOnAppQuit = true;
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers(): void {
    autoUpdater.on('update-available', (info) => {
      // Notify user
      this.showUpdateNotification(info);
    });
    
    autoUpdater.on('download-progress', (progress) => {
      // Show download progress in UI
      this.updateDownloadProgress(progress);
    });
    
    autoUpdater.on('update-downloaded', () => {
      // Prompt to restart
      this.showRestartDialog();
    });
  }
  
  async checkForUpdates(): Promise<void> {
    await autoUpdater.checkForUpdates();
  }
  
  async downloadUpdate(): Promise<void> {
    await autoUpdater.downloadUpdate();
  }
  
  quitAndInstall(): void {
    autoUpdater.quitAndInstall(false, true);
  }
}
```

### 4.3 Native OS Integration

**macOS:**
```typescript
// Touch Bar support
const { TouchBar } = require('electron');

const touchBar = new TouchBar({
  items: [
    new TouchBar.TouchBarButton({
      label: 'ðŸ“¸ Capture',
      click: () => this.captureContext()
    }),
    new TouchBar.TouchBarButton({
      label: 'ðŸ”„ Restore',
      click: () => this.showRestoreMenu()
    }),
    new TouchBar.TouchBarSpacer({ size: 'flexible' }),
    new TouchBar.TouchBarButton({
      label: 'ðŸ¤– AI Chat',
      click: () => this.openAIChat()
    })
  ]
});

mainWindow.setTouchBar(touchBar);

// Menu bar integration
const { Tray } = require('electron');

const tray = new Tray('icon-template.png');
tray.setToolTip('FlowVault');
tray.on('click', () => {
  this.toggleOverlay();
});
```

**Windows:**
```typescript
// Jump list
app.setUserTasks([
  {
    program: process.execPath,
    arguments: '--capture',
    iconPath: process.execPath,
    iconIndex: 0,
    title: 'Quick Capture',
    description: 'Capture current context'
  },
  {
    program: process.execPath,
    arguments: '--restore',
    iconPath: process.execPath,
    iconIndex: 0,
    title: 'Restore Context',
    description: 'Restore last context'
  }
]);

// Thumbnail toolbar
mainWindow.setThumbarButtons([
  {
    tooltip: 'Capture',
    icon: 'capture-icon.png',
    click() { captureContext(); }
  },
  {
    tooltip: 'AI Chat',
    icon: 'ai-icon.png',
    click() { openAIChat(); }
  }
]);
```

**Linux:**
```typescript
// Desktop notification
const { Notification } = require('electron');

new Notification({
  title: 'Context Captured',
  body: 'Working on authentication bug',
  icon: 'icon.png',
  actions: [
    { type: 'button', text: 'View' },
    { type: 'button', text: 'Restore' }
  ]
}).show();
```

### 4.4 Global Keyboard Shortcuts

```typescript
import { globalShortcut } from 'electron';

class ShortcutManager {
  registerShortcuts(): void {
    // Quick capture
    globalShortcut.register('CommandOrControl+Shift+C', () => {
      this.captureContext();
    });
    
    // Quick restore
    globalShortcut.register('CommandOrControl+Shift+R', () => {
      this.showRestoreMenu();
    });
    
    // Toggle overlay
    globalShortcut.register('CommandOrControl+Shift+O', () => {
      this.toggleOverlay();
    });
    
    // AI chat
    globalShortcut.register('CommandOrControl+Shift+A', () => {
      this.openAIChat();
    });
    
    // Focus mode
    globalShortcut.register('CommandOrControl+Shift+F', () => {
      this.toggleFocusMode();
    });
  }
  
  unregisterAll(): void {
    globalShortcut.unregisterAll();
  }
}
```

### 4.5 Performance Optimizations

**Memory Management:**
```typescript
// Automatic garbage collection
setInterval(() => {
  if (global.gc) {
    global.gc();
  }
}, 60000); // Every minute

// Limit renderer processes memory
app.commandLine.appendSwitch('js-flags', '--max-old-space-size=4096');

// Disable hardware acceleration if GPU issues
if (process.platform === 'linux') {
  app.disableHardwareAcceleration();
}
```

**Lazy Loading:**
```typescript
// Load heavy components on demand
const loadHeavyComponent = () => import('./HeavyComponent');

// Use React.lazy for code splitting
const ContextTimeline = React.lazy(() => import('./ContextTimeline'));
const AIChat = React.lazy(() => import('./AIChat'));
const Analytics = React.lazy(() => import('./Analytics'));
```

**Efficient IPC:**
```typescript
// Batch IPC calls
class IPCBatcher {
  private queue: IPCMessage[] = [];
  private timer: NodeJS.Timeout | null = null;
  private readonly BATCH_INTERVAL = 16; // 60fps
  
  send(channel: string, data: any): void {
    this.queue.push({ channel, data });
    
    if (!this.timer) {
      this.timer = setTimeout(() => {
        this.flush();
      }, this.BATCH_INTERVAL);
    }
  }
  
  private flush(): void {
    if (this.queue.length > 0) {
      ipcRenderer.send('batch', this.queue);
      this.queue = [];
    }
    this.timer = null;
  }
}

// Use MessagePorts for high-frequency communication
const { port1, port2 } = new MessageChannel();
port1.onmessage = (event) => {
  // Handle high-frequency updates
  this.handleRealtimeUpdate(event.data);
};
```

---

## 5. UI/UX Design System (Cluely-Inspired) {#uiux-design-system}

### 5.1 Design Philosophy

**Core Principles:**
1. **Dark-First Design**: Premium dark aesthetic with subtle gradients
2. **Glassmorphism**: Frosted glass effects for depth and hierarchy
3. **Micro-Interactions**: Smooth animations for every interaction
4. **Information Density**: Maximum information with minimal clutter
5. **Accessibility**: WCAG 2.1 AAA compliant

### 5.2 Color Palette

```typescript
const colorSystem = {
  // Base colors (Cluely-inspired)
  background: {
    primary: '#0A0A0B',      // Deep black
    secondary: '#121214',    // Card background
    tertiary: '#1A1A1D',     // Elevated surfaces
    overlay: 'rgba(18, 18, 20, 0.85)', // Glass effect
  },
  
  // Accent colors
  accent: {
    primary: '#6366F1',      // Indigo (primary actions)
    secondary: '#8B5CF6',    // Purple (secondary actions)
    success: '#10B981',      // Green (success states)
    warning: '#F59E0B',      // Amber (warnings)
    error: '#EF4444',        // Red (errors)
    info: '#3B82F6',         // Blue (info)
  },
  
  // Gradient definitions
  gradients: {
    primary: 'linear-gradient(135deg, #6366F1 0%, #8B5CF6 100%)',
    success: 'linear-gradient(135deg, #10B981 0%, #059669 100%)',
    danger: 'linear-gradient(135deg, #EF4444 0%, #DC2626 100%)',
    neural: 'linear-gradient(135deg, #8B5CF6 0%, #EC4899 100%)',
    context: 'linear-gradient(135deg, #3B82F6 0%, #6366F1 100%)',
  },
  
  // Text colors
  text: {
    primary: '#F9FAFB',      // White (headings, important text)
    secondary: '#D1D5DB',    // Light gray (body text)
    tertiary: '#9CA3AF',     // Medium gray (muted text)
    disabled: '#6B7280',     // Dark gray (disabled)
    inverse: '#0A0A0B',      // For light backgrounds
  },
  
  // Border colors
  border: {
    subtle: 'rgba(255, 255, 255, 0.05)',
    default: 'rgba(255, 255, 255, 0.1)',
    strong: 'rgba(255, 255, 255, 0.2)',
    accent: 'rgba(99, 102, 241, 0.3)',
  },
  
  // Status colors
  status: {
    active: '#10B981',
    idle: '#F59E0B',
    offline: '#6B7280',
    syncing: '#3B82F6',
    error: '#EF4444',
  },
  
  // Semantic colors
  semantic: {
    code: '#7C3AED',
    file: '#3B82F6',
    terminal: '#10B981',
    browser: '#F59E0B',
    ai: '#EC4899',
  }
};
```

### 5.3 Typography System

```typescript
const typography = {
  fontFamily: {
    primary: '"Inter", -apple-system, BlinkMacSystemFont, sans-serif',
    mono: '"JetBrains Mono", "Fira Code", monospace',
    display: '"Cal Sans", "Inter", sans-serif', // For hero text
  },
  
  fontSize: {
    xs: '0.75rem',    // 12px
    sm: '0.875rem',   // 14px
    base: '1rem',     // 16px
    lg: '1.125rem',   // 18px
    xl: '1.25rem',    // 20px
    '2xl': '1.5rem',  // 24px
    '3xl': '1.875rem', // 30px
    '4xl': '2.25rem', // 36px
    '5xl': '3rem',    // 48px
  },
  
  fontWeight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
  },
  
  lineHeight: {
    tight: 1.25,
    normal: 1.5,
    relaxed: 1.75,
  },
  
  letterSpacing: {
    tight: '-0.02em',
    normal: '0',
    wide: '0.02em',
  }
};
```

### 5.4 Component Design Specifications

#### 5.4.1 Overlay Window Design

```typescript
// Overlay component structure
interface OverlayProps {
  position: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
  isExpanded: boolean;
  isDragging: boolean;
}

const OverlayWindow: React.FC<OverlayProps> = ({ position, isExpanded }) => {
  return (
    <div className="overlay-container">
      {/* Glass effect background */}
      <div className="glass-backdrop" />
      
      {/* Header with drag handle */}
      <div className="overlay-header">
        <div className="drag-handle">
          <GripVertical size={16} />
        </div>
        <StatusIndicator status="active" />
        <QuickActions />
      </div>
      
      {/* Main content area */}
      <div className="overlay-content">
        {isExpanded ? (
          <ExpandedView />
        ) : (
          <CompactView />
        )}
      </div>
      
      {/* Quick action buttons */}
      <div className="overlay-footer">
        <QuickCaptureButton />
        <AIAssistButton />
        <ContextListButton />
      </div>
    </div>
  );
};
```

**CSS Styles (Tailwind + Custom):**
```css
.overlay-container {
  @apply relative w-full h-full;
  @apply rounded-2xl overflow-hidden;
  @apply shadow-2xl shadow-black/50;
  backdrop-filter: blur(40px) saturate(180%);
  background: rgba(18, 18, 20, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.glass-backdrop {
  @apply absolute inset-0 -z-10;
  background: linear-gradient(
    135deg,
    rgba(99, 102, 241, 0.05) 0%,
    rgba(139, 92, 246, 0.05) 100%
  );
}

.overlay-header {
  @apply flex items-center gap-3 p-4;
  @apply border-b border-white/5;
  @apply bg-gradient-to-r from-transparent via-white/[0.02] to-transparent;
}

.drag-handle {
  @apply cursor-move text-gray-500 hover:text-gray-300;
  @apply transition-colors duration-200;
}

.overlay-content {
  @apply p-4 overflow-y-auto;
  @apply scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent;
  max-height: calc(100% - 120px);
}

.overlay-footer {
  @apply absolute bottom-0 left-0 right-0;
  @apply flex items-center justify-around gap-2 p-3;
  @apply border-t border-white/5;
  @apply bg-gradient-to-t from-black/20 to-transparent;
}
```

#### 5.4.2 Context Card Design

```typescript
interface ContextCardProps {
  context: Context;
  isActive: boolean;
  onRestore: () => void;
  onDelete: () => void;
}

const ContextCard: React.FC<ContextCardProps> = ({
  context,
  isActive,
  onRestore,
  onDelete
}) => {
  return (
    <motion.div
      className={`context-card ${isActive ? 'active' : ''}`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, scale: 0.95 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2 }}
    >
      {/* Card header */}
      <div className="card-header">
        <div className="flex items-center gap-3">
          <ContextIcon type={context.type} />
          <div className="flex-1">
            <h3 className="card-title">{context.title}</h3>
            <p className="card-subtitle">
              {formatRelativeTime(context.timestamp)}
            </p>
          </div>
          <ContextBadge status={context.status} />
        </div>
      </div>
      
      {/* AI Summary */}
      <div className="card-summary">
        <AISparkle className="summary-icon" />
        <p className="summary-text">{context.aiSummary}</p>
      </div>
      
      {/* Context metadata */}
      <div className="card-metadata">
        <MetadataItem
          icon={<FileCode />}
          label="Files"
          value={context.fileCount}
        />
        <MetadataItem
          icon={<Globe />}
          label="Tabs"
          value={context.browserTabCount}
        />
        <MetadataItem
          icon={<Terminal />}
          label="Terminal"
          value={context.terminalSessionCount}
        />
      </div>
      
      {/* Action buttons */}
      <div className="card-actions">
        <Button
          variant="primary"
          onClick={onRestore}
          className="flex-1"
        >
          <Play size={16} />
          Restore
        </Button>
        <IconButton
          variant="ghost"
          onClick={onDelete}
          icon={<Trash2 size={16} />}
        />
      </div>
      
      {/* Hover overlay for preview */}
      <div className="card-hover-overlay">
        <PreviewThumbnail context={context} />
      </div>
    </motion.div>
  );
};
```

**Context Card Styles:**
```css
.context-card {
  @apply relative p-5 rounded-xl;
  @apply bg-gradient-to-br from-gray-900/50 to-gray-900/30;
  @apply border border-white/5;
  @apply transition-all duration-300;
  @apply hover:border-indigo-500/30;
  @apply hover:shadow-lg hover:shadow-indigo-500/10;
}

.context-card.active {
  @apply border-indigo-500/50;
  @apply bg-gradient-to-br from-indigo-900/20 to-purple-900/10;
  @apply shadow-xl shadow-indigo-500/20;
}

.card-header {
  @apply mb-4;
}

.card-title {
  @apply text-base font-semibold text-gray-100;
  @apply truncate;
}

.card-subtitle {
  @apply text-sm text-gray-400;
}

.card-summary {
  @apply flex items-start gap-3 mb-4 p-3;
  @apply rounded-lg bg-black/20;
  @apply border border-white/5;
}

.summary-icon {
  @apply flex-shrink-0 text-purple-400;
  animation: pulse-glow 2s ease-in-out infinite;
}

.summary-text {
  @apply text-sm text-gray-300 leading-relaxed;
  @apply line-clamp-3;
}

.card-metadata {
  @apply flex items-center gap-4 mb-4;
  @apply text-sm text-gray-400;
}

.card-actions {
  @apply flex items-center gap-2;
}

.card-hover-overlay {
  @apply absolute inset-0 opacity-0 pointer-events-none;
  @apply transition-opacity duration-300;
  @apply bg-black/90 backdrop-blur-sm;
  @apply rounded-xl overflow-hidden;
}

.context-card:hover .card-hover-overlay {
  @apply opacity-100;
}

@keyframes pulse-glow {
  0%, 100% {
    opacity: 1;
    filter: drop-shadow(0 0 2px currentColor);
  }
  50% {
    opacity: 0.7;
    filter: drop-shadow(0 0 8px currentColor);
  }
}
```

#### 5.4.3 AI Chat Interface

```typescript
const AIChatInterface: React.FC = () => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  
  return (
    <div className="ai-chat-container">
      {/* Chat header */}
      <div className="chat-header">
        <div className="flex items-center gap-3">
          <div className="ai-avatar">
            <Sparkles className="ai-icon" />
          </div>
          <div>
            <h3 className="chat-title">AI Assistant</h3>
            <p className="chat-status">
              <span className="status-dot" />
              Ready to help
            </p>
          </div>
        </div>
        <ContextSelector />
      </div>
      
      {/* Messages area */}
      <div className="chat-messages">
        <AnimatePresence>
          {messages.map((message) => (
            <ChatMessage
              key={message.id}
              message={message}
              isUser={message.role === 'user'}
            />
          ))}
        </AnimatePresence>
        
        {isTyping && <TypingIndicator />}
        
        {/* Suggested prompts */}
        {messages.length === 0 && (
          <SuggestedPrompts onSelect={setInput} />
        )}
      </div>
      
      {/* Input area */}
      <div className="chat-input-container">
        <div className="chat-input-wrapper">
          <TextareaAutosize
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask about your context..."
            className="chat-input"
            maxRows={6}
            onKeyDown={handleKeyDown}
          />
          <div className="input-actions">
            <IconButton
              icon={<Paperclip />}
              tooltip="Attach file"
              onClick={handleAttach}
            />
            <Button
              variant="primary"
              size="sm"
              onClick={handleSend}
              disabled={!input.trim()}
            >
              <Send size={16} />
            </Button>
          </div>
        </div>
        
        {/* Token counter */}
        <div className="token-counter">
          <Zap size={12} />
          <span>{tokenCount} / 4000 tokens</span>
        </div>
      </div>
    </div>
  );
};

const ChatMessage: React.FC<{ message: ChatMessage; isUser: boolean }> = ({
  message,
  isUser
}) => {
  return (
    <motion.div
      className={`chat-message ${isUser ? 'user' : 'assistant'}`}
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <div className="message-avatar">
        {isUser ? (
          <User size={20} />
        ) : (
          <Sparkles size={20} className="ai-icon-animated" />
        )}
      </div>
      
      <div className="message-content">
        <div className="message-header">
          <span className="message-sender">
            {isUser ? 'You' : 'AI Assistant'}
          </span>
          <span className="message-time">
            {formatTime(message.timestamp)}
          </span>
        </div>
        
        <div className="message-body">
          <ReactMarkdown
            components={{
              code: CodeBlock,
              pre: PreBlock,
            }}
          >
            {message.content}
          </ReactMarkdown>
        </div>
        
        {!isUser && (
          <div className="message-actions">
            <IconButton
              icon={<Copy />}
              tooltip="Copy"
              size="xs"
              onClick={() => copyToClipboard(message.content)}
            />
            <IconButton
              icon={<ThumbsUp />}
              tooltip="Good response"
              size="xs"
            />
            <IconButton
              icon={<ThumbsDown />}
              tooltip="Bad response"
              size="xs"
            />
          </div>
        )}
      </div>
    </motion.div>
  );
};
```

**AI Chat Styles:**
```css
.ai-chat-container {
  @apply flex flex-col h-full;
  @apply bg-gradient-to-b from-gray-900 to-black;
}

.chat-header {
  @apply flex items-center justify-between p-4;
  @apply border-b border-white/10;
  @apply bg-gradient-to-r from-indigo-900/10 via-purple-900/10 to-pink-900/10;
}

.ai-avatar {
  @apply w-10 h-10 rounded-full;
  @apply bg-gradient-to-br from-indigo-500 to-purple-500;
  @apply flex items-center justify-center;
  @apply shadow-lg shadow-indigo-500/50;
}

.ai-icon {
  @apply text-white;
  animation: rotate-slow 4s linear infinite;
}

.chat-title {
  @apply text-base font-semibold text-gray-100;
}

.chat-status {
  @apply flex items-center gap-2 text-sm text-gray-400;
}

.status-dot {
  @apply w-2 h-2 rounded-full bg-green-500;
  animation: pulse 2s ease-in-out infinite;
}

.chat-messages {
  @apply flex-1 overflow-y-auto p-4 space-y-4;
  @apply scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent;
}

.chat-message {
  @apply flex gap-3;
}

.chat-message.user {
  @apply flex-row-reverse;
}

.message-avatar {
  @apply w-8 h-8 rounded-full flex-shrink-0;
  @apply flex items-center justify-center;
  @apply bg-gray-800 text-gray-400;
}

.chat-message.assistant .message-avatar {
  @apply bg-gradient-to-br from-indigo-500 to-purple-500;
  @apply text-white;
}

.message-content {
  @apply flex-1 max-w-2xl;
}

.chat-message.user .message-content {
  @apply flex flex-col items-end;
}

.message-body {
  @apply p-4 rounded-2xl;
  @apply bg-gray-800/50 text-gray-200;
  @apply border border-white/5;
}

.chat-message.user .message-body {
  @apply bg-gradient-to-br from-indigo-600 to-purple-600;
  @apply text-white border-0;
}

.message-actions {
  @apply flex items-center gap-1 mt-2;
}

.chat-input-container {
  @apply p-4 border-t border-white/10;
  @apply bg-gradient-to-t from-black/50 to-transparent;
}

.chat-input-wrapper {
  @apply relative rounded-xl;
  @apply bg-gray-900/50 border border-white/10;
  @apply focus-within:border-indigo-500/50;
  @apply transition-colors duration-200;
}

.chat-input {
  @apply w-full px-4 py-3 bg-transparent;
  @apply text-gray-200 placeholder-gray-500;
  @apply resize-none outline-none;
}

.input-actions {
  @apply absolute right-2 bottom-2;
  @apply flex items-center gap-2;
}

.token-counter {
  @apply flex items-center gap-2 mt-2;
  @apply text-xs text-gray-500;
}

@keyframes rotate-slow {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
```

#### 5.4.4 Context Timeline Visualization

```typescript
const ContextTimeline: React.FC = () => {
  const contexts = useContextStore(state => state.contexts);
  const [selectedDate, setSelectedDate] = useState(new Date());
  
  return (
    <div className="timeline-container">
      {/* Timeline header with date navigation */}
      <div className="timeline-header">
        <h2 className="timeline-title">Context Timeline</h2>
        <DateNavigator
          selectedDate={selectedDate}
          onChange={setSelectedDate}
        />
      </div>
      
      {/* Timeline visualization */}
      <div className="timeline-content">
        {/* Time axis */}
        <div className="time-axis">
          {Array.from({ length: 24 }, (_, i) => (
            <div key={i} className="time-mark">
              <span>{i}:00</span>
            </div>
          ))}
        </div>
        
        {/* Context blocks */}
        <div className="timeline-blocks">
          {contexts.map((context) => (
            <TimelineBlock
              key={context.id}
              context={context}
              onClick={() => handleContextClick(context)}
            />
          ))}
        </div>
        
        {/* Flow state indicator */}
        <FlowStateOverlay contexts={contexts} />
      </div>
      
      {/* Statistics panel */}
      <div className="timeline-stats">
        <StatCard
          icon={<Zap />}
          label="Flow Sessions"
          value={calculateFlowSessions(contexts)}
          trend="+12%"
        />
        <StatCard
          icon={<GitBranch />}
          label="Context Switches"
          value={contexts.length}
          trend="-8%"
        />
        <StatCard
          icon={<Clock />}
          label="Deep Work"
          value={calculateDeepWork(contexts)}
          trend="+23%"
        />
      </div>
    </div>
  );
};

const TimelineBlock: React.FC<{ context: Context }> = ({ context, onClick }) => {
  const startPos = calculatePosition(context.startTime);
  const duration = calculateDuration(context.startTime, context.endTime);
  
  return (
    <motion.div
      className="timeline-block"
      style={{
        left: `${startPos}%`,
        width: `${duration}%`,
      }}
      initial={{ scale: 0, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      whileHover={{ scale: 1.05, zIndex: 10 }}
      onClick={onClick}
    >
      <div className="block-content">
        <ContextIcon type={context.type} size={16} />
        <span className="block-label">{context.title}</span>
      </div>
      
      {/* Flow state indicator */}
      <div
        className="flow-indicator"
        style={{
          background: getFlowStateColor(context.flowDepth)
        }}
      />
      
      {/* Tooltip on hover */}
      <div className="block-tooltip">
        <p className="tooltip-title">{context.title}</p>
        <p className="tooltip-time">
          {formatTime(context.startTime)} - {formatTime(context.endTime)}
        </p>
        <p className="tooltip-summary">{context.aiSummary}</p>
      </div>
    </motion.div>
  );
};
```

**Timeline Styles:**
```css
.timeline-container {
  @apply flex flex-col h-full p-6;
  @apply bg-gradient-to-br from-gray-900 via-black to-gray-900;
}

.timeline-header {
  @apply flex items-center justify-between mb-6;
}

.timeline-title {
  @apply text-2xl font-bold;
  @apply bg-gradient-to-r from-indigo-400 to-purple-400;
  @apply bg-clip-text text-transparent;
}

.timeline-content {
  @apply relative flex-1 mb-6;
  @apply rounded-xl p-4;
  @apply bg-black/30 border border-white/5;
}

.time-axis {
  @apply flex justify-between mb-4;
  @apply text-xs text-gray-500;
  @apply border-b border-white/5 pb-2;
}

.timeline-blocks {
  @apply relative h-64;
}

.timeline-block {
  @apply absolute h-12 rounded-lg cursor-pointer;
  @apply bg-gradient-to-r from-indigo-600/80 to-purple-600/80;
  @apply border border-white/10;
  @apply transition-all duration-200;
  @apply hover:shadow-lg hover:shadow-indigo-500/50;
}

.block-content {
  @apply flex items-center gap-2 h-full px-3;
  @apply text-white text-sm font-medium;
}

.flow-indicator {
  @apply absolute bottom-0 left-0 right-0 h-1;
  @apply rounded-b-lg;
}

.block-tooltip {
  @apply absolute left-0 top-full mt-2 w-64;
  @apply p-4 rounded-lg;
  @apply bg-gray-900 border border-white/10;
  @apply shadow-xl opacity-0 pointer-events-none;
  @apply transition-opacity duration-200;
  @apply z-50;
}

.timeline-block:hover .block-tooltip {
  @apply opacity-100;
}

.timeline-stats {
  @apply grid grid-cols-3 gap-4;
}

.stat-card {
  @apply p-4 rounded-xl;
  @apply bg-gradient-to-br from-gray-800/50 to-gray-900/50;
  @apply border border-white/5;
}
```

#### 5.4.5 Button Component System

```typescript
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'ghost' | 'danger' | 'success';
  size: 'xs' | 'sm' | 'md' | 'lg';
  isLoading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  isLoading,
  leftIcon,
  rightIcon,
  children,
  onClick,
  disabled
}) => {
  return (
    <motion.button
      className={`btn btn-${variant} btn-${size}`}
      onClick={onClick}
      disabled={disabled || isLoading}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
    >
      {isLoading ? (
        <Loader className="animate-spin" size={16} />
      ) : (
        <>
          {leftIcon && <span className="btn-icon-left">{leftIcon}</span>}
          <span className="btn-text">{children}</span>
          {rightIcon && <span className="btn-icon-right">{rightIcon}</span>}
        </>
      )}
    </motion.button>
  );
};
```

**Button Styles:**
```css
.btn {
  @apply inline-flex items-center justify-center gap-2;
  @apply font-medium rounded-lg;
  @apply transition-all duration-200;
  @apply focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-black;
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
}

/* Sizes */
.btn-xs { @apply px-2 py-1 text-xs; }
.btn-sm { @apply px-3 py-1.5 text-sm; }
.btn-md { @apply px-4 py-2 text-base; }
.btn-lg { @apply px-6 py-3 text-lg; }

/* Variants */
.btn-primary {
  @apply bg-gradient-to-r from-indigo-600 to-purple-600;
  @apply text-white;
  @apply hover:from-indigo-700 hover:to-purple-700;
  @apply focus:ring-indigo-500;
  @apply shadow-lg shadow-indigo-500/20;
}

.btn-secondary {
  @apply bg-gray-800 text-gray-200;
  @apply hover:bg-gray-700;
  @apply border border-white/10;
  @apply focus:ring-gray-500;
}

.btn-ghost {
  @apply bg-transparent text-gray-400;
  @apply hover:bg-gray-800 hover:text-gray-200;
  @apply focus:ring-gray-500;
}

.btn-danger {
  @apply bg-gradient-to-r from-red-600 to-pink-600;
  @apply text-white;
  @apply hover:from-red-700 hover:to-pink-700;
  @apply focus:ring-red-500;
  @apply shadow-lg shadow-red-500/20;
}

.btn-success {
  @apply bg-gradient-to-r from-green-600 to-emerald-600;
  @apply text-white;
  @apply hover:from-green-700 hover:to-emerald-700;
  @apply focus:ring-green-500;
  @apply shadow-lg shadow-green-500/20;
}
```

---

## 6. Core Features - Detailed Specifications {#core-features}

### 6.1 Automatic Context Capture

**Feature ID:** F001  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.1.1 Technical Requirements

```typescript
interface CaptureOptions {
  includeFiles: boolean;
  includeTerminal: boolean;
  includeBrowser: boolean;
  includeScreenshots: boolean;
  captureDepth: 'minimal' | 'standard' | 'comprehensive';
  aiAnalysis: boolean;
}

interface Context {
  id: string;
  userId: string;
  timestamp: number;
  title: string;
  aiSummary: string;
  type: 'manual' | 'auto' | 'scheduled';
  tags: string[];
  
  // Captured data
  files: FileCaptureResult[];
  browserTabs: BrowserTabCapture[];
  terminalSessions: TerminalCapture[];
  ideState: IDEStateCapture;
  applicationWindows: ApplicationWindow[];
  clipboardHistory: ClipboardEntry[];
  screenshots: Screenshot[];
  
  // Metadata
  projectId?: string;
  branch?: string;
  commitHash?: string;
  focusDepth: number; // 0-100 score
  interruptionCount: number;
  duration: number; // milliseconds
  
  // Relationships
  parentContextId?: string; // For context chains
  relatedContextIds: string[];
  
  // Sync status
  syncStatus: 'pending' | 'synced' | 'error';
  lastSyncTime?: number;
  
  // Privacy
  excludedPaths: string[];
  redactedContent: boolean;
}
```

#### 6.1.2 Capture Triggers

1. **Time-Based Triggers:**
   - Every 15 minutes during active work (configurable)
   - Before system sleep/shutdown
   - At end of work day (configurable time)

2. **Event-Based Triggers:**
   - Project switch detected
   - Git branch change
   - IDE workspace change
   - Terminal directory change
   - Before closing 5+ browser tabs
   - Manual capture via hotkey (Cmd+Shift+C)

3. **Smart Triggers:**
   - Focus session completion (2+ hours uninterrupted)
   - Before/after meetings (calendar integration)
   - Context switch detected by AI
   - When opening new project/repository

#### 6.1.3 Capture Pipeline Implementation

```typescript
class ContextCaptureService {
  private captureQueue: PriorityQueue<CaptureTask>;
  private isCapturing: boolean = false;
  
  async captureContext(options: CaptureOptions): Promise<Context> {
    if (this.isCapturing) {
      throw new Error('Capture already in progress');
    }
    
    this.isCapturing = true;
    const startTime = Date.now();
    
    try {
      // Step 1: Gather raw data in parallel
      const [
        files,
        browser,
        terminal,
        ide,
        apps,
        clipboard,
        screenshots
      ] = await Promise.all([
        this.captureFiles(options),
        this.captureBrowser(options),
        this.captureTerminal(options),
        this.captureIDE(options),
        this.captureApplications(options),
        this.captureClipboard(options),
        this.captureScreenshots(options)
      ]);
      
      // Step 2: Process and filter data
      const processedData = await this.processRawCapture({
        files,
        browser,
        terminal,
        ide,
        apps,
        clipboard,
        screenshots
      });
      
      // Step 3: AI analysis
      const aiSummary = await this.aiEngine.generateContextSummary(
        processedData
      );
      
      // Step 4: Extract metadata
      const metadata = this.extractMetadata(processedData);
      
      // Step 5: Calculate focus depth score
      const focusDepth = this.calculateFocusDepth(processedData);
      
      // Step 6: Detect related contexts
      const relatedContexts = await this.findRelatedContexts(
        processedData,
        aiSummary
      );
      
      // Step 7: Assemble context object
      const context: Context = {
        id: generateUUID(),
        userId: this.userId,
        timestamp: startTime,
        title: metadata.title || 'Untitled Context',
        aiSummary,
        type: options.manual ? 'manual' : 'auto',
        tags: metadata.tags,
        
        files: processedData.files,
        browserTabs: processedData.browser,
        terminalSessions: processedData.terminal,
        ideState: processedData.ide,
        applicationWindows: processedData.apps,
        clipboardHistory: processedData.clipboard,
        screenshots: processedData.screenshots,
        
        projectId: metadata.projectId,
        branch: metadata.branch,
        commitHash: metadata.commitHash,
        focusDepth,
        interruptionCount: 0,
        duration: 0,
        
        relatedContextIds: relatedContexts,
        syncStatus: 'pending',
        excludedPaths: options.excludePaths || [],
        redactedContent: false
      };
      
      // Step 8: Save to local DB
      await this.localDB.saveContext(context);
      
      // Step 9: Queue for sync
      this.syncService.queueSync(context);
      
      // Step 10: Update UI
      this.events.emit('context:captured', context);
      
      // Analytics
      this.analytics.track('context_captured', {
        duration: Date.now() - startTime,
        fileCount: files.length,
        tabCount: browser.length,
        captureType: context.type
      });
      
      return context;
      
    } catch (error) {
      this.logger.error('Context capture failed', error);
      throw error;
    } finally {
      this.isCapturing = false;
    }
  }
  
  private async captureFiles(options: CaptureOptions): Promise<FileCaptureResult[]> {
    const activeFiles: FileCaptureResult[] = [];
    
    // Get files from all supported IDEs
    const ideFiles = await Promise.all([
      this.vscodeIntegration.getOpenFiles(),
      this.intellijIntegration.getOpenFiles(),
      this.sublimeIntegration.getOpenFiles()
    ]);
    
    for (const file of ideFiles.flat()) {
      // Skip excluded paths
      if (this.isExcluded(file.path, options.excludePaths)) {
        continue;
      }
      
      // Read file content
      let content = '';
      let contentHash = '';
      
      try {
        if (file.size < 1024 * 1024) { // < 1MB
          content = await fs.readFile(file.path, 'utf-8');
          contentHash = this.hashContent(content);
        } else {
          // For large files, capture excerpts
          content = await this.captureExcerpt(file.path);
          contentHash = this.hashFile(file.path);
        }
      } catch (error) {
        this.logger.warn(`Failed to read file: ${file.path}`, error);
        continue;
      }
      
      // Extract language
      const language = this.detectLanguage(file.path);
      
      // Get cursor position and selections
      const editorState = await this.getEditorState(file.path);
      
      // Get git status
      const gitStatus = await this.getGitStatus(file.path);
      
      activeFiles.push({
        path: file.path,
        content,
        contentHash,
        excerpt: content.substring(0, 500),
        language,
        cursorPosition: editorState.cursor,
        selections: editorState.selections,
        scrollPosition: editorState.scroll,
        folds: editorState.folds,
        breakpoints: editorState.breakpoints,
        bookmarks: editorState.bookmarks,
        fileSize: file.size,
        lastModified: file.mtime,
        gitStatus
      });
    }
    
    return activeFiles;
  }
  
  private async captureBrowser(options: CaptureOptions): Promise<BrowserTabCapture[]> {
    const tabs: BrowserTabCapture[] = [];
    
    // Connect to browser extension
    const browserTabs = await this.browserExtension.getAllTabs();
    
    for (const tab of browserTabs) {
      // Calculate relevance score using AI
      const relevanceScore = await this.aiEngine.scoreTabRelevance(tab);
      
      // Skip low-relevance tabs
      if (relevanceScore < 0.3) continue;
      
      // Categorize tab
      const category = this.categorizeTab(tab.url);
      
      // Capture screenshot thumbnail
      let screenshot: string | undefined;
      if (options.includeScreenshots) {
        screenshot = await this.browserExtension.captureTab(tab.id);
      }
      
      // Extract form data for unsaved work
      let formData: Record<string, string> | undefined;
      if (this.isFormPage(tab.url)) {
        formData = await this.browserExtension.extractFormData(tab.id);
      }
      
      tabs.push({
        url: tab.url,
        title: tab.title,
        favicon: tab.favicon,
        screenshot,
        scrollPosition: await this.browserExtension.getScrollPosition(tab.id),
        formData,
        selectedText: await this.browserExtension.getSelection(tab.id),
        openTime: tab.openTime,
        lastActiveTime: tab.lastActiveTime,
        category,
        relevanceScore
      });
    }
    
    // Sort by relevance
    return tabs.sort((a, b) => b.relevanceScore - a.relevanceScore);
  }
  
  private async captureTerminal(options: CaptureOptions): Promise<TerminalCapture[]> {
    const sessions: TerminalCapture[] = [];
    
    // Get terminal sessions from all supported terminals
    const terminalApps = [
      'iTerm2',
      'Terminal',
      'Hyper',
      'Warp',
      'Alacritty',
      'Windows Terminal'
    ];
    
    for (const app of terminalApps) {
      const appSessions = await this.terminalIntegration.getSessions(app);
      
      for (const session of appSessions) {
        // Capture command history
        const history = await this.terminalIntegration.getHistory(
          session.id,
          100 // last 100 commands
        );
        
        // Capture output
        const output = await this.terminalIntegration.getOutput(
          session.id,
          1000 // last 1000 lines
        );
        
        // Get environment variables (filtered)
        const envVars = await this.terminalIntegration.getEnvVars(session.id);
        const filteredEnv = this.filterSensitiveEnv(envVars);
        
        // Get active processes
        const processes = await this.terminalIntegration.getProcesses(session.id);
        
        sessions.push({
          sessionId: session.id,
          workingDirectory: session.cwd,
          history: this.redactSensitiveCommands(history),
          output: this.redactSensitiveOutput(output),
          environmentVariables: filteredEnv,
          activeProcesses: processes,
          shell: session.shell,
          tabs: session.tabs
        });
      }
    }
    
    return sessions;
  }
  
  private calculateFocusDepth(data: ProcessedCaptureData): number {
    let score = 0;
    
    // More open files = higher focus
    score += Math.min(data.files.length * 5, 30);
    
    // Relevant browser tabs = higher focus
    const relevantTabs = data.browser.filter(t => t.relevanceScore > 0.7);
    score += Math.min(relevantTabs.length * 3, 20);
    
    // Terminal activity = higher focus
    score += data.terminal.length > 0 ? 15 : 0;
    
    // Breakpoints/debugging = deep focus
    const hasBreakpoints = data.files.some(f => f.breakpoints.length > 0);
    score += hasBreakpoints ? 15 : 0;
    
    // Long file selections = deep reading
    const hasLongSelections = data.files.some(
      f => f.selections.some(s => this.getSelectionLength(s) > 100)
    );
    score += hasLongSelections ? 10 : 0;
    
    // Active test runs = focused development
    const hasTests = data.terminal.some(t => 
      t.history.some(cmd => cmd.includes('test') || cmd.includes('jest'))
    );
    score += hasTests ? 10 : 0;
    
    return Math.min(score, 100);
  }
}
```

### 6.2 One-Click Context Restoration

**Feature ID:** F002  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.2.1 Restoration Pipeline

```typescript
class ContextRestorationService {
  async restoreContext(contextId: string): Promise<void> {
    const startTime = Date.now();
    
    try {
      // Step 1: Fetch context
      const context = await this.localDB.getContext(contextId);
      if (!context) {
        throw new Error('Context not found');
      }
      
      // Step 2: Show restoration UI
      this.showRestorationProgress(context);
      
      // Step 3: Restore in parallel
      const results = await Promise.allSettled([
        this.restoreFiles(context.files),
        this.restoreBrowserTabs(context.browserTabs),
        this.restoreTerminal(context.terminalSessions),
        this.restoreIDE(context.ideState),
        this.restoreApplications(context.applicationWindows)
      ]);
      
      // Step 4: Check for failures
      const failures = results.filter(r => r.status === 'rejected');
      if (failures.length > 0) {
        this.logger.warn('Some restoration steps failed', failures);
        this.showPartialRestoreNotification(failures);
      }
      
      // Step 5: Update context metadata
      await this.localDB.updateContext(contextId, {
        lastRestoredAt: Date.now(),
        restorationCount: context.restorationCount + 1
      });
      
      // Step 6: Show AI summary
      this.showContextSummary(context);
      
      // Step 7: Track analytics
      this.analytics.track('context_restored', {
        contextId,
        duration: Date.now() - startTime,
        fileCount: context.files.length,
        tabCount: context.browserTabs.length,
        failures: failures.length
      });
      
      // Step 8: Show success notification
      this.showSuccessNotification(context);
      
    } catch (error) {
      this.logger.error('Context restoration failed', error);
      this.showErrorNotification(error);
      throw error;
    }
  }
  
  private async restoreFiles(files: FileCaptureResult[]): Promise<void> {
    // Open files in appropriate IDEs
    const filesByIDE = this.groupFilesByIDE(files);
    
    for (const [ide, ideFiles] of Object.entries(filesByIDE)) {
      const integration = this.getIDEIntegration(ide);
      
      for (const file of ideFiles) {
        try {
          // Open file
          await integration.openFile(file.path);
          
          // Restore cursor position
          await integration.setCursorPosition(
            file.path,
            file.cursorPosition
          );
          
          // Restore selections
          for (const selection of file.selections) {
            await integration.addSelection(file.path, selection);
          }
          
          // Restore scroll position
          await integration.setScrollPosition(
            file.path,
            file.scrollPosition
          );
          
          // Restore folds
          await integration.setFolds(file.path, file.folds);
          
          // Restore breakpoints
          for (const breakpoint of file.breakpoints) {
            await integration.addBreakpoint(file.path, breakpoint);
          }
          
        } catch (error) {
          this.logger.error(`Failed to restore file: ${file.path}`, error);
        }
      }
    }
  }
  
  private async restoreBrowserTabs(tabs: BrowserTabCapture[]): Promise<void> {
    // Sort tabs by relevance
    const sortedTabs = tabs.sort((a, b) => b.relevanceScore - a.relevanceScore);
    
    // Open tabs in batches to avoid overwhelming the browser
    const batchSize = 5;
    for (let i = 0; i < sortedTabs.length; i += batchSize) {
      const batch = sortedTabs.slice(i, i + batchSize);
      
      await Promise.all(batch.map(async (tab) => {
        try {
          // Open tab
          const tabId = await this.browserExtension.openTab(tab.url);
          
          // Wait for page load
          await this.browserExtension.waitForLoad(tabId);
          
          // Restore scroll position
          await this.browserExtension.setScrollPosition(
            tabId,
            tab.scrollPosition
          );
          
          // Restore form data if exists
          if (tab.formData) {
            await this.browserExtension.fillForm(tabId, tab.formData);
          }
          
        } catch (error) {
          this.logger.error(`Failed to restore tab: ${tab.url}`, error);
        }
      }));
      
      // Small delay between batches
      await this.sleep(500);
    }
  }
  
  private async restoreTerminal(sessions: TerminalCapture[]): Promise<void> {
    for (const session of sessions) {
      try {
        // Create new terminal session
        const terminalId = await this.terminalIntegration.createSession(
          session.shell
        );
        
        // Set working directory
        await this.terminalIntegration.changeDirectory(
          terminalId,
          session.workingDirectory
        );
        
        // Optionally restore environment variables
        if (this.settings.restoreEnvVars) {
          await this.terminalIntegration.setEnvVars(
            terminalId,
            session.environmentVariables
          );
        }
        
        // Show command history context
        await this.terminalIntegration.sendComment(
          terminalId,
          `# Restored context - Previous commands:\n# ${session.history.slice(-5).join('\n# ')}`
        );
        
      } catch (error) {
        this.logger.error('Failed to restore terminal session', error);
      }
    }
  }
  
  private showContextSummary(context: Context): void {
    // Show overlay with AI summary
    this.overlayService.show({
      type: 'context-summary',
      content: {
        title: context.title,
        summary: context.aiSummary,
        timestamp: context.timestamp,
        files: context.files.length,
        tabs: context.browserTabs.length,
        focusDepth: context.focusDepth
      },
      duration: 10000, // 10 seconds
      position: 'top-right'
    });
  }
}
```

### 6.3 AI Context Assistant

**Feature ID:** F003  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.3.1 AI Assistant Implementation

```typescript
class AIAssistantService {
  private openai: OpenAI;
  private conversationHistory: Map<string, ChatMessage[]>;
  private vectorStore: VectorStore;
  
  async chat(
    message: string,
    contextId?: string,
    userId?: string
  ): Promise<AsyncIterableIterator<string>> {
    // Get conversation history
    const history = this.conversationHistory.get(userId || 'default') || [];
    
    // Get current context if provided
    let contextData = null;
    if (contextId) {
      contextData = await this.localDB.getContext(contextId);
    } else {
      // Use active context
      contextData = await this.getActiveContext();
    }
    
    // Build system prompt with context
    const systemPrompt = this.buildSystemPrompt(contextData);
    
    // Prepare messages
    const messages = [
      { role: 'system', content: systemPrompt },
      ...history,
      { role: 'user', content: message }
    ];
    
    // Stream response
    const stream = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages,
      stream: true,
      temperature: 0.7,
      max_tokens: 2000
    });
    
    // Track conversation
    history.push({ role: 'user', content: message });
    
    return this.streamWithHistory(stream, history, userId);
  }
  
  private buildSystemPrompt(context: Context | null): string {
    let prompt = `You are FlowVault's AI Assistant, an expert software development companion.

Your role is to:
1. Help developers understand their working context
2. Answer questions about code, files, and browser tabs in the current context
3. Suggest next steps and debugging strategies
4. Explain code patterns and architectural decisions
5. Help restore mental models after interruptions

Guidelines:
- Be concise but thorough
- Use code examples when helpful
- Reference specific files and line numbers from the context
- Proactively suggest relevant actions
- Maintain a friendly, collaborative tone
`;
    
    if (context) {
      prompt += `\n\nCurrent Context:
Title: ${context.title}
Summary: ${context.aiSummary}
Focus Depth: ${context.focusDepth}/100

Open Files (${context.files.length}):
${context.files.slice(0, 10).map(f => `- ${f.path} (${f.language})`).join('\n')}

Browser Tabs (${context.browserTabs.length}):
${context.browserTabs.slice(0, 5).map(t => `- ${t.title} (${t.url})`).join('\n')}

Recent Terminal Commands:
${context.terminalSessions[0]?.history.slice(-5).join('\n') || 'None'}
`;
    }
    
    return prompt;
  }
  
  async* streamWithHistory(
    stream: AsyncIterable<any>,
    history: ChatMessage[],
    userId: string
  ): AsyncIterableIterator<string> {
    let fullResponse = '';
    
    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || '';
      fullResponse += content;
      yield content;
    }
    
    // Save to history
    history.push({ role: 'assistant', content: fullResponse });
    this.conversationHistory.set(userId, history.slice(-20)); // Keep last 20 messages
  }
  
  // Proactive AI suggestions
  async getSuggestions(context: Context): Promise<string[]> {
    const suggestions: string[] = [];
    
    // Analyze context for suggestions
    const analysis = await this.analyzeContext(context);
    
    if (analysis.hasUncommittedChanges) {
      suggestions.push("You have uncommitted changes in 3 files. Would you like to review them?");
    }
    
    if (analysis.hasFailingTests) {
      suggestions.push("I noticed some tests are failing. Want me to help debug?");
    }
    
    if (analysis.hasOpenStackOverflow) {
      suggestions.push("You have Stack Overflow tabs open about async/await. Need help understanding that concept?");
    }
    
    if (analysis.hasLongFocusSession) {
      suggestions.push("You've been in flow for 2+ hours. Great work! Want to capture this context before taking a break?");
    }
    
    return suggestions;
  }
}
```

### 6.4 Team Context Sharing

**Feature ID:** F004  
**Priority:** P1 (High)  
**Complexity:** Medium

#### 6.4.1 Sharing Implementation

```typescript
interface SharedContext {
  id: string;
  contextId: string;
  sharedBy: string;
  sharedWith: string[]; // User IDs or 'team'
  shareType: 'view' | 'clone' | 'collaborate';
  expiresAt?: number;
  accessCount: number;
  comments: ContextComment[];
  reactions: ContextReaction[];
}

class ContextSharingService {
  async shareContext(
    contextId: string,
    shareWith: string[],
    options: ShareOptions
  ): Promise<string> {
    const context = await this.localDB.getContext(contextId);
    
    // Redact sensitive information
    const sanitizedContext = await this.sanitizeContext(context, options);
    
    // Create share record
    const share: SharedContext = {
      id: generateUUID(),
      contextId: context.id,
      sharedBy: this.userId,
      sharedWith: shareWith,
      shareType: options.type,
      expiresAt: options.expiresAt,
      accessCount: 0,
      comments: [],
      reactions: []
    };
    
    // Upload to backend
    const shareUrl = await this.api.post('/contexts/share', {
      context: sanitizedContext,
      share
    });
    
    // Notify recipients
    await this.notifyRecipients(shareWith, {
      senderName: this.getUserName(),
      contextTitle: context.title,
      shareUrl
    });
    
    return shareUrl;
  }
  
  async cloneSharedContext(shareId: string): Promise<Context> {
    // Fetch shared context
    const shared = await this.api.get(`/contexts/shared/${shareId}`);
    
    // Create local copy
    const localContext = {
      ...shared.context,
      id: generateUUID(),
      userId: this.userId,
      type: 'cloned',
      parentContextId: shared.context.id
    };
    
    // Save locally
    await this.localDB.saveContext(localContext);
    
    // Track access
    await this.api.post(`/contexts/shared/${shareId}/access`);
    
    return localContext;
  }
}
```

### 6.5 Focus Mode & Interruption Filtering

**Feature ID:** F005  
**Priority:** P1 (High)  
**Complexity:** Medium

```typescript
class FocusModeService {
  private isActive: boolean = false;
  private startTime: number = 0;
  private blockedNotifications: Notification[] = [];
  
  async enableFocusMode(duration?: number): Promise<void> {
    this.isActive = true;
    this.startTime = Date.now();
    
    // Configure notification filtering
    await this.configureNotificationFilters();
    
    // Set system Do Not Disturb
    await this.setSystemDND(true);
    
    // Show focus mode indicator
    this.overlayService.showFocusIndicator(duration);
    
    // Schedule auto-disable if duration specified
    if (duration) {
      setTimeout(() => this.disableFocusMode(), duration);
    }
    
    // Track focus session
    this.analytics.track('focus_mode_enabled', {
      duration,
      timestamp: this.startTime
    });
  }
  
  async disableFocusMode(): Promise<void> {
    if (!this.isActive) return;
    
    const sessionDuration = Date.now() - this.startTime;
    this.isActive = false;
    
    // Restore notifications
    await this.setSystemDND(false);
    
    // Show blocked notifications summary
    if (this.blockedNotifications.length > 0) {
      this.showBlockedNotificationsSummary();
    }
    
    // Track focus session completion
    this.analytics.track('focus_session_completed', {
      duration: sessionDuration,
      blockedNotifications: this.blockedNotifications.length
    });
    
    // Clear blocked notifications
    this.blockedNotifications = [];
  }
  
  shouldBlockNotification(notification: Notification): boolean {
    if (!this.isActive) return false;
    
    // Always allow critical notifications
    if (notification.priority === 'critical') {
      return false;
    }
    
    // Block based on source
    const blockedSources = this.settings.focusMode.blockedSources;
    if (blockedSources.includes(notification.source)) {
      this.blockedNotifications.push(notification);
      return true;
    }
    
    // Use AI to determine importance
    const importance = this.aiEngine.scoreNotificationImportance(
      notification,
      this.getActiveContext()
    );
    
    if (importance < 0.7) {
      this.blockedNotifications.push(notification);
      return true;
    }
    
    return false;
  }
}
```

---

## 7. Advanced Features {#advanced-features}

### 7.1 Context Search & Discovery

```typescript
class ContextSearchService {
  async search(query: string, filters?: SearchFilters): Promise<SearchResult[]> {
    // Generate query embedding
    const queryEmbedding = await this.embeddings.generate(query);
    
    // Vector similarity search
    const semanticResults = await this.vectorStore.search(
      queryEmbedding,
      filters?.limit || 20
    );
    
    // Traditional keyword search
    const keywordResults = await this.localDB.searchContexts(query, filters);
    
    // Merge and rank results
    const mergedResults = this.mergeResults(semanticResults, keywordResults);
    
    return mergedResults;
  }
  
  async findSimilarContexts(contextId: string): Promise<Context[]> {
    const context = await this.localDB.getContext(contextId);
    const embedding = await this.embeddings.generate(context.aiSummary);
    
    const similar = await this.vectorStore.search(embedding, 10);
    return similar.filter(c => c.id !== contextId);
  }
}
```

### 7.2 Context Analytics & Insights

```typescript
interface ProductivityInsights {
  // Time analytics
  totalWorkTime: number;
  deepWorkTime: number;
  fragmentedTime: number;
  
  // Context metrics
  contextSwitches: number;
  averageContextDuration: number;
  longestFlowSession: number;
  
  // Focus analytics
  focusScore: number; // 0-100
  interruptionRate: number;
  recoveryTime: number;
  
  // Project analytics
  projectDistribution: Record<string, number>;
  topProjects: Array<{ project: string; time: number }>;
  
  // Technology analytics
  languageDistribution: Record<string, number>;
  toolUsage: Record<string, number>;
  
  // Patterns
  peakProductivityHours: number[];
  contextSwitchPatterns: Array<{ from: string; to: string; frequency: number }>;
  
  // Trends
  weekOverWeekChange: number;
  monthOverMonthChange: number;
}

class AnalyticsService {
  async generateInsights(
    userId: string,
    timeRange: TimeRange
  ): Promise<ProductivityInsights> {
    const contexts = await this.localDB.getContextsInRange(userId, timeRange);
    
    // Calculate time metrics
    const timeMetrics = this.calculateTimeMetrics(contexts);
    
    // Calculate focus metrics
    const focusMetrics = this.calculateFocusMetrics(contexts);
    
    // Calculate project distribution
    const projectMetrics = this.calculateProjectMetrics(contexts);
    
    // Calculate technology usage
    const techMetrics = this.calculateTechnologyMetrics(contexts);
    
    // Detect patterns
    const patterns = await this.detectPatterns(contexts);
    
    // Calculate trends
    const trends = await this.calculateTrends(userId, timeRange);
    
    return {
      ...timeMetrics,
      ...focusMetrics,
      ...projectMetrics,
      ...techMetrics,
      ...patterns,
      ...trends
    };
  }
  
  private calculateTimeMetrics(contexts: Context[]): TimeMetrics {
    let totalWorkTime = 0;
    let deepWorkTime = 0;
    let fragmentedTime = 0;
    
    for (const context of contexts) {
      totalWorkTime += context.duration;
      
      if (context.focusDepth > 70) {
        deepWorkTime += context.duration;
      } else if (context.focusDepth < 30) {
        fragmentedTime += context.duration;
      }
    }
    
    return {
      totalWorkTime,
      deepWorkTime,
      fragmentedTime,
      contextSwitches: contexts.length,
      averageContextDuration: totalWorkTime / contexts.length,
      longestFlowSession: Math.max(...contexts.map(c => c.duration))
    };
  }
  
  async detectPatterns(contexts: Context[]): Promise<Patterns> {
    // Analyze context switches
    const switches: Array<{ from: string; to: string }> = [];
    
    for (let i = 1; i < contexts.length; i++) {
      switches.push({
        from: contexts[i - 1].projectId || 'unknown',
        to: contexts[i].projectId || 'unknown'
      });
    }
    
    // Group and count
    const switchFrequency = new Map<string, number>();
    switches.forEach(s => {
      const key = `${s.from}â†’${s.to}`;
      switchFrequency.set(key, (switchFrequency.get(key) || 0) + 1);
    });
    
    // Analyze peak hours
    const hourlyActivity = new Array(24).fill(0);
    contexts.forEach(c => {
      const hour = new Date(c.timestamp).getHours();
      hourlyActivity[hour] += c.duration;
    });
    
    const peakHours = hourlyActivity
      .map((activity, hour) => ({ hour, activity }))
      .sort((a, b) => b.activity - a.activity)
      .slice(0, 5)
      .map(h => h.hour);
    
    return {
      contextSwitchPatterns: Array.from(switchFrequency.entries())
        .map(([pattern, frequency]) => {
          const [from, to] = pattern.split('â†’');
          return { from, to, frequency };
        })
        .sort((a, b) => b.frequency - a.frequency)
        .slice(0, 10),
      peakProductivityHours: peakHours
    };
  }
}
```

### 7.3 Smart Notifications & Suggestions

```typescript
class SmartNotificationService {
  async generateNotifications(): Promise<Notification[]> {
    const notifications: Notification[] = [];
    const activeContext = await this.getActiveContext();
    const insights = await this.analytics.getCurrentInsights();
    
    // Long context without capture
    if (activeContext && Date.now() - activeContext.timestamp > 3600000) {
      notifications.push({
        id: generateUUID(),
        type: 'suggestion',
        priority: 'medium',
        title: 'Capture your progress?',
        message: "You've been working for over an hour. Save this context to preserve your flow state.",
        action: {
          label: 'Capture Now',
          handler: () => this.captureContext()
        }
      });
    }
    
    // Focus session achievement
    if (insights.longestFlowSession > 7200000) { // 2 hours
      notifications.push({
        type: 'achievement',
        priority: 'low',
        title: 'ðŸŽ‰ Flow Master!',
        message: 'You just completed a 2+ hour deep work session!',
        action: {
          label: 'View Stats',
          handler: () => this.showAnalytics()
        }
      });
    }
    
    // Context switch warning
    if (insights.contextSwitches > 20 && insights.deepWorkTime < 3600000) {
      notifications.push({
        type: 'insight',
        priority: 'medium',
        title: 'High context switching detected',
        message: 'You switched contexts 20+ times today with limited deep work. Try Focus Mode?',
        action: {
          label: 'Enable Focus Mode',
          handler: () => this.enableFocusMode()
        }
      });
    }
    
    // Similar past context
    const similar = await this.findSimilarPastContext(activeContext);
    if (similar) {
      notifications.push({
        type: 'suggestion',
        priority: 'high',
        title: 'Related context found',
        message: `You worked on something similar 2 days ago: "${similar.title}"`,
        action: {
          label: 'View Context',
          handler: () => this.viewContext(similar.id)
        }
      });
    }
    
    return notifications;
  }
  
  // Proactive context suggestions
  async suggestContextRestore(): Promise<Context | null> {
    const currentTime = new Date().getHours();
    const currentDay = new Date().getDay();
    
    // Find contexts at similar time/day in the past
    const historicalContexts = await this.localDB.getContextsByTimePattern({
      hour: currentTime,
      dayOfWeek: currentDay,
      limit: 10
    });
    
    if (historicalContexts.length === 0) return null;
    
    // Use AI to pick the most relevant
    const relevanceScores = await Promise.all(
      historicalContexts.map(async c => ({
        context: c,
        score: await this.aiEngine.scoreContextRelevance(c)
      }))
    );
    
    const best = relevanceScores.sort((a, b) => b.score - a.score)[0];
    
    if (best.score > 0.7) {
      return best.context;
    }
    
    return null;
  }
}
```

### 7.4 Collaborative Features

```typescript
interface CollaborationSession {
  id: string;
  contextId: string;
  participants: Participant[];
  startTime: number;
  endTime?: number;
  sharedCursor: CursorPosition[];
  chat: ChatMessage[];
  activities: Activity[];
}

class CollaborationService {
  private websocket: WebSocket;
  
  async startCollaboration(contextId: string): Promise<string> {
    const context = await this.localDB.getContext(contextId);
    
    // Create collaboration session
    const session: CollaborationSession = {
      id: generateUUID(),
      contextId,
      participants: [
        {
          userId: this.userId,
          name: this.userName,
          role: 'host',
          joinedAt: Date.now()
        }
      ],
      startTime: Date.now(),
      sharedCursor: [],
      chat: [],
      activities: []
    };
    
    // Start WebSocket connection
    await this.websocket.send('collab:start', session);
    
    // Share invite link
    const inviteLink = await this.generateInviteLink(session.id);
    
    return inviteLink;
  }
  
  async joinCollaboration(sessionId: string): Promise<void> {
    // Join WebSocket room
    await this.websocket.send('collab:join', {
      sessionId,
      userId: this.userId,
      userName: this.userName
    });
    
    // Listen for events
    this.websocket.on('collab:cursor', (data) => {
      this.updateRemoteCursor(data);
    });
    
    this.websocket.on('collab:activity', (data) => {
      this.handleRemoteActivity(data);
    });
    
    this.websocket.on('collab:chat', (data) => {
      this.handleChatMessage(data);
    });
  }
  
  async shareCursorPosition(position: CursorPosition): Promise<void> {
    await this.websocket.send('collab:cursor', {
      userId: this.userId,
      position
    });
  }
  
  async shareActivity(activity: Activity): Promise<void> {
    await this.websocket.send('collab:activity', {
      userId: this.userId,
      activity
    });
  }
}
```

### 7.5 Context Automation & Workflows

```typescript
interface Workflow {
  id: string;
  name: string;
  trigger: WorkflowTrigger;
  actions: WorkflowAction[];
  enabled: boolean;
}

interface WorkflowTrigger {
  type: 'time' | 'event' | 'condition';
  config: any;
}

interface WorkflowAction {
  type: 'capture' | 'restore' | 'notify' | 'sync' | 'custom';
  config: any;
}

class WorkflowService {
  private workflows: Map<string, Workflow> = new Map();
  
  async createWorkflow(workflow: Workflow): Promise<void> {
    this.workflows.set(workflow.id, workflow);
    
    // Register trigger
    this.registerTrigger(workflow);
    
    await this.localDB.saveWorkflow(workflow);
  }
  
  private registerTrigger(workflow: Workflow): void {
    switch (workflow.trigger.type) {
      case 'time':
        this.registerTimeTrigger(workflow);
        break;
      case 'event':
        this.registerEventTrigger(workflow);
        break;
      case 'condition':
        this.registerConditionTrigger(workflow);
        break;
    }
  }
  
  private registerTimeTrigger(workflow: Workflow): void {
    const { schedule } = workflow.trigger.config;
    
    // Use cron-like scheduling
    cron.schedule(schedule, async () => {
      if (workflow.enabled) {
        await this.executeWorkflow(workflow);
      }
    });
  }
  
  private registerEventTrigger(workflow: Workflow): void {
    const { event } = workflow.trigger.config;
    
    this.events.on(event, async (data) => {
      if (workflow.enabled && this.evaluateConditions(workflow, data)) {
        await this.executeWorkflow(workflow, data);
      }
    });
  }
  
  private async executeWorkflow(
    workflow: Workflow,
    data?: any
  ): Promise<void> {
    this.logger.info(`Executing workflow: ${workflow.name}`);
    
    for (const action of workflow.actions) {
      try {
        await this.executeAction(action, data);
      } catch (error) {
        this.logger.error(`Workflow action failed: ${action.type}`, error);
      }
    }
    
    this.analytics.track('workflow_executed', {
      workflowId: workflow.id,
      workflowName: workflow.name
    });
  }
  
  private async executeAction(action: WorkflowAction, data?: any): Promise<void> {
    switch (action.type) {
      case 'capture':
        await this.contextCapture.captureContext(action.config);
        break;
        
      case 'restore':
        await this.contextRestore.restoreContext(action.config.contextId);
        break;
        
      case 'notify':
        await this.notifications.show(action.config);
        break;
        
      case 'sync':
        await this.sync.syncAll();
        break;
        
      case 'custom':
        await this.pluginManager.executePlugin(
          action.config.pluginId,
          action.config.action,
          data
        );
        break;
    }
  }
}

// Example workflows
const exampleWorkflows: Workflow[] = [
  {
    id: 'auto-capture-eod',
    name: 'Auto-capture at end of day',
    trigger: {
      type: 'time',
      config: { schedule: '0 18 * * *' } // 6 PM daily
    },
    actions: [
      {
        type: 'capture',
        config: { captureDepth: 'comprehensive' }
      },
      {
        type: 'notify',
        config: {
          title: 'Context saved',
          message: 'Your end-of-day context has been captured'
        }
      }
    ],
    enabled: true
  },
  {
    id: 'restore-morning',
    name: 'Restore yesterday\'s context in the morning',
    trigger: {
      type: 'time',
      config: { schedule: '0 9 * * *' } // 9 AM daily
    },
    actions: [
      {
        type: 'restore',
        config: { contextId: 'last' }
      }
    ],
    enabled: true
  },
  {
    id: 'focus-mode-deep-work',
    name: 'Enable focus mode during deep work hours',
    trigger: {
      type: 'time',
      config: { schedule: '0 10-12,14-16 * * *' } // 10 AM-12 PM, 2-4 PM
    },
    actions: [
      {
        type: 'custom',
        config: {
          pluginId: 'focus-mode',
          action: 'enable',
          duration: 7200000 // 2 hours
        }
      }
    ],
    enabled: false
  }
];
```

### 7.6 Context Templates

```typescript
interface ContextTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  icon: string;
  files: string[]; // File paths or patterns
  browserTabs: string[]; // URLs
  terminalCommands: string[];
  ideConfig: any;
  tags: string[];
}

class TemplateService {
  async createFromContext(contextId: string): Promise<ContextTemplate> {
    const context = await this.localDB.getContext(contextId);
    
    const template: ContextTemplate = {
      id: generateUUID(),
      name: `${context.title} Template`,
      description: context.aiSummary,
      category: this.detectCategory(context),
      icon: this.selectIcon(context),
      files: context.files.map(f => this.generalizePath(f.path)),
      browserTabs: context.browserTabs.map(t => t.url),
      terminalCommands: context.terminalSessions[0]?.history.slice(-5) || [],
      ideConfig: context.ideState,
      tags: context.tags
    };
    
    await this.localDB.saveTemplate(template);
    
    return template;
  }
  
  async applyTemplate(templateId: string): Promise<Context> {
    const template = await this.localDB.getTemplate(templateId);
    
    // Create new context from template
    const context: Context = {
      id: generateUUID(),
      userId: this.userId,
      timestamp: Date.now(),
      title: template.name,
      aiSummary: template.description,
      type: 'manual',
      tags: template.tags,
      files: [],
      browserTabs: [],
      terminalSessions: [],
      // ... other fields
    };
    
    // Apply file patterns
    for (const pattern of template.files) {
      const matchedFiles = await this.findMatchingFiles(pattern);
      for (const file of matchedFiles) {
        await this.ideIntegration.openFile(file);
      }
    }
    
    // Open browser tabs
    for (const url of template.browserTabs) {
      await this.browserExtension.openTab(url);
    }
    
    // Execute terminal commands
    if (template.terminalCommands.length > 0) {
      const terminalId = await this.terminalIntegration.createSession();
      for (const command of template.terminalCommands) {
        await this.terminalIntegration.sendCommand(terminalId, command);
      }
    }
    
    // Capture the applied template as a context
    await this.sleep(2000); // Wait for everything to open
    return await this.contextCapture.captureContext({
      includeFiles: true,
      includeBrowser: true,
      includeTerminal: true,
      captureDepth: 'standard',
      aiAnalysis: true
    });
  }
}

// Built-in templates
const builtInTemplates: ContextTemplate[] = [
  {
    id: 'react-dev',
    name: 'React Development',
    description: 'Set up for React component development',
    category: 'frontend',
    icon: 'âš›ï¸',
    files: [
      'src/components/**/*.tsx',
      'src/App.tsx',
      'package.json'
    ],
    browserTabs: [
      'http://localhost:3000',
      'https://react.dev/reference',
      'https://tailwindcss.com/docs'
    ],
    terminalCommands: [
      'npm run dev'
    ],
    ideConfig: {},
    tags: ['react', 'frontend', 'typescript']
  },
  {
    id: 'debugging',
    name: 'Debugging Session',
    description: 'Set up for debugging with logs and breakpoints',
    category: 'debugging',
    icon: 'ðŸ›',
    files: [
      'src/**/*.log',
      'tests/**/*.test.ts'
    ],
    browserTabs: [
      'http://localhost:3000/debug',
      'https://stackoverflow.com'
    ],
    terminalCommands: [
      'npm run test:debug',
      'tail -f logs/error.log'
    ],
    ideConfig: {
      enableBreakpoints: true,
      openDebugConsole: true
    },
    tags: ['debugging', 'testing']
  },
  {
    id: 'api-dev',
    name: 'API Development',
    description: 'Backend API development setup',
    category: 'backend',
    icon: 'ðŸ”Œ',
    files: [
      'src/routes/**/*.ts',
      'src/controllers/**/*.ts',
      'src/models/**/*.ts'
    ],
    browserTabs: [
      'http://localhost:8000/docs',
      'https://expressjs.com/en/api.html'
    ],
    terminalCommands: [
      'npm run dev',
      'curl http://localhost:8000/health'
    ],
    ideConfig: {},
    tags: ['backend', 'api', 'nodejs']
  }
];
```

---

## 8. Data Models & Database Schema {#data-models}

### 8.1 SQLite Schema (Local Database)

```sql
-- Users table
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  avatar_url TEXT,
  settings TEXT, -- JSON
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Contexts table
CREATE TABLE contexts (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  title TEXT NOT NULL,
  ai_summary TEXT,
  type TEXT NOT NULL, -- 'manual', 'auto', 'scheduled'
  tags TEXT, -- JSON array
  project_id TEXT,
  branch TEXT,
  commit_hash TEXT,
  focus_depth INTEGER,
  interruption_count INTEGER DEFAULT 0,
  duration INTEGER DEFAULT 0,
  parent_context_id TEXT,
  related_context_ids TEXT, -- JSON array
  sync_status TEXT DEFAULT 'pending',
  last_sync_time INTEGER,
  excluded_paths TEXT, -- JSON array
  redacted_content INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (parent_context_id) REFERENCES contexts(id)
);

CREATE INDEX idx_contexts_user_id ON contexts(user_id);
CREATE INDEX idx_contexts_timestamp ON contexts(timestamp);
CREATE INDEX idx_contexts_project_id ON contexts(project_id);
CREATE INDEX idx_contexts_sync_status ON contexts(sync_status);

-- Files table
CREATE TABLE files (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  path TEXT NOT NULL,
  content TEXT,
  content_hash TEXT NOT NULL,
  excerpt TEXT,
  language TEXT,
  cursor_line INTEGER,
  cursor_column INTEGER,
  selections TEXT, -- JSON
  scroll_position INTEGER,
  folds TEXT, -- JSON array
  breakpoints TEXT, -- JSON array
  bookmarks TEXT, -- JSON
  file_size INTEGER,
  last_modified INTEGER,
  git_branch TEXT,
  git_changes INTEGER,
  git_staged INTEGER,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_files_context_id ON files(context_id);
CREATE INDEX idx_files_path ON files(path);

-- Browser tabs table
CREATE TABLE browser_tabs (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  url TEXT NOT NULL,
  title TEXT,
  favicon TEXT,
  screenshot TEXT, -- Base64 or URL
  scroll_position INTEGER,
  form_data TEXT, -- JSON
  selected_text TEXT,
  open_time INTEGER,
  last_active_time INTEGER,
  category TEXT,
  relevance_score REAL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_browser_tabs_context_id ON browser_tabs(context_id);

-- Terminal sessions table
CREATE TABLE terminal_sessions (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  working_directory TEXT,
  history TEXT, -- JSON array
  output TEXT,
  environment_variables TEXT, -- JSON
  active_processes TEXT, -- JSON array
  shell TEXT,
  tabs TEXT, -- JSON array
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_terminal_sessions_context_id ON terminal_sessions(context_id);

-- IDE state table
CREATE TABLE ide_states (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  type TEXT NOT NULL,
  open_projects TEXT, -- JSON array
  workspace TEXT, -- JSON
  extensions TEXT, -- JSON array
  debug_sessions TEXT, -- JSON array
  run_configurations TEXT, -- JSON array
  search_history TEXT, -- JSON array
  recent_files TEXT, -- JSON array
  pinned_files TEXT, -- JSON array
  split_layout TEXT, -- JSON
  editor_groups TEXT, -- JSON array
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_ide_states_context_id ON ide_states(context_id);

-- Context embeddings table (for semantic search)
CREATE TABLE context_embeddings (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  embedding BLOB NOT NULL, -- Vector embedding
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_context_embeddings_context_id ON context_embeddings(context_id);

-- Workflows table
CREATE TABLE workflows (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  trigger_type TEXT NOT NULL,
  trigger_config TEXT, -- JSON
  actions TEXT, -- JSON array
  enabled INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_workflows_user_id ON workflows(user_id);

-- Templates table
CREATE TABLE templates (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT,
  icon TEXT,
  files TEXT, -- JSON array
  browser_tabs TEXT, -- JSON array
  terminal_commands TEXT, -- JSON array
  ide_config TEXT, -- JSON
  tags TEXT, -- JSON array
  is_public INTEGER DEFAULT 0,
  usage_count INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_templates_user_id ON templates(user_id);
CREATE INDEX idx_templates_category ON templates(category);

-- Analytics events table
CREATE TABLE analytics_events (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  event_name TEXT NOT NULL,
  event_data TEXT, -- JSON
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_analytics_events_user_id ON analytics_events(user_id);
CREATE INDEX idx_analytics_events_timestamp ON analytics_events(timestamp);

-- Settings table
CREATE TABLE settings (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  key TEXT NOT NULL,
  value TEXT, -- JSON
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE(user_id, key)
);

CREATE INDEX idx_settings_user_id ON settings(user_id);
```

### 8.2 PostgreSQL Schema (Backend Database)

```sql
-- Users table (backend)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255),
  avatar_url TEXT,
  password_hash VARCHAR(255),
  subscription_tier VARCHAR(50) DEFAULT 'free',
  subscription_status VARCHAR(50),
  stripe_customer_id VARCHAR(255),
  settings JSONB,
  last_login_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_subscription_tier ON users(subscription_tier);

-- Contexts table (cloud storage)
CREATE TABLE contexts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  local_id VARCHAR(255), -- ID from client
  timestamp BIGINT NOT NULL,
  title TEXT NOT NULL,
  ai_summary TEXT,
  type VARCHAR(50) NOT NULL,
  tags JSONB,
  project_id VARCHAR(255),
  branch VARCHAR(255),
  commit_hash VARCHAR(255),
  focus_depth INTEGER,
  interruption_count INTEGER DEFAULT 0,
  duration INTEGER DEFAULT 0,
  parent_context_id UUID,
  related_context_ids JSONB,
  excluded_paths JSONB,
  redacted_content BOOLEAN DEFAULT FALSE,
  data JSONB, -- Full context data
  embedding vector(1536), -- For vector similarity search
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_context_id) REFERENCES contexts(id)
);

CREATE INDEX idx_contexts_user_id ON contexts(user_id);
CREATE INDEX idx_contexts_timestamp ON contexts(timestamp);
CREATE INDEX idx_contexts_project_id ON contexts(project_id);
CREATE INDEX idx_contexts_embedding ON contexts USING ivfflat (embedding vector_cosine_ops);

-- Shared contexts table
CREATE TABLE shared_contexts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  context_id UUID NOT NULL,
  shared_by UUID NOT NULL,
  share_type VARCHAR(50) NOT NULL, -- 'view', 'clone', 'collaborate'
  expires_at TIMESTAMP,
  access_count INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE,
  FOREIGN KEY (shared_by) REFERENCES users(id)
);

CREATE INDEX idx_shared_contexts_context_id ON shared_contexts(context_id);

-- Shared context access table
CREATE TABLE shared_context_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shared_context_id UUID NOT NULL,
  user_id UUID,
  share_token VARCHAR(255),
  accessed_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (shared_context_id) REFERENCES shared_contexts(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Teams table
CREATE TABLE teams (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  owner_id UUID NOT NULL,
  subscription_tier VARCHAR(50) DEFAULT 'team',
  settings JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (owner_id) REFERENCES users(id)
);

-- Team members table
CREATE TABLE team_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  team_id UUID NOT NULL,
  user_id UUID NOT NULL,
  role VARCHAR(50) DEFAULT 'member', -- 'admin', 'member'
  joined_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE(team_id, user_id)
);

-- Subscriptions table
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID,
  team_id UUID,
  stripe_subscription_id VARCHAR(255) UNIQUE,
  plan VARCHAR(50) NOT NULL,
  status VARCHAR(50) NOT NULL,
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,

// Listen for file changes
    vscode.workspace.onDidOpenTextDocument((doc) => {
      this.notifyFileOpen(doc);
    });
    
    vscode.workspace.onDidChangeTextDocument((e) => {
      this.notifyFileChange(e);
    });
    
    // Listen for workspace changes
    vscode.workspace.onDidChangeWorkspaceFolders(() => {
      this.notifyWorkspaceChange();
    });
  }
  
  async captureContext(): Promise<void> {
    const editor = vscode.window.activeTextEditor;
    if (!editor) return;
    
    const contextData = {
      openFiles: vscode.workspace.textDocuments.map(doc => ({
        path: doc.fileName,
        language: doc.languageId,
        cursorPosition: editor.selection.active,
        selections: editor.selections,
        scrollPosition: editor.visibleRanges[0]?.start.line || 0
      })),
      workspace: vscode.workspace.workspaceFolders?.[0]?.uri.fsPath,
      activeFile: editor.document.fileName,
      debugSessions: vscode.debug.activeDebugSession ? [{
        name: vscode.debug.activeDebugSession.name,
        type: vscode.debug.activeDebugSession.type
      }] : []
    };
    
    // Send to main app
    await this.sendToMainApp('capture', contextData);
  }
  
  private async sendToMainApp(action: string, data: any): Promise<void> {
    // IPC communication with Electron app
    const ipc = require('electron').ipcRenderer;
    await ipc.invoke('vscode-extension', { action, data });
  }
}
```

**JetBrains Plugin (IntelliJ IDEA, PyCharm, etc.):**
```kotlin
// IntelliJ Platform Plugin
class FlowVaultPlugin : DumbAware, ApplicationComponent {
    
    override fun initComponent() {
        // Register project listener
        ProjectManager.getInstance().addProjectManagerListener(object : ProjectManagerListener {
            override fun projectOpened(project: Project) {
                initProject(project)
            }
        })
    }
    
    private fun initProject(project: Project) {
        // Register file editor listener
        project.messageBus.connect().subscribe(
            FileEditorManagerListener.FILE_EDITOR_MANAGER,
            object : FileEditorManagerListener {
                override fun fileOpened(source: FileEditorManager, file: VirtualFile) {
                    notifyFileOpen(file)
                }
            }
        )
        
        // Register document listener
        EditorFactory.getInstance().eventMulticaster.addDocumentListener(
            object : DocumentListener {
                override fun documentChanged(event: DocumentEvent) {
                    notifyDocumentChange(event)
                }
            }
        )
    }
    
    fun captureContext(project: Project): ContextData {
        val fileEditorManager = FileEditorManager.getInstance(project)
        val openFiles = fileEditorManager.openFiles
        
        return ContextData(
            openFiles = openFiles.map { file ->
                FileData(
                    path = file.path,
                    language = file.fileType.name,
                    cursorPosition = getCursorPosition(file),
                    content = getFileContent(file)
                )
            },
            projectPath = project.basePath,
            activeFile = fileEditorManager.selectedEditor?.file?.path,
            runConfigurations = RunManager.getInstance(project).allConfigurationsList.map {
                it.name
            },
            debugSessions = XDebuggerManager.getInstance(project).debugSessions.map {
                DebugSessionData(it.sessionName, it.debugProcess.toString())
            }
        )
    }
}
```

### 12.2 Browser Extension

```typescript
// Chrome/Firefox Extension
class FlowVaultBrowserExtension {
  private websocket: WebSocket;
  
  async init(): Promise<void> {
    // Connect to native app
    this.connectToNativeApp();
    
    // Listen for tab events
    chrome.tabs.onCreated.addListener(this.onTabCreated.bind(this));
    chrome.tabs.onUpdated.addListener(this.onTabUpdated.bind(this));
    chrome.tabs.onRemoved.addListener(this.onTabRemoved.bind(this));
    chrome.tabs.onActivated.addListener(this.onTabActivated.bind(this));
    
    // Listen for navigation
    chrome.webNavigation.onCompleted.addListener(this.onNavigationCompleted.bind(this));
  }
  
  async getAllTabs(): Promise<BrowserTabCapture[]> {
    const windows = await chrome.windows.getAll({ populate: true });
    const tabs: BrowserTabCapture[] = [];
    
    for (const window of windows) {
      for (const tab of window.tabs || []) {
        if (!tab.url || tab.url.startsWith('chrome://')) continue;
        
        // Capture tab data
        const tabData = await this.captureTab(tab.id!);
        tabs.push({
          url: tab.url,
          title: tab.title || '',
          favicon: tab.favIconUrl || '',
          screenshot: await this.captureTabScreenshot(tab.id!),
          scrollPosition: await this.getScrollPosition(tab.id!),
          selectedText: await this.getSelectedText(tab.id!),
          openTime: tab.openTime || Date.now(),
          lastActiveTime: tab.lastAccessed || Date.now(),
          category: this.categorizeUrl(tab.url),
          relevanceScore: 1.0
        });
      }
    }
    
    return tabs;
  }
  
  async captureTabScreenshot(tabId: number): Promise<string> {
    return await chrome.tabs.captureVisibleTab(undefined, {
      format: 'png',
      quality: 50
    });
  }
  
  async getScrollPosition(tabId: number): Promise<number> {
    const result = await chrome.scripting.executeScript({
      target: { tabId },
      func: () => window.scrollY
    });
    return result[0]?.result || 0;
  }
  
  async getSelectedText(tabId: number): Promise<string | undefined> {
    const result = await chrome.scripting.executeScript({
      target: { tabId },
      func: () => window.getSelection()?.toString()
    });
    return result[0]?.result;
  }
  
  async extractFormData(tabId: number): Promise<Record<string, string>> {
    const result = await chrome.scripting.executeScript({
      target: { tabId },
      func: () => {
        const formData: Record<string, string> = {};
        const forms = document.querySelectorAll('form');
        
        forms.forEach((form, formIndex) => {
          const inputs = form.querySelectorAll('input, textarea, select');
          inputs.forEach((input: any) => {
            if (input.name && input.value && input.type !== 'password') {
              formData[`form${formIndex}_${input.name}`] = input.value;
            }
          });
        });
        
        return formData;
      }
    });
    
    return result[0]?.result || {};
  }
  
  async openTab(url: string): Promise<number> {
    const tab = await chrome.tabs.create({ url });
    return tab.id!;
  }
  
  async setScrollPosition(tabId: number, position: number): Promise<void> {
    await chrome.scripting.executeScript({
      target: { tabId },
      func: (pos) => window.scrollTo(0, pos),
      args: [position]
    });
  }
  
  async fillForm(tabId: number, formData: Record<string, string>): Promise<void> {
    await chrome.scripting.executeScript({
      target: { tabId },
      func: (data) => {
        for (const [key, value] of Object.entries(data)) {
          const [, fieldName] = key.split('_');
          const input = document.querySelector(`[name="${fieldName}"]`) as HTMLInputElement;
          if (input) {
            input.value = value;
          }
        }
      },
      args: [formData]
    });
  }
  
  private connectToNativeApp(): void {
    // Native messaging to Electron app
    const port = chrome.runtime.connectNative('com.flowvault.app');
    
    port.onMessage.addListener((message) => {
      this.handleNativeMessage(message);
    });
    
    port.onDisconnect.addListener(() => {
      console.error('Disconnected from native app');
      setTimeout(() => this.connectToNativeApp(), 5000);
    });
  }
  
  private categorizeUrl(url: string): string {
    if (url.includes('stackoverflow.com')) return 'stackoverflow';
    if (url.includes('github.com') || url.includes('gitlab.com')) return 'github';
    if (url.includes('docs.') || url.includes('/docs/') || url.includes('/documentation/')) return 'documentation';
    if (url.includes('localhost') || url.includes('127.0.0.1')) return 'localhost';
    return 'other';
  }
}
```

### 12.3 Terminal Integration

```typescript
// Terminal integration for iTerm2, Terminal.app, etc.
class TerminalIntegration {
  private terminalType: string;
  
  async detectTerminal(): Promise<string> {
    if (process.platform === 'darwin') {
      // macOS
      const apps = await this.getRunningApplications();
      if (apps.includes('iTerm2')) return 'iterm2';
      if (apps.includes('Terminal')) return 'terminal';
      if (apps.includes('Warp')) return 'warp';
    } else if (process.platform === 'win32') {
      return 'windows-terminal';
    } else {
      return 'gnome-terminal';
    }
    
    return 'unknown';
  }
  
  async getSessions(terminal: string): Promise<TerminalSession[]> {
    switch (terminal) {
      case 'iterm2':
        return this.getITerm2Sessions();
      case 'terminal':
        return this.getTerminalAppSessions();
      case 'warp':
        return this.getWarpSessions();
      default:
        return [];
    }
  }
  
  private async getITerm2Sessions(): Promise<TerminalSession[]> {
    // Use AppleScript to communicate with iTerm2
    const script = `
      tell application "iTerm2"
        set sessionList to {}
        repeat with aWindow in windows
          repeat with aTab in tabs of aWindow
            repeat with aSession in sessions of aTab
              set sessionInfo to {
                id: id of aSession,
                name: name of aSession,
                cwd: variable named "session.path" of aSession,
                shell: variable named "session.shell" of aSession
              }
              set end of sessionList to sessionInfo
            end repeat
          end repeat
        end repeat
        return sessionList
      end tell
    `;
    
    const result = await this.execAppleScript(script);
    return this.parseAppleScriptResult(result);
  }
  
  async getHistory(sessionId: string, limit: number = 100): Promise<string[]> {
    // Read shell history file
    const historyFile = path.join(os.homedir(), '.zsh_history');
    
    try {
      const content = await fs.readFile(historyFile, 'utf-8');
      const lines = content.split('\n').filter(Boolean);
      return lines.slice(-limit);
    } catch (error) {
      console.error('Failed to read history:', error);
      return [];
    }
  }
  
  async getOutput(sessionId: string, lines: number = 1000): Promise<string> {
    // This depends on terminal type
    // For iTerm2, use AppleScript
    const script = `
      tell application "iTerm2"
        tell session id "${sessionId}"
          set output to text
          return output
        end tell
      end tell
    `;
    
    try {
      return await this.execAppleScript(script);
    } catch (error) {
      return '';
    }
  }
  
  async createSession(shell: string = 'zsh'): Promise<string> {
    const script = `
      tell application "iTerm2"
        tell current window
          create tab with default profile
          tell current session
            write text "${shell}"
            return id
          end tell
        end tell
      end tell
    `;
    
    return await this.execAppleScript(script);
  }
  
  async sendCommand(sessionId: string, command: string): Promise<void> {
    const script = `
      tell application "iTerm2"
        tell session id "${sessionId}"
          write text "${command}"
        end tell
      end tell
    `;
    
    await this.execAppleScript(script);
  }
  
  async changeDirectory(sessionId: string, directory: string): Promise<void> {
    await this.sendCommand(sessionId, `cd "${directory}"`);
  }
  
  private async execAppleScript(script: string): Promise<string> {
    return new Promise((resolve, reject) => {
      exec(`osascript -e '${script.replace(/'/g, "\\'")}'`, (error, stdout) => {
        if (error) reject(error);
        else resolve(stdout.trim());
      });
    });
  }
}
```

### 12.4 Git Integration

```typescript
class GitIntegration {
  async getRepositoryInfo(directory: string): Promise<GitInfo | null> {
    try {
      const git = simpleGit(directory);
      
      const [branch, status, log] = await Promise.all([
        git.branch(),
        git.status(),
        git.log({ maxCount: 10 })
      ]);
      
      return {
        branch: branch.current,
        remote: await git.getRemotes(true),
        status: {
          modified: status.modified,
          created: status.created,
          deleted: status.deleted,
          renamed: status.renamed,
          staged: status.staged,
          ahead: status.ahead,
          behind: status.behind
        },
        recentCommits: log.all.map(commit => ({
          hash: commit.hash,
          message: commit.message,
          author: commit.author_name,
          date: commit.date
        }))
      };
    } catch (error) {
      return null;
    }
  }
  
  async getFileStatus(filePath: string): Promise<FileGitStatus | null> {
    const repoPath = await this.findRepositoryRoot(path.dirname(filePath));
    if (!repoPath) return null;
    
    const git = simpleGit(repoPath);
    const status = await git.status();
    
    const relativePath = path.relative(repoPath, filePath);
    
    return {
      branch: status.current || 'unknown',
      changes: this.countFileChanges(status, relativePath),
      staged: status.staged.includes(relativePath)
    };
  }
  
  private async findRepositoryRoot(directory: string): Promise<string | null> {
    let current = directory;
    
    while (current !== '/') {
      if (await fs.pathExists(path.join(current, '.git'))) {
        return current;
      }
      current = path.dirname(current);
    }
    
    return null;
  }
  
  async captureGitContext(directory: string): Promise<GitContext> {
    const git = simpleGit(directory);
    
    const [branch, diff, stash] = await Promise.all([
      git.branch(),
      git.diff(['--stat']),
      git.stashList()
    ]);
    
    return {
      currentBranch: branch.current,
      allBranches: branch.all,
      uncommittedChanges: diff,
      stashedChanges: stash.all.length,
      remotes: await git.getRemotes(true)
    };
  }
}
```

### 12.5 Calendar Integration

```typescript
class CalendarIntegration {
  private googleCalendar: calendar_v3.Calendar;
  private outlookCalendar: any;
  
  async getUpcomingMeetings(hours: number = 2): Promise<Meeting[]> {
    const now = new Date();
    const later = new Date(now.getTime() + hours * 60 * 60 * 1000);
    
    const [googleMeetings, outlookMeetings] = await Promise.all([
      this.getGoogleMeetings(now, later),
      this.getOutlookMeetings(now, later)
    ]);
    
    return [...googleMeetings, ...outlookMeetings].sort(
      (a, b) => a.startTime.getTime() - b.startTime.getTime()
    );
  }
  
  private async getGoogleMeetings(start: Date, end: Date): Promise<Meeting[]> {
    const response = await this.googleCalendar.events.list({
      calendarId: 'primary',
      timeMin: start.toISOString(),
      timeMax: end.toISOString(),
      singleEvents: true,
      orderBy: 'startTime'
    });
    
    return (response.data.items || []).map(event => ({
      id: event.id!,
      title: event.summary || 'Untitled',
      startTime: new Date(event.start?.dateTime || event.start?.date || ''),
      endTime: new Date(event.end?.dateTime || event.end?.date || ''),
      attendees: event.attendees?.map(a => a.email!) || [],
      location: event.location,
      description: event.description
    }));
  }
  
  async shouldCaptureBefore(meeting: Meeting): Promise<boolean> {
    const minutesUntil = (meeting.startTime.getTime() - Date.now()) / 1000 / 60;
    return minutesUntil <= 5 && minutesUntil > 0;
  }
  
  async shouldRestoreAfter(meeting: Meeting): Promise<boolean> {
    const minutesSince = (Date.now() - meeting.endTime.getTime()) / 1000 / 60;
    return minutesSince >= 0 && minutesSince <= 5;
  }
}
```

---

## 13. Analytics & Telemetry {#analytics-telemetry}

### 13.1 Event Tracking

```typescript
interface AnalyticsEvent {
  eventName: string;
  userId: string;
  timestamp: number;
  properties: Record<string, any>;
  sessionId: string;
}

class AnalyticsService {
  private mixpanel: Mixpanel;
  private amplitude: Amplitude;
  private segment: Segment;
  
  async track(eventName: string, properties?: Record<string, any>): Promise<void> {
    const event: AnalyticsEvent = {
      eventName,
      userId: this.userId,
      timestamp: Date.now(),
      properties: {
        ...properties,
        platform: process.platform,
        appVersion: app.getVersion(),
        subscriptionTier: this.subscriptionTier
      },
      sessionId: this.sessionId
    };
    
    // Send to multiple analytics platforms
    await Promise.all([
      this.mixpanel.track(event),
      this.amplitude.track(event),
      this.segment.track(event)
    ]);
    
    // Store locally for backup
    await this.localDB.saveAnalyticsEvent(event);
  }
  
  // Core events to track
  async trackAppLaunched(): Promise<void> {
    await this.track('app_launched', {
      launchTime: Date.now(),
      startupDuration: this.getStartupDuration()
    });
  }
  
  async trackContextCaptured(context: Context): Promise<void> {
    await this.track('context_captured', {
      contextId: context.id,
      type: context.type,
      fileCount: context.files.length,
      tabCount: context.browserTabs.length,
      focusDepth: context.focusDepth,
      duration: context.duration
    });
  }
  
  async trackContextRestored(contextId: string, duration: number): Promise<void> {
    await this.track('context_restored', {
      contextId,
      restorationDuration: duration
    });
  }
  
  async trackAIChatMessage(messageLength: number, responseTime: number): Promise<void> {
    await this.track('ai_chat_message', {
      messageLength,
      responseTime,
      tokensUsed: Math.ceil(messageLength / 4)
    });
  }
  
  async trackFeatureUsed(feature: string): Promise<void> {
    await this.track('feature_used', {
      feature,
      timestamp: Date.now()
    });
  }
  
  async trackError(error: Error, context?: any): Promise<void> {
    await this.track('error_occurred', {
      errorMessage: error.message,
      errorStack: error.stack,
      context
    });
    
    // Also send to error tracking
    Sentry.captureException(error, { extra: context });
  }
  
  // User properties
  async identifyUser(userId: string, properties: UserProperties): Promise<void> {
    await Promise.all([
      this.mixpanel.people.set(userId, properties),
      this.amplitude.identify(userId, properties),
      this.segment.identify(userId, properties)
    ]);
  }
  
  async updateUserProperties(properties: Partial<UserProperties>): Promise<void> {
    await Promise.all([
      this.mixpanel.people.set(this.userId, properties),
      this.amplitude.identify(this.userId, properties)
    ]);
  }
}
```

### 13.2 Product Metrics

```typescript
interface ProductMetrics {
  // Activation metrics
  timeToFirstCapture: number;
  timeToFirstRestore: number;
  timeToFirstAIChat: number;
  
  // Engagement metrics
  dailyActiveUsers: number;
  weeklyActiveUsers: number;
  monthlyActiveUsers: number;
  avgSessionDuration: number;
  avgCapturesPerDay: number;
  avgRestoresPerDay: number;
  
  // Feature adoption
  focusModeUsage: number;
  aiChatUsage: number;
  collaborationUsage: number;
  workflowUsage: number;
  
  // Retention metrics
  day1Retention: number;
  day7Retention: number;
  day30Retention: number;
  
  // Conversion metrics
  freeToProConversion: number;
  proToTeamConversion: number;
  avgTimeToConversion: number;
  
  // Performance metrics
  avgCaptureTime: number;
  avgRestoreTime: number;
  errorRate: number;
  crashRate: number;
}

class MetricsCollector {
  async collectDailyMetrics(): Promise<ProductMetrics> {
    const today = new Date();
    const yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
    
    const [
      activationMetrics,
      engagementMetrics,
      retentionMetrics,
      performanceMetrics
    ] = await Promise.all([
      this.getActivationMetrics(yesterday, today),
      this.getEngagementMetrics(yesterday, today),
      this.getRetentionMetrics(),
      this.getPerformanceMetrics(yesterday, today)
    ]);
    
    return {
      ...activationMetrics,
      ...engagementMetrics,
      ...retentionMetrics,
      ...performanceMetrics
    };
  }
  
  private async getEngagementMetrics(start: Date, end: Date): Promise<any> {
    const events = await this.db.getEventsInRange(start, end);
    
    const dau = new Set(events.map(e => e.userId)).size;
    const captures = events.filter(e => e.eventName === 'context_captured');
    const restores = events.filter(e => e.eventName === 'context_restored');
    
    return {
      dailyActiveUsers: dau,
      avgCapturesPerDay: captures.length / dau,
      avgRestoresPerDay: restores.length / dau
    };
  }
}
```

---

## 14. Monetization Implementation {#monetization-implementation}

### 14.1 Subscription Tiers

```typescript
interface SubscriptionPlan {
  id: string;
  name: string;
  price: number;
  interval: 'month' | 'year';
  features: PlanFeatures;
  limits: PlanLimits;
}

interface PlanFeatures {
  contextsHistoryDays: number;
  aiQueriesPerDay: number;
  collaborationEnabled: boolean;
  focusModeEnabled: boolean;
  analyticsEnabled: boolean;
  prioritySupport: boolean;
  customWorkflows: boolean;
  apiAccess: boolean;
}

interface PlanLimits {
  maxContextsPerDay: number;
  maxStorageGB: number;
  maxTeamMembers: number;
  maxSharedContexts: number;
}

const SUBSCRIPTION_PLANS: SubscriptionPlan[] = [
  {
    id: 'free',
    name: 'Free',
    price: 0,
    interval: 'month',
    features: {
      contextsHistoryDays: 7,
      aiQueriesPerDay: 10,
      collaborationEnabled: false,
      focusModeEnabled: true,
      analyticsEnabled: false,
      prioritySupport: false,
      customWorkflows: false,
      apiAccess: false
    },
    limits: {
      maxContextsPerDay: 10,
      maxStorageGB: 1,
      maxTeamMembers: 0,
      maxSharedContexts: 3
    }
  },
  {
    id: 'pro_monthly',
    name: 'Pro',
    price: 19,
    interval: 'month',
    features: {
      contextsHistoryDays: 365,
      aiQueriesPerDay: 200,
      collaborationEnabled: true,
      focusModeEnabled: true,
      analyticsEnabled: true,
      prioritySupport: false,
      customWorkflows: true,
      apiAccess: false
    },
    limits: {
      maxContextsPerDay: 100,
      maxStorageGB: 50,
      maxTeamMembers: 0,
      maxSharedContexts: 50
    }
  },
  {
    id: 'team_monthly',
    name: 'Team',
    price: 49,
    interval: 'month',
    features: {
      contextsHistoryDays: -1, // unlimited
      aiQueriesPerDay: 1000,
      collaborationEnabled: true,
      focusModeEnabled: true,
      analyticsEnabled: true,
      prioritySupport: true,
      customWorkflows: true,
      apiAccess: true
    },
    limits: {
      maxContextsPerDay: -1, // unlimited
      maxStorageGB: 500,
      maxTeamMembers: 10,
      maxSharedContexts: -1 // unlimited
    }
  }
];
```

### 14.2 Stripe Integration

```typescript
class PaymentService {
  private stripe: Stripe;
  
  async createCheckoutSession(
    userId: string,
    planId: string
  ): Promise<string> {
    const plan = SUBSCRIPTION_PLANS.find(p => p.id === planId);
    if (!plan) throw new Error('Invalid plan');
    
    const session = await this.stripe.checkout.sessions.create({
      customer_email: await this.getUserEmail(userId),
      payment_method_types: ['card'],
      line_items: [{
        price_data: {
          currency: 'usd',
          product_data: {
            name: `FlowVault ${plan.name}`,
            description: this.getPlanDescription(plan)
          },
          unit_amount: plan.price * 100,
          recurring: {
            interval: plan.interval
          }
        },
        quantity: 1
      }],
      mode: 'subscription',
      success_url: `${process.env.APP_URL}/subscription/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.APP_URL}/subscription/cancel`,
      metadata: {
        userId,
        planId
      }
    });
    
    return session.url!;
  }
  
  async handleWebhook(event: Stripe.Event): Promise<void> {
    switch (event.type) {
      case 'checkout.session.completed':
        await this.handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
        break;
        
      case 'customer.subscription.updated':
        await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;
        
      case 'customer.subscription.deleted':
        await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;
        
      case 'invoice.payment_failed':
        await this.handlePaymentFailed(event.data.object as Stripe.Invoice);
        break;
    }
  }
  
  private async handleCheckoutCompleted(session: Stripe.Checkout.Session): Promise<void> {
    const { userId, planId } = session.metadata!;
    
    await this.db.updateUserSubscription(userId, {
      planId,
      stripeCustomerId: session.customer as string,
      stripeSubscriptionId: session.subscription as string,
      status: 'active',
      currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
    });
    
    // Send welcome email
    await this.emailService.sendSubscriptionWelcome(userId, planId);
    
    // Track conversion
    await this.analytics.track('subscription_created', {
      userId,
      planId,
      amount: session.amount_total! / 100
    });
  }
}
```

### 14.3 Usage Enforcement

```typescript
class UsageEnforcement {
  async checkLimit(userId: string, action: string): Promise<boolean> {
    const subscription = await this.db.getUserSubscription(userId);
    const plan = SUBSCRIPTION_PLANS.find(p => p.id === subscription.planId);
    if (!plan) return false;
    
    const usage = await this.getUsageToday(userId);
    
    switch (action) {
      case 'capture_context':
        if (plan.limits.maxContextsPerDay === -1) return true;
        return usage.captureCount < plan.limits.maxContextsPerDay;
        
      case 'ai_query':
        if (plan.features.aiQueriesPerDay === -1) return true;
        return usage.aiQueryCount < plan.features.aiQueriesPerDay;
        
      case 'share_context':
        if (plan.limits.maxSharedContexts === -1) return true;
        return usage.sharedContextCount < plan.limits.maxSharedContexts;
        
      default:
        return true;
    }
  }
  
  async incrementUsage(userId: string, action: string): Promise<void> {
    await-- Subscriptions table
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID,
  team_id UUID,
  stripe_subscription_id VARCHAR(255) UNIQUE,
  plan VARCHAR(50) NOT NULL,
  status VARCHAR(50) NOT NULL,
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  cancel_at_period_end BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE
);

-- Analytics aggregations table
CREATE TABLE analytics_aggregations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  date DATE NOT NULL,
  total_work_time INTEGER DEFAULT 0,
  deep_work_time INTEGER DEFAULT 0,
  fragmented_time INTEGER DEFAULT 0,
  context_switches INTEGER DEFAULT 0,
  focus_score INTEGER DEFAULT 0,
  metrics JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE(user_id, date)
);

CREATE INDEX idx_analytics_user_date ON analytics_aggregations(user_id, date);

-- API usage tracking
CREATE TABLE api_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  endpoint VARCHAR(255) NOT NULL,
  method VARCHAR(10) NOT NULL,
  status_code INTEGER,
  response_time INTEGER,
  timestamp TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_api_usage_user_id ON api_usage(user_id);
CREATE INDEX idx_api_usage_timestamp ON api_usage(timestamp);
```

### 8.3 Data Access Layer

```typescript
class DatabaseService {
  private sqlite: Database;
  private postgres: Pool;
  
  constructor() {
    this.sqlite = new Database(path.join(app.getPath('userData'), 'flowvault.db'));
    this.initializeSQLite();
  }
  
  private async initializeSQLite(): Promise<void> {
    // Run migrations
    await this.sqlite.exec(SQLITE_SCHEMA);
    
    // Enable WAL mode for better concurrency
    await this.sqlite.exec('PRAGMA journal_mode=WAL');
    
    // Enable foreign keys
    await this.sqlite.exec('PRAGMA foreign_keys=ON');
  }
  
  // Context operations
  async saveContext(context: Context): Promise<void> {
    const stmt = this.sqlite.prepare(`
      INSERT INTO contexts (
        id, user_id, timestamp, title, ai_summary, type, tags,
        project_id, branch, commit_hash, focus_depth, 
        interruption_count, duration, parent_context_id,
        related_context_ids, sync_status, excluded_paths,
        redacted_content, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    await stmt.run(
      context.id,
      context.userId,
      context.timestamp,
      context.title,
      context.aiSummary,
      context.type,
      JSON.stringify(context.tags),
      context.projectId,
      context.branch,
      context.commitHash,
      context.focusDepth,
      context.interruptionCount,
      context.duration,
      context.parentContextId,
      JSON.stringify(context.relatedContextIds),
      context.syncStatus,
      JSON.stringify(context.excludedPaths),
      context.redactedContent ? 1 : 0,
      Date.now(),
      Date.now()
    );
    
    // Save related data
    await this.saveFiles(context.id, context.files);
    await this.saveBrowserTabs(context.id, context.browserTabs);
    await this.saveTerminalSessions(context.id, context.terminalSessions);
    await this.saveIDEState(context.id, context.ideState);
  }
  
  async getContext(contextId: string): Promise<Context | null> {
    const contextRow = await this.sqlite.get(
      'SELECT * FROM contexts WHERE id = ?',
      contextId
    );
    
    if (!contextRow) return null;
    
    // Load related data
    const [files, browserTabs, terminalSessions, ideState] = await Promise.all([
      this.getFiles(contextId),
      this.getBrowserTabs(contextId),
      this.getTerminalSessions(contextId),
      this.getIDEState(contextId)
    ]);
    
    return this.mapToContext(contextRow, {
      files,
      browserTabs,
      terminalSessions,
      ideState
    });
  }
  
  async searchContexts(
    query: string,
    filters?: SearchFilters
  ): Promise<Context[]> {
    let sql = `
      SELECT * FROM contexts
      WHERE user_id = ?
      AND (
        title LIKE ? OR
        ai_summary LIKE ? OR
        tags LIKE ?
      )
    `;
    
    const params: any[] = [
      filters?.userId || this.currentUserId,
      `%${query}%`,
      `%${query}%`,
      `%${query}%`
    ];
    
    if (filters?.projectId) {
      sql += ' AND project_id = ?';
      params.push(filters.projectId);
    }
    
    if (filters?.startDate) {
      sql += ' AND timestamp >= ?';
      params.push(filters.startDate);
    }
    
    if (filters?.endDate) {
      sql += ' AND timestamp <= ?';
      params.push(filters.endDate);
    }
    
    sql += ' ORDER BY timestamp DESC LIMIT ?';
    params.push(filters?.limit || 50);
    
    const rows = await this.sqlite.all(sql, ...params);
    
    return Promise.all(
      rows.map(row => this.getContext(row.id))
    );
  }
  
  // Batch operations for performance
  async saveFiles(contextId: string, files: FileCaptureResult[]): Promise<void> {
    const stmt = this.sqlite.prepare(`
      INSERT INTO files (
        id, context_id, path, content, content_hash, excerpt,
        language, cursor_line, cursor_column, selections,
        scroll_position, folds, breakpoints, bookmarks,
        file_size, last_modified, git_branch, git_changes,
        git_staged, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    const insert = this.sqlite.transaction((files: FileCaptureResult[]) => {
      for (const file of files) {
        stmt.run(
          generateUUID(),
          contextId,
          file.path,
          file.content,
          file.contentHash,
          file.excerpt,
          file.language,
          file.cursorPosition.line,
          file.cursorPosition.column,
          JSON.stringify(file.selections),
          file.scrollPosition,
          JSON.stringify(file.folds),
          JSON.stringify(file.breakpoints),
          JSON.stringify(file.bookmarks),
          file.fileSize,
          file.lastModified,
          file.gitStatus?.branch,
          file.gitStatus?.changes,
          file.gitStatus?.staged ? 1 : 0,
          Date.now()
        );
      }
    });
    
    insert(files);
  }
}
```

---

## 9. API Specifications {#api-specifications}

### 9.1 REST API Endpoints

```typescript
// Base URL: https://api.flowvault.com/v1

interface APIEndpoints {
  // Authentication
  'POST /auth/register': {
    request: { email: string; password: string; name: string };
    response: { userId: string; token: string };
  };
  
  'POST /auth/login': {
    request: { email: string; password: string };
    response: { userId: string; token: string; refreshToken: string };
  };
  
  'POST /auth/refresh': {
    request: { refreshToken: string };
    response: { token: string };
  };
  
  // Contexts
  'POST /contexts': {
    request: { context: Context };
    response: { contextId: string };
  };
  
  'GET /contexts/:id': {
    response: { context: Context };
  };
  
  'GET /contexts': {
    query: { 
      limit?: number; 
      offset?: number;
      projectId?: string;
      startDate?: number;
      endDate?: number;
    };
    response: { contexts: Context[]; total: number };
  };
  
  'PUT /contexts/:id': {
    request: { context: Partial<Context> };
    response: { success: boolean };
  };
  
  'DELETE /contexts/:id': {
    response: { success: boolean };
  };
  
  // Context Search
  'POST /contexts/search': {
    request: { 
      query: string; 
      filters?: SearchFilters;
      semantic?: boolean;
    };
    response: { results: SearchResult[] };
  };
  
  // Context Sharing
  'POST /contexts/:id/share': {
    request: { 
      shareWith: string[];
      shareType: 'view' | 'clone' | 'collaborate';
      expiresAt?: number;
    };
    response: { shareUrl: string; shareId: string };
  };
  
  'GET /contexts/shared/:shareId': {
    response: { context: Context; share: SharedContext };
  };
  
  'POST /contexts/shared/:shareId/access': {
    response: { success: boolean };
  };
  
  // AI
  'POST /ai/chat': {
    request: { 
      message: string; 
      contextId?: string;
      conversationId?: string;
    };
    response: { 
      response: string; 
      conversationId: string;
    };
  };
  
  'POST /ai/summarize': {
    request: { contextId: string };
    response: { summary: string };
  };
  
  'POST /ai/suggest': {
    request: { contextId: string };
    response: { suggestions: string[] };
  };
  
  // Analytics
  'GET /analytics/insights': {
    query: { 
      startDate: number; 
      endDate: number;
      granularity?: 'day' | 'week' | 'month';
    };
    response: { insights: ProductivityInsights };
  };
  
  'GET /analytics/trends': {
    query: { period: 'week' | 'month' | 'quarter' };
    response: { trends: TrendData };
  };
  
  // Sync
  'POST /sync/contexts': {
    request: { contexts: Context[] };
    response: { synced: string[]; failed: string[] };
  };
  
  'GET /sync/status': {
    response: { 
      lastSyncTime: number;
      pendingCount: number;
      status: 'synced' | 'pending' | 'error';
    };
  };
  
  // Teams
  'POST /teams': {
    request: { name: string };
    response: { teamId: string };
  };
  
  'POST /teams/:id/members': {
    request: { userIds: string[]; role: 'admin' | 'member' };
    response: { success: boolean };
  };
  
  'GET /teams/:id/contexts': {
    query: { limit?: number; offset?: number };
    response: { contexts: Context[]; total: number };
  };
  
  // Subscriptions
  'POST /subscriptions/checkout': {
    request: { plan: 'pro' | 'team'; interval: 'month' | 'year' };
    response: { checkoutUrl: string };
  };
  
  'POST /subscriptions/portal': {
    response: { portalUrl: string };
  };
  
  'GET /subscriptions/current': {
    response: { subscription: Subscription };
  };
}
```

### 9.2 WebSocket Events

```typescript
// WebSocket URL: wss://ws.flowvault.com

interface WebSocketEvents {
  // Client â†’ Server
  'context:capture': { context: Context };
  'context:update': { contextId: string; updates: Partial<Context> };
  'sync:request': { since: number };
  
  // Server â†’ Client
  'context:captured': { context: Context };
  'context:updated': { contextId: string; updates: Partial<Context> };
  'sync:completed': { contexts: Context[] };
  'sync:error': { error: string };
  
  // Collaboration
  'collab:start': { session: CollaborationSession };
  'collab:join': { sessionId: string; participant: Participant };
  'collab:leave': { sessionId: string; userId: string };
  'collab:cursor': { sessionId: string; userId: string; position: CursorPosition };
  'collab:activity': { sessionId: string; userId: string; activity: Activity };
  'collab:chat': { sessionId: string; message: ChatMessage };
  
  // Real-time notifications
  'notification:new': { notification: Notification };
  'notification:read': { notificationId: string };
}
```

### 9.3 Rate Limiting

```typescript
const rateLimits = {
  free: {
    'POST /contexts': { limit: 100, window: '1h' },
    'POST /ai/chat': { limit: 50, window: '1d' },
    'POST /contexts/search': { limit: 200, window: '1h' },
    'GET *': { limit: 1000, window: '1h' }
  },
  pro: {
    'POST /contexts': { limit: 500, window: '1h' },
    'POST /ai/chat': { limit: 500, window: '1d' },
    'POST /contexts/search': { limit: 1000, window: '1h' },
    'GET *': { limit: 5000, window: '1h' }
  },
  team: {
    'POST /contexts': { limit: 2000, window: '1h' },
    'POST /ai/chat': { limit: 2000, window: '1d' },
    'POST /contexts/search': { limit: 5000, window: '1h' },
    'GET *': { limit: 20000, window: '1h' }
  }
};
```

---

## 10. Security & Privacy {#security-privacy}

### 10.1 Data Encryption

```typescript
class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private keyDerivation = 'pbkdf2';
  
  // Encrypt sensitive data before storage
  async encrypt(data: string, password: string): Promise<EncryptedData> {
    const salt = crypto.randomBytes(32);
    const key = await this.deriveKey(password, salt);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipheriv(this.algorithm, key, iv);
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      salt: salt.toString('hex'),
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }
  
  async decrypt(encryptedData: EncryptedData, password: string): Promise<string> {
    const key = await this.deriveKey(
      password,
      Buffer.from(encryptedData.salt, 'hex')
    );
    
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      key,
      Buffer.from(encryptedData.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  
  private async deriveKey(password: string, salt: Buffer): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      crypto.pbkdf2(password, salt, 100000, 32, 'sha256', (err, key) => {
        if (err) reject(err);
        else resolve(key);
      });
    });
  }
}
```

### 10.2 Privacy Controls

```typescript
interface PrivacySettings {
  encryptLocalData: boolean;
  encryptSyncedData: boolean;
  excludePatterns: string[]; // File patterns to exclude
  redactPatterns: string[]; // Patterns to redact (API keys, passwords)
  excludeApplications: string[]; // Apps to exclude from capture
  excludeUrls: string[]; // URL patterns to exclude
  anonymizeScreenshots: boolean;
  retentionPeriod: number; // Days to keep data
  allowTelemetry: boolean;
  shareUsageData: boolean;
}

class PrivacyService {
  async applyPrivacySettings(
    context: Context,
    settings: PrivacySettings
  ): Promise<Context> {
    const sanitizedContext = { ...context };
    
    // Filter files by exclude patterns
    sanitizedContext.files = context.files.filter(file => 
      !this.matchesExcludePattern(file.path, settings.excludePatterns)
    );
    
    // Redact sensitive content
    for (const file of sanitizedContext.files) {
      file.content = await this.redactSensitiveContent(
        file.content,
        settings.redactPatterns
      );
    }
    
    // Filter browser tabs
    sanitizedContext.browserTabs = context.browserTabs.filter(tab =>
      !this.matchesExcludePattern(tab.url, settings.excludeUrls)
    );
    
    // Redact terminal history
    for (const session of sanitizedContext.terminalSessions) {
      session.history = session.history.map(cmd =>
        this.redactCommand(cmd, settings.redactPatterns)
      );
      session.environmentVariables = this.filterEnvVars(
        session.environmentVariables
      );
    }
    
    // Anonymize screenshots if enabled
    if (settings.anonymizeScreenshots) {
      sanitizedContext.screenshots = await this.anonymizeScreenshots(
        context.screenshots
      );
    }
    
    return sanitizedContext;
  }
  
  private async redactSensitiveContent(
    content: string,
    patterns: string[]
  ): Promise<string> {
    let redacted = content;
    
    // Common patterns
    const sensitivePatterns = [
      /api[_-]?key[:\s=]+['"]?([a-zA-Z0-9_-]+)['"]?/gi,
      /password[:\s=]+['"]?([^\s'"]+)['"]?/gi,
      /token[:\s=]+['"]?([a-zA-Z0-9._-]+)['"]?/gi,
      /secret[:\s=]+['"]?([a-zA-Z0-9_-]+)['"]?/gi,
      ...patterns.map(p => new RegExp(p, 'gi'))
    ];
    
    for (const pattern of sensitivePatterns) {
      redacted = redacted.replace(pattern, (match) => {
        return match.replace(/[a-zA-Z0-9]/g, '*');
      });
    }
    
    return redacted;
  }
  
  private filterEnvVars(
    envVars: Record<string, string>
  ): Record<string, string> {
    const filtered: Record<string, string> = {};
    const allowedVars = ['PATH', 'HOME', 'USER', 'SHELL', 'LANG'];
    
    for (const [key, value] of Object.entries(envVars)) {
      if (allowedVars.includes(key) || !this.isSensitiveEnvVar(key)) {
        filtered[key] = value;
      }
    }
    
    return filtered;
  }
  
  private isSensitiveEnvVar(key: string): boolean {
    const sensitiveKeywords = [
      'KEY',
      'SECRET',
      'TOKEN',
      'PASSWORD',
      'CREDENTIAL',
      'AUTH'
    ];
    
    return sensitiveKeywords.some(keyword => 
      key.toUpperCase().includes(keyword)
    );
  }
}
```

### 10.3 Authentication & Authorization

```typescript
class AuthService {
  async authenticate(email: string, password: string): Promise<AuthResult> {
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Verify credentials
    const user = await this.db.getUserByEmail(email);
    if (!user || !await bcrypt.compare(password, user.passwordHash)) {
      throw new Error('Invalid credentials');
    }
    
    // Generate tokens
    const accessToken = this.generateAccessToken(user.id);
    const refreshToken = this.generateRefreshToken(user.id);
    
    // Store refresh token
    await this.storeRefreshToken(user.id, refreshToken);
    
    return {
      userId: user.id,
      accessToken,
      refreshToken,
      expiresIn: 3600 // 1 hour
    };
  }
  
  private generateAccessToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'access' },
      process.env.JWT_SECRET!,
      { expiresIn: '1h' }
    );
  }
  
  private generateRefreshToken(userId: string): string {
    return jwt.sign(
      { userId, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET!,
      { expiresIn: '30d' }
    );
  }
  
  async verifyToken(token: string): Promise<TokenPayload> {
    try {
      const payload = jwt.verify(token, process.env.JWT_SECRET!) as TokenPayload;
      return payload;
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
}

// Middleware for protected routes
const requireAuth = async (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const payload = await authService.verifyToken(token);
    req.userId = payload.userId;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};
```

---

## 11. Performance Requirements {#performance-requirements}

### 11.1 Performance Targets

```typescript
interface PerformanceTargets {
  // Capture performance
  contextCaptureTime: {
    p50: 2000,      // 2 seconds
    p95: 5000,      // 5 seconds
    p99: 10000      // 10 seconds
  };
  
  // Restoration performance
  contextRestoreTime: {
    p50: 3000,      // 3 seconds
    p95: 8000,      // 8 seconds
    p99: 15000      // 15 seconds
  };
  
  // UI responsiveness
  uiInteraction: {
    p50: 50,        // 50ms
    p95: 100,       // 100ms
    p99: 200        // 200ms
  };
  
  // Search performance
  searchLatency: {
    p50: 200,       // 200ms
    p95: 500,       // 500ms
    p99: 1000       // 1 second
  };
  
  // AI response time
  aiResponseTime: {
    firstToken: 500,    // 500ms to first token
    p50: 2000,          // 2 seconds total
    p95: 5000           // 5 seconds total
  };
  
  // Memory usage
  memoryUsage: {
    idle: 200,          // 200MB idle
    active: 500,        // 500MB active capture
    max: 1000           // 1GB maximum
  };
  
  // CPU usage
  cpuUsage: {
    idle: 5,            // 5% idle
    active: 30,         // 30% during capture
    max: 80             // 80% maximum
  };
  
  // Startup time
  startupTime: {
    cold: 3000,         // 3 seconds cold start
    warm: 1000          // 1 second warm start
  };
}
```

### 11.2 Performance Monitoring

```typescript
class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetric> = new Map();
  
  startMeasure(label: string): void {
    this.metrics.set(label, {
      label,
      startTime: performance.now(),
      endTime: 0,
      duration: 0
    });
  }
  
  endMeasure(label: string): number {
    const metric = this.metrics.get(label);
    if (!metric) return 0;
    
    metric.endTime = performance.now();
    metric.duration = metric.endTime - metric.startTime;
    
    // Log to analytics
    this.analytics.track('performance_metric', {
      label,
      duration: metric.duration,
      timestamp: Date.now()
    });
    
    // Alert if exceeds threshold
    if (this.exceedsThreshold(label, metric.duration)) {
      this.alertSlowPerformance(label, metric.duration);
    }
    
    return metric.duration;
  }
  
  private exceedsThreshold(label: string, duration: number): boolean {
    const thresholds: Record<string, number> = {
      'context_capture': 10000,
      'context_restore': 15000,
      'ui_interaction': 200,
      'search': 1000,
      'ai_response': 5000
    };
    
    return duration > (thresholds[label] || 5000);
  }
  
  async getPerformanceReport(): Promise<PerformanceReport> {
    const metrics = Array.from(this.metrics.values());
    
    return {
      captureTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'context_capture')
      ),
      restoreTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'context_restore')
      ),
      searchTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'search')
      ),
      aiResponseTime: this.calculatePercentiles(
        metrics.filter(m => m.label === 'ai_response')
      ),
      memoryUsage: await this.getMemoryUsage(),
      cpuUsage: await this.getCPUUsage()
    };
  }
  
  private calculatePercentiles(metrics: PerformanceMetric[]): Percentiles {
    const durations = metrics.map(m => m.duration).sort((a, b) => a - b);
    
    return {
      p50: durations[Math.floor(durations.length * 0.5)],
      p95: durations[Math.floor(durations.length * 0.95)],
      p99: durations[Math.floor(durations.length * 0.99)]
    };
  }
}
```

### 11.3 Optimization Strategies

```typescript
class OptimizationService {
  // Lazy loading for heavy components
  async lazyLoadComponent(componentName: string): Promise<React.ComponentType> {
    return import(`./components/${componentName}`).then(m => m.default);
  }
  
  // Debounce expensive operations
  debouncedCapture = debounce(async () => {
    await this.captureContext();
  }, 5000);
  
  // Throttle high-frequency events
  throttledSync = throttle(async () => {
    await this.syncService.sync();
  }, 10000);
  
  // Memoize expensive computations
  @memoize
  async calculateInsights(userId: string, timeRange: TimeRange): Promise<ProductivityInsights> {
    // Expensive calculation
    return await this.analytics.generateInsights(userId, timeRange);
  }
  
  // Virtual scrolling for long lists
  renderContextList(contexts: Context[]): JSX.Element {
    return (
      <VirtualList
        height={600}
        itemCount={contexts.length}
        itemSize={120}
        renderItem={(index) => (
          <ContextCard context={contexts[index]} />
        )}
      />
    );
  }
  
  // Web Workers for heavy computations
  async processInWorker<T>(data: any): Promise<T> {
    return new Promise((resolve, reject) => {
      const worker = new Worker('./worker.js');
      
      worker.postMessage(data);
      
      worker.onmessage = (e) => {
        resolve(e.data);
        worker.terminate();
      };
      
      worker.onerror = (e) => {
        reject(e);
        worker.terminate();
      };
    });
  }
  
  // IndexedDB for large datasets
  async cacheToIndexedDB(key: string, data: any): Promise<void> {
    const db = await this.openIndexedDB();
    const tx = db.transaction('cache', 'readwrite');
    await tx.objectStore('cache').put({ key, data, timestamp: Date.now() });
  }
  
  async getFromIndexedDB(key: string): Promise<any> {
    const db = await this.openIndexedDB();
    const tx = db.transaction('cache', 'readonly');
    const result = await tx.objectStore('cache').get(key);
    return result?.data;
  }
}
```

---

## 12. Integration Requirements {#integration-requirements}

### 12.1 IDE Integrations

**VS Code Extension:**
```typescript
// VS Code Extension API
import * as vscode from 'vscode';

export class FlowVaultExtension {
  private statusBarItem: vscode.StatusBarItem;
  
  async activate(context: vscode.ExtensionContext) {
    // Register commands
    context.subscriptions.push(
      vscode.commands.registerCommand('flowvault.captureContext', () => {
        this.captureContext();
      })
    );
    
    // Create status bar item
    this.statusBarItem = vscode.window.createStatusBarItem(
      vscode.StatusBarAlignment.Right,
      100
    );
    this.statusBarItem.text = '$(database) FlowVault';
    this.statusBarItem.command = 'flowvault.showMenu';
    this.statusBarItem.show();
    
    // Listen for file changes# FlowVault - Product Requirements Document (PRD)
## AI-Powered Developer Context Preservation System

**Version:** 1.0  
**Last Updated:** October 26, 2025  
**Document Owner:** Product Team  
**Status:** Ready for Development

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Product Overview](#product-overview)
3. [Technical Architecture](#technical-architecture)
4. [Electron Application Specifications](#electron-application-specifications)
5. [UI/UX Design System (Cluely-Inspired)](#uiux-design-system)
6. [Core Features - Detailed Specifications](#core-features)
7. [Advanced Features](#advanced-features)
8. [Data Models & Database Schema](#data-models)
9. [API Specifications](#api-specifications)
10. [Security & Privacy](#security-privacy)
11. [Performance Requirements](#performance-requirements)
12. [Integration Requirements](#integration-requirements)
13. [Analytics & Telemetry](#analytics-telemetry)
14. [Monetization Implementation](#monetization-implementation)
15. [Development Roadmap](#development-roadmap)

---

## 1. Executive Summary {#executive-summary}

FlowVault is an Electron-based desktop application that solves the $1.4 trillion context-switching problem in software development. It automatically captures, preserves, and restores complete developer working contexts, enabling instant recovery of flow states after interruptions.

**Key Metrics:**
- Target: 250,000 users in Year 1
- ARR Goal: $105M at 5% market penetration
- Technical Goal: <100ms context restoration latency
- Engagement Goal: 80% DAU/MAU ratio

---

## 2. Product Overview {#product-overview}

### 2.1 Product Vision

Create the world's first cognitive infrastructure for developers that eliminates context loss, enabling continuous flow states and 10x productivity improvements.

### 2.2 Core Value Propositions

1. **Instant Context Recovery**: Restore complete working state in <5 seconds
2. **Zero Mental Load**: Never worry about losing your place
3. **Team Knowledge Sharing**: Transfer context between team members effortlessly
4. **Focus Protection**: Intelligent interruption filtering
5. **Productivity Intelligence**: Data-driven insights into work patterns

### 2.3 Target Users

**Primary:**
- Senior Software Engineers (5+ years experience)
- Full-stack Developers working across multiple codebases
- Tech Leads managing multiple projects
- DevOps Engineers handling incidents

**Secondary:**
- Junior Developers (onboarding use case)
- Product Managers (understanding technical context)
- Engineering Managers (team productivity insights)

### 2.4 Success Metrics

**Adoption Metrics:**
- Daily Active Users (DAU): 80% of registered users
- Weekly Active Users (WAU): 95% of registered users
- Context Captures per User per Day: 15-25
- Context Restorations per User per Day: 8-15

**Engagement Metrics:**
- Average Session Duration: 6+ hours (running in background)
- Feature Usage Rate: 70% of users use 5+ features weekly
- Retention: 90% Week-1, 75% Month-1, 60% Month-6

**Business Metrics:**
- Free-to-Paid Conversion: 15% within 30 days
- Team Expansion Rate: 40% of Pro users upgrade to Team within 90 days
- Net Revenue Retention: 120% annually
- Customer Acquisition Cost (CAC): <$50
- Lifetime Value (LTV): >$2,000

---

## 3. Technical Architecture {#technical-architecture}

### 3.1 Overall System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FlowVault Electron App                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Overlay    â”‚  â”‚   Main UI    â”‚  â”‚  Background  â”‚      â”‚
â”‚  â”‚   Window     â”‚  â”‚   Window     â”‚  â”‚   Services   â”‚      â”‚
â”‚  â”‚  (Frameless) â”‚  â”‚  (Standard)  â”‚  â”‚  (Node.js)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚           IPC Communication Layer                    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Context    â”‚  â”‚     AI       â”‚  â”‚   Plugin     â”‚      â”‚
â”‚  â”‚   Capture    â”‚  â”‚   Engine     â”‚  â”‚   System     â”‚      â”‚
â”‚  â”‚   Engine     â”‚  â”‚              â”‚  â”‚              â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   Local DB   â”‚  â”‚   File       â”‚  â”‚   Cache      â”‚      â”‚
â”‚  â”‚  (SQLite)    â”‚  â”‚   System     â”‚  â”‚   Layer      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ HTTPS/WebSocket
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Backend Services (Cloud)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   API        â”‚  â”‚   AI         â”‚  â”‚   Sync       â”‚      â”‚
â”‚  â”‚   Gateway    â”‚  â”‚   Service    â”‚  â”‚   Service    â”‚      â”‚
â”‚  â”‚  (Node.js)   â”‚  â”‚  (Python)    â”‚  â”‚  (Node.js)   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  PostgreSQL  â”‚  â”‚   Redis      â”‚  â”‚  S3/Object   â”‚      â”‚
â”‚  â”‚  (Primary)   â”‚  â”‚   Cache      â”‚  â”‚   Storage    â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  Analytics   â”‚  â”‚   Queue      â”‚  â”‚   Search     â”‚      â”‚
â”‚  â”‚  (ClickHouse)â”‚  â”‚  (RabbitMQ)  â”‚  â”‚(Elasticsearch)â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Technology Stack

**Electron Application:**
- **Framework**: Electron 28.x (latest stable)
- **Renderer**: React 18.x with TypeScript 5.x
- **State Management**: Zustand + React Query
- **Styling**: Tailwind CSS 3.x + Framer Motion
- **Build Tool**: Vite 5.x
- **Testing**: Vitest + Playwright

**Backend Services:**
- **API Gateway**: Node.js 20.x + Express.js + tRPC
- **AI Service**: Python 3.11 + FastAPI + LangChain
- **Database**: PostgreSQL 16 (primary) + SQLite (local)
- **Cache**: Redis 7.x
- **Message Queue**: RabbitMQ 3.12
- **Search**: Elasticsearch 8.x
- **Object Storage**: AWS S3 / MinIO (self-hosted option)
- **Analytics**: ClickHouse 23.x

**AI/ML Stack:**
- **LLM Provider**: OpenAI GPT-4 Turbo (primary), Anthropic Claude (fallback)
- **Embeddings**: OpenAI text-embedding-3-large
- **Vector Database**: Pinecone / Weaviate
- **Local LLM**: Ollama (for offline mode)

**Infrastructure:**
- **Container Orchestration**: Kubernetes (AWS EKS / GCP GKE)
- **CI/CD**: GitHub Actions
- **Monitoring**: Datadog / Prometheus + Grafana
- **Error Tracking**: Sentry
- **CDN**: CloudFlare

### 3.3 Electron Architecture (Detailed)

#### 3.3.1 Multi-Window Architecture

**Main Window (Standard BrowserWindow):**
```typescript
// Specifications
{
  width: 1400,
  height: 900,
  minWidth: 1200,
  minHeight: 700,
  frame: true,
  titleBarStyle: 'hiddenInset', // macOS
  backgroundColor: '#0A0A0B',
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true,
    preload: path.join(__dirname, 'preload.js'),
    webSecurity: true
  }
}
```

**Overlay Window (Frameless BrowserWindow):**
```typescript
// Specifications for always-on-top overlay
{
  width: 400,
  height: 600,
  frame: false,
  transparent: true,
  alwaysOnTop: true,
  skipTaskbar: true,
  resizable: false,
  movable: true,
  hasShadow: false,
  type: 'panel', // macOS, toolbar on Windows
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true,
    preload: path.join(__dirname, 'overlay-preload.js')
  }
}
```

**Mini Widget (System Tray Extension):**
```typescript
// Compact widget for quick actions
{
  width: 320,
  height: 480,
  frame: false,
  transparent: true,
  alwaysOnTop: true,
  skipTaskbar: true,
  show: false, // shown on tray click
  webPreferences: {
    nodeIntegration: false,
    contextIsolation: true
  }
}
```

#### 3.3.2 IPC Communication Architecture

**Bidirectional IPC Channels:**

```typescript
// Main Process â†’ Renderer
enum MainToRendererChannels {
  CONTEXT_CAPTURED = 'context:captured',
  CONTEXT_UPDATED = 'context:updated',
  AI_RESPONSE = 'ai:response',
  SYNC_STATUS = 'sync:status',
  NOTIFICATION = 'notification:show',
  FOCUS_CHANGE = 'focus:changed',
  PLUGIN_EVENT = 'plugin:event'
}

// Renderer â†’ Main Process
enum RendererToMainChannels {
  CAPTURE_CONTEXT = 'context:capture',
  RESTORE_CONTEXT = 'context:restore',
  AI_QUERY = 'ai:query',
  OPEN_FILE = 'file:open',
  SYNC_REQUEST = 'sync:request',
  SETTINGS_UPDATE = 'settings:update'
}

// IPC Implementation with type safety
interface IPCInvokeHandlers {
  'context:capture': (options: CaptureOptions) => Promise<Context>;
  'context:restore': (contextId: string) => Promise<void>;
  'context:list': (filters: ContextFilters) => Promise<Context[]>;
  'ai:query': (query: string, contextId?: string) => Promise<AIResponse>;
  'settings:get': () => Promise<Settings>;
  'settings:update': (settings: Partial<Settings>) => Promise<void>;
  'file:read': (path: string) => Promise<string>;
  'plugin:execute': (pluginId: string, action: string, params: any) => Promise<any>;
}
```

#### 3.3.3 Process Architecture

**Main Process Responsibilities:**
- Window lifecycle management
- Native OS integration (file system, notifications, shortcuts)
- SQLite database operations
- Background services coordination
- IPC orchestration
- Auto-updater management
- System tray management

**Renderer Process Responsibilities:**
- UI rendering and user interactions
- State management (Zustand stores)
- Real-time data updates (WebSocket)
- Client-side routing
- Form validation
- Local caching (IndexedDB)

**Worker Processes (via fork):**
- Context capture engine (CPU-intensive)
- AI request processing
- File system monitoring
- Screenshot/screen recording
- Data synchronization

### 3.4 Context Capture Engine Architecture

```typescript
class ContextCaptureEngine {
  // Core components
  private fileSystemWatcher: FileSystemWatcher;
  private applicationMonitor: ApplicationMonitor;
  private browserExtensionBridge: BrowserBridge;
  private ideIntegration: IDEIntegration;
  private terminalMonitor: TerminalMonitor;
  private clipboardMonitor: ClipboardMonitor;
  
  // Capture pipeline
  async captureContext(): Promise<Context> {
    // Parallel capture for performance
    const [
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState,
      applicationWindows,
      clipboardHistory,
      screenshots
    ] = await Promise.all([
      this.captureActiveFiles(),
      this.captureBrowserTabs(),
      this.captureTerminalSessions(),
      this.captureIDEState(),
      this.captureApplicationWindows(),
      this.captureClipboardHistory(),
      this.captureScreenshots()
    ]);
    
    // AI-powered context analysis
    const contextSummary = await this.aiAnalyzeContext({
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState
    });
    
    // Assemble complete context
    return {
      id: generateUUID(),
      timestamp: Date.now(),
      activeFiles,
      browserTabs,
      terminalSessions,
      ideState,
      applicationWindows,
      clipboardHistory,
      screenshots,
      aiSummary: contextSummary,
      metadata: this.extractMetadata()
    };
  }
}
```

**File System Capture:**
```typescript
interface FileCaptureResult {
  path: string;
  content: string; // Full content for small files
  contentHash: string; // SHA-256 hash
  excerpt: string; // First/last N lines for large files
  language: string;
  cursorPosition: { line: number; column: number };
  selections: Array<{ start: Position; end: Position }>;
  scrollPosition: number;
  folds: number[]; // Collapsed line numbers
  breakpoints: number[];
  bookmarks: Bookmark[];
  fileSize: number;
  lastModified: number;
  gitStatus?: {
    branch: string;
    changes: number;
    staged: boolean;
  };
}
```

**Browser Tab Capture:**
```typescript
interface BrowserTabCapture {
  url: string;
  title: string;
  favicon: string;
  screenshot?: string; // Base64 thumbnail
  scrollPosition: number;
  formData?: Record<string, string>; // For unsaved forms
  selectedText?: string;
  openTime: number;
  lastActiveTime: number;
  category: 'documentation' | 'stackoverflow' | 'github' | 'other';
  relevanceScore: number; // AI-calculated
}
```

**Terminal Session Capture:**
```typescript
interface TerminalCapture {
  sessionId: string;
  workingDirectory: string;
  history: string[]; // Last 100 commands
  output: string; // Last 1000 lines
  environmentVariables: Record<string, string>;
  activeProcesses: Process[];
  shell: string;
  tabs: TerminalTab[];
}
```

**IDE State Capture:**
```typescript
interface IDEStateCapture {
  type: 'vscode' | 'intellij' | 'pycharm' | 'webstorm' | 'vim' | 'emacs';
  openProjects: Project[];
  workspace: {
    folders: string[];
    settings: Record<string, any>;
  };
  extensions: Extension[];
  debugSessions: DebugSession[];
  runConfigurations: RunConfig[];
  searchHistory: string[];
  recentFiles: string[];
  pinnedFiles: string[];
  splitLayout: SplitLayoutConfig;
  editorGroups: EditorGroup[];
}
```

### 3.5 AI Engine Architecture

```typescript
class AIContextEngine {
  private openai: OpenAI;
  private vectorStore: VectorStore;
  private embeddingCache: Map<string, number[]>;
  
  // Generate context summary
  async generateContextSummary(context: Context): Promise<string> {
    const prompt = this.buildContextPrompt(context);
    
    const completion = await this.openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: `You are an expert software developer analyzing a colleague's working context.
          Generate a concise, actionable summary that captures:
          1. The primary task/problem being worked on
          2. Current progress and approach
          3. Key files and their purposes
          4. Any blockers or questions
          5. Next steps
          
          Format the summary to enable instant context restoration.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 500,
      temperature: 0.3
    });
    
    return completion.choices[0].message.content;
  }
  
  // Semantic context search
  async searchSimilarContexts(query: string, limit: number = 10): Promise<Context[]> {
    // Generate query embedding
    const queryEmbedding = await this.generateEmbedding(query);
    
    // Vector similarity search
    const similarContextIds = await this.vectorStore.search(
      queryEmbedding,
      limit
    );
    
    // Fetch full contexts
    return await this.fetchContextsByIds(similarContextIds);
  }
  
  // AI chat interface
  async chatWithContext(
    message: string,
    contextId: string,
    conversationHistory: ChatMessage[]
  ): Promise<string> {
    const context = await this.fetchContext(contextId);
    
    const systemPrompt = `You are FlowVault's AI assistant with access to the developer's complete working context.
    
    Current Context:
    ${JSON.stringify(context, null, 2)}
    
    Answer questions about this context, help debug issues, suggest next steps, and provide insights.`;
    
    const messages = [
      { role: "system", content: systemPrompt },
      ...conversationHistory,
      { role: "user", content: message }
    ];
    
    const response = await this.openai.chat.completions.create({
      model: "gpt-4-turbo-preview",
      messages,
      max_tokens: 1000,
      temperature: 0.7,
      stream: true // Enable streaming for real-time responses
    });
    
    return this.streamResponse(response);
  }
}
```

### 3.6 Data Synchronization Architecture

**Hybrid Sync Strategy:**
- Local-first with SQLite
- Background sync to cloud
- Conflict resolution using Last-Write-Wins + Vector Clocks
- Differential sync (only changed data)
- Compression for network efficiency

```typescript
class SyncEngine {
  private localDB: SQLiteDB;
  private remoteAPI: APIClient;
  private syncQueue: Queue<SyncOperation>;
  private websocket: WebSocket;
  
  async syncContext(context: Context): Promise<void> {
    // 1. Save locally first (fast)
    await this.localDB.saveContext(context);
    
    // 2. Queue for background sync
    this.syncQueue.add({
      type: 'context:create',
      payload: context,
      priority: 'normal'
    });
    
    // 3. Process sync queue
    await this.processSyncQueue();
  }
  
  private async processSyncQueue(): Promise<void> {
    while (!this.syncQueue.isEmpty()) {
      const operation = this.syncQueue.dequeue();
      
      try {
        // Compress payload
        const compressed = await this.compress(operation.payload);
        
        // Send to backend
        await this.remoteAPI.post('/sync', {
          operation: operation.type,
          data: compressed,
          timestamp: Date.now(),
          deviceId: this.deviceId
        });
        
        // Mark as synced
        await this.localDB.markSynced(operation.id);
      } catch (error) {
        // Retry with exponential backoff
        this.syncQueue.addWithDelay(operation, this.calculateBackoff());
      }
    }
  }
  
  // Real-time sync via WebSocket
  private setupRealtimeSync(): void {
    this.websocket.on('context:updated', async (data) => {
      // Merge remote changes
      await this.mergeRemoteContext(data);
      
      // Notify UI
      this.emit('sync:completed', data);
    });
  }
}
```

### 3.7 Plugin System Architecture

```typescript
interface Plugin {
  id: string;
  name: string;
  version: string;
  author: string;
  description: string;
  
  // Lifecycle hooks
  onActivate(context: PluginContext): Promise<void>;
  onDeactivate(): Promise<void>;
  
  // Event handlers
  onContextCapture?(context: Context): Promise<Context>;
  onContextRestore?(context: Context): Promise<void>;
  onFileOpen?(file: string): Promise<void>;
  
  // Custom commands
  commands?: PluginCommand[];
  
  // UI extensions
  uiExtensions?: {
    sidebar?: React.ComponentType;
    statusBar?: React.ComponentType;
    contextMenu?: MenuItem[];
  };
}

class PluginManager {
  private plugins: Map<string, Plugin>;
  private sandboxes: Map<string, VM>;
  
  async loadPlugin(pluginPath: string): Promise<void> {
    // Create isolated sandbox
    const sandbox = new VM({
      timeout: 5000,
      sandbox: {
        console,
        require: this.createRequireProxy(),
        flowvault: this.createPluginAPI()
      }
    });
    
    // Load and validate plugin
    const plugin = await sandbox.run(
      fs.readFileSync(pluginPath, 'utf8')
    );
    
    // Execute onActivate hook
    await plugin.onActivate(this.createPluginContext());
    
    this.plugins.set(plugin.id, plugin);
    this.sandboxes.set(plugin.id, sandbox);
  }
  
  private createPluginAPI(): PluginAPI {
    return {
      // Safe APIs exposed to plugins
      contexts: {
        getCurrent: () => this.getCurrentContext(),
        list: (filters) => this.listContexts(filters),
        create: (context) => this.createContext(context)
      },
      ui: {
        showNotification: (message) => this.showNotification(message),
        showDialog: (options) => this.showDialog(options)
      },
      storage: {
        get: (key) => this.pluginStorage.get(key),
        set: (key, value) => this.pluginStorage.set(key, value)
      }
    };
  }
}
```

---

## 4. Electron Application Specifications {#electron-application-specifications}

### 4.1 Build Configuration

**electron-builder configuration:**

```json
{
  "appId": "com.flowvault.app",
  "productName": "FlowVault",
  "copyright": "Copyright Â© 2025 FlowVault Inc.",
  "directories": {
    "output": "dist",
    "buildResources": "build"
  },
  "files": [
    "dist-electron/**/*",
    "dist/**/*",
    "package.json"
  ],
  "mac": {
    "category": "public.app-category.developer-tools",
    "target": ["dmg", "zip"],
    "hardenedRuntime": true,
    "gatekeeperAssess": false,
    "entitlements": "build/entitlements.mac.plist",
    "entitlementsInherit": "build/entitlements.mac.plist",
    "icon": "build/icon.icns",
    "minimumSystemVersion": "10.15.0",
    "darkModeSupport": true
  },
  "win": {
    "target": ["nsis", "portable"],
    "icon": "build/icon.ico",
    "publisherName": "FlowVault Inc.",
    "verifyUpdateCodeSignature": true
  },
  "linux": {
    "target": ["AppImage", "deb", "rpm"],
    "category": "Development",
    "icon": "build/icons",
    "maintainer": "support@flowvault.com"
  },
  "nsis": {
    "oneClick": false,
    "allowToChangeInstallationDirectory": true,
    "createDesktopShortcut": true,
    "createStartMenuShortcut": true
  },
  "publish": {
    "provider": "github",
    "owner": "flowvault",
    "repo": "flowvault-app"
  }
}
```

### 4.2 Auto-Update Implementation

```typescript
import { autoUpdater } from 'electron-updater';

class AutoUpdateManager {
  constructor() {
    autoUpdater.autoDownload = false;
    autoUpdater.autoInstallOnAppQuit = true;
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers(): void {
    autoUpdater.on('update-available', (info) => {
      // Notify user
      this.showUpdateNotification(info);
    });
    
    autoUpdater.on('download-progress', (progress) => {
      // Show download progress in UI
      this.updateDownloadProgress(progress);
    });
    
    autoUpdater.on('update-downloaded', () => {
      // Prompt to restart
      this.showRestartDialog();
    });
  }
  
  async checkForUpdates(): Promise<void> {
    await autoUpdater.checkForUpdates();
  }
  
  async downloadUpdate(): Promise<void> {
    await autoUpdater.downloadUpdate();
  }
  
  quitAndInstall(): void {
    autoUpdater.quitAndInstall(false, true);
  }
}
```

### 4.3 Native OS Integration

**macOS:**
```typescript
// Touch Bar support
const { TouchBar } = require('electron');

const touchBar = new TouchBar({
  items: [
    new TouchBar.TouchBarButton({
      label: 'ðŸ“¸ Capture',
      click: () => this.captureContext()
    }),
    new TouchBar.TouchBarButton({
      label: 'ðŸ”„ Restore',
      click: () => this.showRestoreMenu()
    }),
    new TouchBar.TouchBarSpacer({ size: 'flexible' }),
    new TouchBar.TouchBarButton({
      label: 'ðŸ¤– AI Chat',
      click: () => this.openAIChat()
    })
  ]
});

mainWindow.setTouchBar(touchBar);

// Menu bar integration
const { Tray } = require('electron');

const tray = new Tray('icon-template.png');
tray.setToolTip('FlowVault');
tray.on('click', () => {
  this.toggleOverlay();
});
```

**Windows:**
```typescript
// Jump list
app.setUserTasks([
  {
    program: process.execPath,
    arguments: '--capture',
    iconPath: process.execPath,
    iconIndex: 0,
    title: 'Quick Capture',
    description: 'Capture current context'
  },
  {
    program: process.execPath,
    arguments: '--restore',
    iconPath: process.execPath,
    iconIndex: 0,
    title: 'Restore Context',
    description: 'Restore last context'
  }
]);

// Thumbnail toolbar
mainWindow.setThumbarButtons([
  {
    tooltip: 'Capture',
    icon: 'capture-icon.png',
    click() { captureContext(); }
  },
  {
    tooltip: 'AI Chat',
    icon: 'ai-icon.png',
    click() { openAIChat(); }
  }
]);
```

**Linux:**
```typescript
// Desktop notification
const { Notification } = require('electron');

new Notification({
  title: 'Context Captured',
  body: 'Working on authentication bug',
  icon: 'icon.png',
  actions: [
    { type: 'button', text: 'View' },
    { type: 'button', text: 'Restore' }
  ]
}).show();
```

### 4.4 Global Keyboard Shortcuts

```typescript
import { globalShortcut } from 'electron';

class ShortcutManager {
  registerShortcuts(): void {
    // Quick capture
    globalShortcut.register('CommandOrControl+Shift+C', () => {
      this.captureContext();
    });
    
    // Quick restore
    globalShortcut.register('CommandOrControl+Shift+R', () => {
      this.showRestoreMenu();
    });
    
    // Toggle overlay
    globalShortcut.register('CommandOrControl+Shift+O', () => {
      this.toggleOverlay();
    });
    
    // AI chat
    globalShortcut.register('CommandOrControl+Shift+A', () => {
      this.openAIChat();
    });
    
    // Focus mode
    globalShortcut.register('CommandOrControl+Shift+F', () => {
      this.toggleFocusMode();
    });
  }
  
  unregisterAll(): void {
    globalShortcut.unregisterAll();
  }
}
```

### 4.5 Performance Optimizations

**Memory Management:**
```typescript
// Automatic garbage collection
setInterval(() => {
  if (global.gc) {
    global.gc();
  }
}, 60000); // Every minute

// Limit renderer processes memory
app.commandLine.appendSwitch('js-flags', '--max-old-space-size=4096');

// Disable hardware acceleration if GPU issues
if (process.platform === 'linux') {
  app.disableHardwareAcceleration();
}
```

**Lazy Loading:**
```typescript
// Load heavy components on demand
const loadHeavyComponent = () => import('./HeavyComponent');

// Use React.lazy for code splitting
const ContextTimeline = React.lazy(() => import('./ContextTimeline'));
const AIChat = React.lazy(() => import('./AIChat'));
const Analytics = React.lazy(() => import('./Analytics'));
```

**Efficient IPC:**
```typescript
// Batch IPC calls
class IPCBatcher {
  private queue: IPCMessage[] = [];
  private timer: NodeJS.Timeout | null = null;
  private readonly BATCH_INTERVAL = 16; // 60fps
  
  send(channel: string, data: any): void {
    this.queue.push({ channel, data });
    
    if (!this.timer) {
      this.timer = setTimeout(() => {
        this.flush();
      }, this.BATCH_INTERVAL);
    }
  }
  
  private flush(): void {
    if (this.queue.length > 0) {
      ipcRenderer.send('batch', this.queue);
      this.queue = [];
    }
    this.timer = null;
  }
}

// Use MessagePorts for high-frequency communication
const { port1, port2 } = new MessageChannel();
port1.onmessage = (event) => {
  // Handle high-frequency updates
  this.handleRealtimeUpdate(event.data);
};
```

---

## 5. UI/UX Design System (Cluely-Inspired) {#uiux-design-system}

### 5.1 Design Philosophy

**Core Principles:**
1. **Dark-First Design**: Premium dark aesthetic with subtle gradients
2. **Glassmorphism**: Frosted glass effects for depth and hierarchy
3. **Micro-Interactions**: Smooth animations for every interaction
4. **Information Density**: Maximum information with minimal clutter
5. **Accessibility**: WCAG 2.1 AAA compliant

### 5.2 Color Palette

```typescript
const colorSystem = {
  // Base colors (Cluely-inspired)
  background: {
    primary: '#0A0A0B',      // Deep black
    secondary: '#121214',    // Card background
    tertiary: '#1A1A1D',     // Elevated surfaces
    overlay: 'rgba(18, 18, 20, 0.85)', // Glass effect
  },
  
  // Accent colors
  accent: {
    primary: '#6366F1',      // Indigo (primary actions)
    secondary: '#8B5CF6',    // Purple (secondary actions)
    success: '#10B981',      // Green (success states)
    warning: '#F59E0B',      // Amber (warnings)
    error: '#EF4444',        // Red (errors)
    info: '#3B82F6',         // Blue (info)
  },
  
  // Gradient definitions
  gradients: {
    primary: 'linear-gradient(135deg, #6366F1 0%, #8B5CF6 100%)',
    success: 'linear-gradient(135deg, #10B981 0%, #059669 100%)',
    danger: 'linear-gradient(135deg, #EF4444 0%, #DC2626 100%)',
    neural: 'linear-gradient(135deg, #8B5CF6 0%, #EC4899 100%)',
    context: 'linear-gradient(135deg, #3B82F6 0%, #6366F1 100%)',
  },
  
  // Text colors
  text: {
    primary: '#F9FAFB',      // White (headings, important text)
    secondary: '#D1D5DB',    // Light gray (body text)
    tertiary: '#9CA3AF',     // Medium gray (muted text)
    disabled: '#6B7280',     // Dark gray (disabled)
    inverse: '#0A0A0B',      // For light backgrounds
  },
  
  // Border colors
  border: {
    subtle: 'rgba(255, 255, 255, 0.05)',
    default: 'rgba(255, 255, 255, 0.1)',
    strong: 'rgba(255, 255, 255, 0.2)',
    accent: 'rgba(99, 102, 241, 0.3)',
  },
  
  // Status colors
  status: {
    active: '#10B981',
    idle: '#F59E0B',
    offline: '#6B7280',
    syncing: '#3B82F6',
    error: '#EF4444',
  },
  
  // Semantic colors
  semantic: {
    code: '#7C3AED',
    file: '#3B82F6',
    terminal: '#10B981',
    browser: '#F59E0B',
    ai: '#EC4899',
  }
};
```

### 5.3 Typography System

```typescript
const typography = {
  fontFamily: {
    primary: '"Inter", -apple-system, BlinkMacSystemFont, sans-serif',
    mono: '"JetBrains Mono", "Fira Code", monospace',
    display: '"Cal Sans", "Inter", sans-serif', // For hero text
  },
  
  fontSize: {
    xs: '0.75rem',    // 12px
    sm: '0.875rem',   // 14px
    base: '1rem',     // 16px
    lg: '1.125rem',   // 18px
    xl: '1.25rem',    // 20px
    '2xl': '1.5rem',  // 24px
    '3xl': '1.875rem', // 30px
    '4xl': '2.25rem', // 36px
    '5xl': '3rem',    // 48px
  },
  
  fontWeight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
  },
  
  lineHeight: {
    tight: 1.25,
    normal: 1.5,
    relaxed: 1.75,
  },
  
  letterSpacing: {
    tight: '-0.02em',
    normal: '0',
    wide: '0.02em',
  }
};
```

### 5.4 Component Design Specifications

#### 5.4.1 Overlay Window Design

```typescript
// Overlay component structure
interface OverlayProps {
  position: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
  isExpanded: boolean;
  isDragging: boolean;
}

const OverlayWindow: React.FC<OverlayProps> = ({ position, isExpanded }) => {
  return (
    <div className="overlay-container">
      {/* Glass effect background */}
      <div className="glass-backdrop" />
      
      {/* Header with drag handle */}
      <div className="overlay-header">
        <div className="drag-handle">
          <GripVertical size={16} />
        </div>
        <StatusIndicator status="active" />
        <QuickActions />
      </div>
      
      {/* Main content area */}
      <div className="overlay-content">
        {isExpanded ? (
          <ExpandedView />
        ) : (
          <CompactView />
        )}
      </div>
      
      {/* Quick action buttons */}
      <div className="overlay-footer">
        <QuickCaptureButton />
        <AIAssistButton />
        <ContextListButton />
      </div>
    </div>
  );
};
```

**CSS Styles (Tailwind + Custom):**
```css
.overlay-container {
  @apply relative w-full h-full;
  @apply rounded-2xl overflow-hidden;
  @apply shadow-2xl shadow-black/50;
  backdrop-filter: blur(40px) saturate(180%);
  background: rgba(18, 18, 20, 0.85);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.glass-backdrop {
  @apply absolute inset-0 -z-10;
  background: linear-gradient(
    135deg,
    rgba(99, 102, 241, 0.05) 0%,
    rgba(139, 92, 246, 0.05) 100%
  );
}

.overlay-header {
  @apply flex items-center gap-3 p-4;
  @apply border-b border-white/5;
  @apply bg-gradient-to-r from-transparent via-white/[0.02] to-transparent;
}

.drag-handle {
  @apply cursor-move text-gray-500 hover:text-gray-300;
  @apply transition-colors duration-200;
}

.overlay-content {
  @apply p-4 overflow-y-auto;
  @apply scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent;
  max-height: calc(100% - 120px);
}

.overlay-footer {
  @apply absolute bottom-0 left-0 right-0;
  @apply flex items-center justify-around gap-2 p-3;
  @apply border-t border-white/5;
  @apply bg-gradient-to-t from-black/20 to-transparent;
}
```

#### 5.4.2 Context Card Design

```typescript
interface ContextCardProps {
  context: Context;
  isActive: boolean;
  onRestore: () => void;
  onDelete: () => void;
}

const ContextCard: React.FC<ContextCardProps> = ({
  context,
  isActive,
  onRestore,
  onDelete
}) => {
  return (
    <motion.div
      className={`context-card ${isActive ? 'active' : ''}`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, scale: 0.95 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2 }}
    >
      {/* Card header */}
      <div className="card-header">
        <div className="flex items-center gap-3">
          <ContextIcon type={context.type} />
          <div className="flex-1">
            <h3 className="card-title">{context.title}</h3>
            <p className="card-subtitle">
              {formatRelativeTime(context.timestamp)}
            </p>
          </div>
          <ContextBadge status={context.status} />
        </div>
      </div>
      
      {/* AI Summary */}
      <div className="card-summary">
        <AISparkle className="summary-icon" />
        <p className="summary-text">{context.aiSummary}</p>
      </div>
      
      {/* Context metadata */}
      <div className="card-metadata">
        <MetadataItem
          icon={<FileCode />}
          label="Files"
          value={context.fileCount}
        />
        <MetadataItem
          icon={<Globe />}
          label="Tabs"
          value={context.browserTabCount}
        />
        <MetadataItem
          icon={<Terminal />}
          label="Terminal"
          value={context.terminalSessionCount}
        />
      </div>
      
      {/* Action buttons */}
      <div className="card-actions">
        <Button
          variant="primary"
          onClick={onRestore}
          className="flex-1"
        >
          <Play size={16} />
          Restore
        </Button>
        <IconButton
          variant="ghost"
          onClick={onDelete}
          icon={<Trash2 size={16} />}
        />
      </div>
      
      {/* Hover overlay for preview */}
      <div className="card-hover-overlay">
        <PreviewThumbnail context={context} />
      </div>
    </motion.div>
  );
};
```

**Context Card Styles:**
```css
.context-card {
  @apply relative p-5 rounded-xl;
  @apply bg-gradient-to-br from-gray-900/50 to-gray-900/30;
  @apply border border-white/5;
  @apply transition-all duration-300;
  @apply hover:border-indigo-500/30;
  @apply hover:shadow-lg hover:shadow-indigo-500/10;
}

.context-card.active {
  @apply border-indigo-500/50;
  @apply bg-gradient-to-br from-indigo-900/20 to-purple-900/10;
  @apply shadow-xl shadow-indigo-500/20;
}

.card-header {
  @apply mb-4;
}

.card-title {
  @apply text-base font-semibold text-gray-100;
  @apply truncate;
}

.card-subtitle {
  @apply text-sm text-gray-400;
}

.card-summary {
  @apply flex items-start gap-3 mb-4 p-3;
  @apply rounded-lg bg-black/20;
  @apply border border-white/5;
}

.summary-icon {
  @apply flex-shrink-0 text-purple-400;
  animation: pulse-glow 2s ease-in-out infinite;
}

.summary-text {
  @apply text-sm text-gray-300 leading-relaxed;
  @apply line-clamp-3;
}

.card-metadata {
  @apply flex items-center gap-4 mb-4;
  @apply text-sm text-gray-400;
}

.card-actions {
  @apply flex items-center gap-2;
}

.card-hover-overlay {
  @apply absolute inset-0 opacity-0 pointer-events-none;
  @apply transition-opacity duration-300;
  @apply bg-black/90 backdrop-blur-sm;
  @apply rounded-xl overflow-hidden;
}

.context-card:hover .card-hover-overlay {
  @apply opacity-100;
}

@keyframes pulse-glow {
  0%, 100% {
    opacity: 1;
    filter: drop-shadow(0 0 2px currentColor);
  }
  50% {
    opacity: 0.7;
    filter: drop-shadow(0 0 8px currentColor);
  }
}
```

#### 5.4.3 AI Chat Interface

```typescript
const AIChatInterface: React.FC = () => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  
  return (
    <div className="ai-chat-container">
      {/* Chat header */}
      <div className="chat-header">
        <div className="flex items-center gap-3">
          <div className="ai-avatar">
            <Sparkles className="ai-icon" />
          </div>
          <div>
            <h3 className="chat-title">AI Assistant</h3>
            <p className="chat-status">
              <span className="status-dot" />
              Ready to help
            </p>
          </div>
        </div>
        <ContextSelector />
      </div>
      
      {/* Messages area */}
      <div className="chat-messages">
        <AnimatePresence>
          {messages.map((message) => (
            <ChatMessage
              key={message.id}
              message={message}
              isUser={message.role === 'user'}
            />
          ))}
        </AnimatePresence>
        
        {isTyping && <TypingIndicator />}
        
        {/* Suggested prompts */}
        {messages.length === 0 && (
          <SuggestedPrompts onSelect={setInput} />
        )}
      </div>
      
      {/* Input area */}
      <div className="chat-input-container">
        <div className="chat-input-wrapper">
          <TextareaAutosize
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Ask about your context..."
            className="chat-input"
            maxRows={6}
            onKeyDown={handleKeyDown}
          />
          <div className="input-actions">
            <IconButton
              icon={<Paperclip />}
              tooltip="Attach file"
              onClick={handleAttach}
            />
            <Button
              variant="primary"
              size="sm"
              onClick={handleSend}
              disabled={!input.trim()}
            >
              <Send size={16} />
            </Button>
          </div>
        </div>
        
        {/* Token counter */}
        <div className="token-counter">
          <Zap size={12} />
          <span>{tokenCount} / 4000 tokens</span>
        </div>
      </div>
    </div>
  );
};

const ChatMessage: React.FC<{ message: ChatMessage; isUser: boolean }> = ({
  message,
  isUser
}) => {
  return (
    <motion.div
      className={`chat-message ${isUser ? 'user' : 'assistant'}`}
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
    >
      <div className="message-avatar">
        {isUser ? (
          <User size={20} />
        ) : (
          <Sparkles size={20} className="ai-icon-animated" />
        )}
      </div>
      
      <div className="message-content">
        <div className="message-header">
          <span className="message-sender">
            {isUser ? 'You' : 'AI Assistant'}
          </span>
          <span className="message-time">
            {formatTime(message.timestamp)}
          </span>
        </div>
        
        <div className="message-body">
          <ReactMarkdown
            components={{
              code: CodeBlock,
              pre: PreBlock,
            }}
          >
            {message.content}
          </ReactMarkdown>
        </div>
        
        {!isUser && (
          <div className="message-actions">
            <IconButton
              icon={<Copy />}
              tooltip="Copy"
              size="xs"
              onClick={() => copyToClipboard(message.content)}
            />
            <IconButton
              icon={<ThumbsUp />}
              tooltip="Good response"
              size="xs"
            />
            <IconButton
              icon={<ThumbsDown />}
              tooltip="Bad response"
              size="xs"
            />
          </div>
        )}
      </div>
    </motion.div>
  );
};
```

**AI Chat Styles:**
```css
.ai-chat-container {
  @apply flex flex-col h-full;
  @apply bg-gradient-to-b from-gray-900 to-black;
}

.chat-header {
  @apply flex items-center justify-between p-4;
  @apply border-b border-white/10;
  @apply bg-gradient-to-r from-indigo-900/10 via-purple-900/10 to-pink-900/10;
}

.ai-avatar {
  @apply w-10 h-10 rounded-full;
  @apply bg-gradient-to-br from-indigo-500 to-purple-500;
  @apply flex items-center justify-center;
  @apply shadow-lg shadow-indigo-500/50;
}

.ai-icon {
  @apply text-white;
  animation: rotate-slow 4s linear infinite;
}

.chat-title {
  @apply text-base font-semibold text-gray-100;
}

.chat-status {
  @apply flex items-center gap-2 text-sm text-gray-400;
}

.status-dot {
  @apply w-2 h-2 rounded-full bg-green-500;
  animation: pulse 2s ease-in-out infinite;
}

.chat-messages {
  @apply flex-1 overflow-y-auto p-4 space-y-4;
  @apply scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent;
}

.chat-message {
  @apply flex gap-3;
}

.chat-message.user {
  @apply flex-row-reverse;
}

.message-avatar {
  @apply w-8 h-8 rounded-full flex-shrink-0;
  @apply flex items-center justify-center;
  @apply bg-gray-800 text-gray-400;
}

.chat-message.assistant .message-avatar {
  @apply bg-gradient-to-br from-indigo-500 to-purple-500;
  @apply text-white;
}

.message-content {
  @apply flex-1 max-w-2xl;
}

.chat-message.user .message-content {
  @apply flex flex-col items-end;
}

.message-body {
  @apply p-4 rounded-2xl;
  @apply bg-gray-800/50 text-gray-200;
  @apply border border-white/5;
}

.chat-message.user .message-body {
  @apply bg-gradient-to-br from-indigo-600 to-purple-600;
  @apply text-white border-0;
}

.message-actions {
  @apply flex items-center gap-1 mt-2;
}

.chat-input-container {
  @apply p-4 border-t border-white/10;
  @apply bg-gradient-to-t from-black/50 to-transparent;
}

.chat-input-wrapper {
  @apply relative rounded-xl;
  @apply bg-gray-900/50 border border-white/10;
  @apply focus-within:border-indigo-500/50;
  @apply transition-colors duration-200;
}

.chat-input {
  @apply w-full px-4 py-3 bg-transparent;
  @apply text-gray-200 placeholder-gray-500;
  @apply resize-none outline-none;
}

.input-actions {
  @apply absolute right-2 bottom-2;
  @apply flex items-center gap-2;
}

.token-counter {
  @apply flex items-center gap-2 mt-2;
  @apply text-xs text-gray-500;
}

@keyframes rotate-slow {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
```

#### 5.4.4 Context Timeline Visualization

```typescript
const ContextTimeline: React.FC = () => {
  const contexts = useContextStore(state => state.contexts);
  const [selectedDate, setSelectedDate] = useState(new Date());
  
  return (
    <div className="timeline-container">
      {/* Timeline header with date navigation */}
      <div className="timeline-header">
        <h2 className="timeline-title">Context Timeline</h2>
        <DateNavigator
          selectedDate={selectedDate}
          onChange={setSelectedDate}
        />
      </div>
      
      {/* Timeline visualization */}
      <div className="timeline-content">
        {/* Time axis */}
        <div className="time-axis">
          {Array.from({ length: 24 }, (_, i) => (
            <div key={i} className="time-mark">
              <span>{i}:00</span>
            </div>
          ))}
        </div>
        
        {/* Context blocks */}
        <div className="timeline-blocks">
          {contexts.map((context) => (
            <TimelineBlock
              key={context.id}
              context={context}
              onClick={() => handleContextClick(context)}
            />
          ))}
        </div>
        
        {/* Flow state indicator */}
        <FlowStateOverlay contexts={contexts} />
      </div>
      
      {/* Statistics panel */}
      <div className="timeline-stats">
        <StatCard
          icon={<Zap />}
          label="Flow Sessions"
          value={calculateFlowSessions(contexts)}
          trend="+12%"
        />
        <StatCard
          icon={<GitBranch />}
          label="Context Switches"
          value={contexts.length}
          trend="-8%"
        />
        <StatCard
          icon={<Clock />}
          label="Deep Work"
          value={calculateDeepWork(contexts)}
          trend="+23%"
        />
      </div>
    </div>
  );
};

const TimelineBlock: React.FC<{ context: Context }> = ({ context, onClick }) => {
  const startPos = calculatePosition(context.startTime);
  const duration = calculateDuration(context.startTime, context.endTime);
  
  return (
    <motion.div
      className="timeline-block"
      style={{
        left: `${startPos}%`,
        width: `${duration}%`,
      }}
      initial={{ scale: 0, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      whileHover={{ scale: 1.05, zIndex: 10 }}
      onClick={onClick}
    >
      <div className="block-content">
        <ContextIcon type={context.type} size={16} />
        <span className="block-label">{context.title}</span>
      </div>
      
      {/* Flow state indicator */}
      <div
        className="flow-indicator"
        style={{
          background: getFlowStateColor(context.flowDepth)
        }}
      />
      
      {/* Tooltip on hover */}
      <div className="block-tooltip">
        <p className="tooltip-title">{context.title}</p>
        <p className="tooltip-time">
          {formatTime(context.startTime)} - {formatTime(context.endTime)}
        </p>
        <p className="tooltip-summary">{context.aiSummary}</p>
      </div>
    </motion.div>
  );
};
```

**Timeline Styles:**
```css
.timeline-container {
  @apply flex flex-col h-full p-6;
  @apply bg-gradient-to-br from-gray-900 via-black to-gray-900;
}

.timeline-header {
  @apply flex items-center justify-between mb-6;
}

.timeline-title {
  @apply text-2xl font-bold;
  @apply bg-gradient-to-r from-indigo-400 to-purple-400;
  @apply bg-clip-text text-transparent;
}

.timeline-content {
  @apply relative flex-1 mb-6;
  @apply rounded-xl p-4;
  @apply bg-black/30 border border-white/5;
}

.time-axis {
  @apply flex justify-between mb-4;
  @apply text-xs text-gray-500;
  @apply border-b border-white/5 pb-2;
}

.timeline-blocks {
  @apply relative h-64;
}

.timeline-block {
  @apply absolute h-12 rounded-lg cursor-pointer;
  @apply bg-gradient-to-r from-indigo-600/80 to-purple-600/80;
  @apply border border-white/10;
  @apply transition-all duration-200;
  @apply hover:shadow-lg hover:shadow-indigo-500/50;
}

.block-content {
  @apply flex items-center gap-2 h-full px-3;
  @apply text-white text-sm font-medium;
}

.flow-indicator {
  @apply absolute bottom-0 left-0 right-0 h-1;
  @apply rounded-b-lg;
}

.block-tooltip {
  @apply absolute left-0 top-full mt-2 w-64;
  @apply p-4 rounded-lg;
  @apply bg-gray-900 border border-white/10;
  @apply shadow-xl opacity-0 pointer-events-none;
  @apply transition-opacity duration-200;
  @apply z-50;
}

.timeline-block:hover .block-tooltip {
  @apply opacity-100;
}

.timeline-stats {
  @apply grid grid-cols-3 gap-4;
}

.stat-card {
  @apply p-4 rounded-xl;
  @apply bg-gradient-to-br from-gray-800/50 to-gray-900/50;
  @apply border border-white/5;
}
```

#### 5.4.5 Button Component System

```typescript
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'ghost' | 'danger' | 'success';
  size: 'xs' | 'sm' | 'md' | 'lg';
  isLoading?: boolean;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  isLoading,
  leftIcon,
  rightIcon,
  children,
  onClick,
  disabled
}) => {
  return (
    <motion.button
      className={`btn btn-${variant} btn-${size}`}
      onClick={onClick}
      disabled={disabled || isLoading}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
    >
      {isLoading ? (
        <Loader className="animate-spin" size={16} />
      ) : (
        <>
          {leftIcon && <span className="btn-icon-left">{leftIcon}</span>}
          <span className="btn-text">{children}</span>
          {rightIcon && <span className="btn-icon-right">{rightIcon}</span>}
        </>
      )}
    </motion.button>
  );
};
```

**Button Styles:**
```css
.btn {
  @apply inline-flex items-center justify-center gap-2;
  @apply font-medium rounded-lg;
  @apply transition-all duration-200;
  @apply focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-black;
  @apply disabled:opacity-50 disabled:cursor-not-allowed;
}

/* Sizes */
.btn-xs { @apply px-2 py-1 text-xs; }
.btn-sm { @apply px-3 py-1.5 text-sm; }
.btn-md { @apply px-4 py-2 text-base; }
.btn-lg { @apply px-6 py-3 text-lg; }

/* Variants */
.btn-primary {
  @apply bg-gradient-to-r from-indigo-600 to-purple-600;
  @apply text-white;
  @apply hover:from-indigo-700 hover:to-purple-700;
  @apply focus:ring-indigo-500;
  @apply shadow-lg shadow-indigo-500/20;
}

.btn-secondary {
  @apply bg-gray-800 text-gray-200;
  @apply hover:bg-gray-700;
  @apply border border-white/10;
  @apply focus:ring-gray-500;
}

.btn-ghost {
  @apply bg-transparent text-gray-400;
  @apply hover:bg-gray-800 hover:text-gray-200;
  @apply focus:ring-gray-500;
}

.btn-danger {
  @apply bg-gradient-to-r from-red-600 to-pink-600;
  @apply text-white;
  @apply hover:from-red-700 hover:to-pink-700;
  @apply focus:ring-red-500;
  @apply shadow-lg shadow-red-500/20;
}

.btn-success {
  @apply bg-gradient-to-r from-green-600 to-emerald-600;
  @apply text-white;
  @apply hover:from-green-700 hover:to-emerald-700;
  @apply focus:ring-green-500;
  @apply shadow-lg shadow-green-500/20;
}
```

---

## 6. Core Features - Detailed Specifications {#core-features}

### 6.1 Automatic Context Capture

**Feature ID:** F001  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.1.1 Technical Requirements

```typescript
interface CaptureOptions {
  includeFiles: boolean;
  includeTerminal: boolean;
  includeBrowser: boolean;
  includeScreenshots: boolean;
  captureDepth: 'minimal' | 'standard' | 'comprehensive';
  aiAnalysis: boolean;
}

interface Context {
  id: string;
  userId: string;
  timestamp: number;
  title: string;
  aiSummary: string;
  type: 'manual' | 'auto' | 'scheduled';
  tags: string[];
  
  // Captured data
  files: FileCaptureResult[];
  browserTabs: BrowserTabCapture[];
  terminalSessions: TerminalCapture[];
  ideState: IDEStateCapture;
  applicationWindows: ApplicationWindow[];
  clipboardHistory: ClipboardEntry[];
  screenshots: Screenshot[];
  
  // Metadata
  projectId?: string;
  branch?: string;
  commitHash?: string;
  focusDepth: number; // 0-100 score
  interruptionCount: number;
  duration: number; // milliseconds
  
  // Relationships
  parentContextId?: string; // For context chains
  relatedContextIds: string[];
  
  // Sync status
  syncStatus: 'pending' | 'synced' | 'error';
  lastSyncTime?: number;
  
  // Privacy
  excludedPaths: string[];
  redactedContent: boolean;
}
```

#### 6.1.2 Capture Triggers

1. **Time-Based Triggers:**
   - Every 15 minutes during active work (configurable)
   - Before system sleep/shutdown
   - At end of work day (configurable time)

2. **Event-Based Triggers:**
   - Project switch detected
   - Git branch change
   - IDE workspace change
   - Terminal directory change
   - Before closing 5+ browser tabs
   - Manual capture via hotkey (Cmd+Shift+C)

3. **Smart Triggers:**
   - Focus session completion (2+ hours uninterrupted)
   - Before/after meetings (calendar integration)
   - Context switch detected by AI
   - When opening new project/repository

#### 6.1.3 Capture Pipeline Implementation

```typescript
class ContextCaptureService {
  private captureQueue: PriorityQueue<CaptureTask>;
  private isCapturing: boolean = false;
  
  async captureContext(options: CaptureOptions): Promise<Context> {
    if (this.isCapturing) {
      throw new Error('Capture already in progress');
    }
    
    this.isCapturing = true;
    const startTime = Date.now();
    
    try {
      // Step 1: Gather raw data in parallel
      const [
        files,
        browser,
        terminal,
        ide,
        apps,
        clipboard,
        screenshots
      ] = await Promise.all([
        this.captureFiles(options),
        this.captureBrowser(options),
        this.captureTerminal(options),
        this.captureIDE(options),
        this.captureApplications(options),
        this.captureClipboard(options),
        this.captureScreenshots(options)
      ]);
      
      // Step 2: Process and filter data
      const processedData = await this.processRawCapture({
        files,
        browser,
        terminal,
        ide,
        apps,
        clipboard,
        screenshots
      });
      
      // Step 3: AI analysis
      const aiSummary = await this.aiEngine.generateContextSummary(
        processedData
      );
      
      // Step 4: Extract metadata
      const metadata = this.extractMetadata(processedData);
      
      // Step 5: Calculate focus depth score
      const focusDepth = this.calculateFocusDepth(processedData);
      
      // Step 6: Detect related contexts
      const relatedContexts = await this.findRelatedContexts(
        processedData,
        aiSummary
      );
      
      // Step 7: Assemble context object
      const context: Context = {
        id: generateUUID(),
        userId: this.userId,
        timestamp: startTime,
        title: metadata.title || 'Untitled Context',
        aiSummary,
        type: options.manual ? 'manual' : 'auto',
        tags: metadata.tags,
        
        files: processedData.files,
        browserTabs: processedData.browser,
        terminalSessions: processedData.terminal,
        ideState: processedData.ide,
        applicationWindows: processedData.apps,
        clipboardHistory: processedData.clipboard,
        screenshots: processedData.screenshots,
        
        projectId: metadata.projectId,
        branch: metadata.branch,
        commitHash: metadata.commitHash,
        focusDepth,
        interruptionCount: 0,
        duration: 0,
        
        relatedContextIds: relatedContexts,
        syncStatus: 'pending',
        excludedPaths: options.excludePaths || [],
        redactedContent: false
      };
      
      // Step 8: Save to local DB
      await this.localDB.saveContext(context);
      
      // Step 9: Queue for sync
      this.syncService.queueSync(context);
      
      // Step 10: Update UI
      this.events.emit('context:captured', context);
      
      // Analytics
      this.analytics.track('context_captured', {
        duration: Date.now() - startTime,
        fileCount: files.length,
        tabCount: browser.length,
        captureType: context.type
      });
      
      return context;
      
    } catch (error) {
      this.logger.error('Context capture failed', error);
      throw error;
    } finally {
      this.isCapturing = false;
    }
  }
  
  private async captureFiles(options: CaptureOptions): Promise<FileCaptureResult[]> {
    const activeFiles: FileCaptureResult[] = [];
    
    // Get files from all supported IDEs
    const ideFiles = await Promise.all([
      this.vscodeIntegration.getOpenFiles(),
      this.intellijIntegration.getOpenFiles(),
      this.sublimeIntegration.getOpenFiles()
    ]);
    
    for (const file of ideFiles.flat()) {
      // Skip excluded paths
      if (this.isExcluded(file.path, options.excludePaths)) {
        continue;
      }
      
      // Read file content
      let content = '';
      let contentHash = '';
      
      try {
        if (file.size < 1024 * 1024) { // < 1MB
          content = await fs.readFile(file.path, 'utf-8');
          contentHash = this.hashContent(content);
        } else {
          // For large files, capture excerpts
          content = await this.captureExcerpt(file.path);
          contentHash = this.hashFile(file.path);
        }
      } catch (error) {
        this.logger.warn(`Failed to read file: ${file.path}`, error);
        continue;
      }
      
      // Extract language
      const language = this.detectLanguage(file.path);
      
      // Get cursor position and selections
      const editorState = await this.getEditorState(file.path);
      
      // Get git status
      const gitStatus = await this.getGitStatus(file.path);
      
      activeFiles.push({
        path: file.path,
        content,
        contentHash,
        excerpt: content.substring(0, 500),
        language,
        cursorPosition: editorState.cursor,
        selections: editorState.selections,
        scrollPosition: editorState.scroll,
        folds: editorState.folds,
        breakpoints: editorState.breakpoints,
        bookmarks: editorState.bookmarks,
        fileSize: file.size,
        lastModified: file.mtime,
        gitStatus
      });
    }
    
    return activeFiles;
  }
  
  private async captureBrowser(options: CaptureOptions): Promise<BrowserTabCapture[]> {
    const tabs: BrowserTabCapture[] = [];
    
    // Connect to browser extension
    const browserTabs = await this.browserExtension.getAllTabs();
    
    for (const tab of browserTabs) {
      // Calculate relevance score using AI
      const relevanceScore = await this.aiEngine.scoreTabRelevance(tab);
      
      // Skip low-relevance tabs
      if (relevanceScore < 0.3) continue;
      
      // Categorize tab
      const category = this.categorizeTab(tab.url);
      
      // Capture screenshot thumbnail
      let screenshot: string | undefined;
      if (options.includeScreenshots) {
        screenshot = await this.browserExtension.captureTab(tab.id);
      }
      
      // Extract form data for unsaved work
      let formData: Record<string, string> | undefined;
      if (this.isFormPage(tab.url)) {
        formData = await this.browserExtension.extractFormData(tab.id);
      }
      
      tabs.push({
        url: tab.url,
        title: tab.title,
        favicon: tab.favicon,
        screenshot,
        scrollPosition: await this.browserExtension.getScrollPosition(tab.id),
        formData,
        selectedText: await this.browserExtension.getSelection(tab.id),
        openTime: tab.openTime,
        lastActiveTime: tab.lastActiveTime,
        category,
        relevanceScore
      });
    }
    
    // Sort by relevance
    return tabs.sort((a, b) => b.relevanceScore - a.relevanceScore);
  }
  
  private async captureTerminal(options: CaptureOptions): Promise<TerminalCapture[]> {
    const sessions: TerminalCapture[] = [];
    
    // Get terminal sessions from all supported terminals
    const terminalApps = [
      'iTerm2',
      'Terminal',
      'Hyper',
      'Warp',
      'Alacritty',
      'Windows Terminal'
    ];
    
    for (const app of terminalApps) {
      const appSessions = await this.terminalIntegration.getSessions(app);
      
      for (const session of appSessions) {
        // Capture command history
        const history = await this.terminalIntegration.getHistory(
          session.id,
          100 // last 100 commands
        );
        
        // Capture output
        const output = await this.terminalIntegration.getOutput(
          session.id,
          1000 // last 1000 lines
        );
        
        // Get environment variables (filtered)
        const envVars = await this.terminalIntegration.getEnvVars(session.id);
        const filteredEnv = this.filterSensitiveEnv(envVars);
        
        // Get active processes
        const processes = await this.terminalIntegration.getProcesses(session.id);
        
        sessions.push({
          sessionId: session.id,
          workingDirectory: session.cwd,
          history: this.redactSensitiveCommands(history),
          output: this.redactSensitiveOutput(output),
          environmentVariables: filteredEnv,
          activeProcesses: processes,
          shell: session.shell,
          tabs: session.tabs
        });
      }
    }
    
    return sessions;
  }
  
  private calculateFocusDepth(data: ProcessedCaptureData): number {
    let score = 0;
    
    // More open files = higher focus
    score += Math.min(data.files.length * 5, 30);
    
    // Relevant browser tabs = higher focus
    const relevantTabs = data.browser.filter(t => t.relevanceScore > 0.7);
    score += Math.min(relevantTabs.length * 3, 20);
    
    // Terminal activity = higher focus
    score += data.terminal.length > 0 ? 15 : 0;
    
    // Breakpoints/debugging = deep focus
    const hasBreakpoints = data.files.some(f => f.breakpoints.length > 0);
    score += hasBreakpoints ? 15 : 0;
    
    // Long file selections = deep reading
    const hasLongSelections = data.files.some(
      f => f.selections.some(s => this.getSelectionLength(s) > 100)
    );
    score += hasLongSelections ? 10 : 0;
    
    // Active test runs = focused development
    const hasTests = data.terminal.some(t => 
      t.history.some(cmd => cmd.includes('test') || cmd.includes('jest'))
    );
    score += hasTests ? 10 : 0;
    
    return Math.min(score, 100);
  }
}
```

### 6.2 One-Click Context Restoration

**Feature ID:** F002  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.2.1 Restoration Pipeline

```typescript
class ContextRestorationService {
  async restoreContext(contextId: string): Promise<void> {
    const startTime = Date.now();
    
    try {
      // Step 1: Fetch context
      const context = await this.localDB.getContext(contextId);
      if (!context) {
        throw new Error('Context not found');
      }
      
      // Step 2: Show restoration UI
      this.showRestorationProgress(context);
      
      // Step 3: Restore in parallel
      const results = await Promise.allSettled([
        this.restoreFiles(context.files),
        this.restoreBrowserTabs(context.browserTabs),
        this.restoreTerminal(context.terminalSessions),
        this.restoreIDE(context.ideState),
        this.restoreApplications(context.applicationWindows)
      ]);
      
      // Step 4: Check for failures
      const failures = results.filter(r => r.status === 'rejected');
      if (failures.length > 0) {
        this.logger.warn('Some restoration steps failed', failures);
        this.showPartialRestoreNotification(failures);
      }
      
      // Step 5: Update context metadata
      await this.localDB.updateContext(contextId, {
        lastRestoredAt: Date.now(),
        restorationCount: context.restorationCount + 1
      });
      
      // Step 6: Show AI summary
      this.showContextSummary(context);
      
      // Step 7: Track analytics
      this.analytics.track('context_restored', {
        contextId,
        duration: Date.now() - startTime,
        fileCount: context.files.length,
        tabCount: context.browserTabs.length,
        failures: failures.length
      });
      
      // Step 8: Show success notification
      this.showSuccessNotification(context);
      
    } catch (error) {
      this.logger.error('Context restoration failed', error);
      this.showErrorNotification(error);
      throw error;
    }
  }
  
  private async restoreFiles(files: FileCaptureResult[]): Promise<void> {
    // Open files in appropriate IDEs
    const filesByIDE = this.groupFilesByIDE(files);
    
    for (const [ide, ideFiles] of Object.entries(filesByIDE)) {
      const integration = this.getIDEIntegration(ide);
      
      for (const file of ideFiles) {
        try {
          // Open file
          await integration.openFile(file.path);
          
          // Restore cursor position
          await integration.setCursorPosition(
            file.path,
            file.cursorPosition
          );
          
          // Restore selections
          for (const selection of file.selections) {
            await integration.addSelection(file.path, selection);
          }
          
          // Restore scroll position
          await integration.setScrollPosition(
            file.path,
            file.scrollPosition
          );
          
          // Restore folds
          await integration.setFolds(file.path, file.folds);
          
          // Restore breakpoints
          for (const breakpoint of file.breakpoints) {
            await integration.addBreakpoint(file.path, breakpoint);
          }
          
        } catch (error) {
          this.logger.error(`Failed to restore file: ${file.path}`, error);
        }
      }
    }
  }
  
  private async restoreBrowserTabs(tabs: BrowserTabCapture[]): Promise<void> {
    // Sort tabs by relevance
    const sortedTabs = tabs.sort((a, b) => b.relevanceScore - a.relevanceScore);
    
    // Open tabs in batches to avoid overwhelming the browser
    const batchSize = 5;
    for (let i = 0; i < sortedTabs.length; i += batchSize) {
      const batch = sortedTabs.slice(i, i + batchSize);
      
      await Promise.all(batch.map(async (tab) => {
        try {
          // Open tab
          const tabId = await this.browserExtension.openTab(tab.url);
          
          // Wait for page load
          await this.browserExtension.waitForLoad(tabId);
          
          // Restore scroll position
          await this.browserExtension.setScrollPosition(
            tabId,
            tab.scrollPosition
          );
          
          // Restore form data if exists
          if (tab.formData) {
            await this.browserExtension.fillForm(tabId, tab.formData);
          }
          
        } catch (error) {
          this.logger.error(`Failed to restore tab: ${tab.url}`, error);
        }
      }));
      
      // Small delay between batches
      await this.sleep(500);
    }
  }
  
  private async restoreTerminal(sessions: TerminalCapture[]): Promise<void> {
    for (const session of sessions) {
      try {
        // Create new terminal session
        const terminalId = await this.terminalIntegration.createSession(
          session.shell
        );
        
        // Set working directory
        await this.terminalIntegration.changeDirectory(
          terminalId,
          session.workingDirectory
        );
        
        // Optionally restore environment variables
        if (this.settings.restoreEnvVars) {
          await this.terminalIntegration.setEnvVars(
            terminalId,
            session.environmentVariables
          );
        }
        
        // Show command history context
        await this.terminalIntegration.sendComment(
          terminalId,
          `# Restored context - Previous commands:\n# ${session.history.slice(-5).join('\n# ')}`
        );
        
      } catch (error) {
        this.logger.error('Failed to restore terminal session', error);
      }
    }
  }
  
  private showContextSummary(context: Context): void {
    // Show overlay with AI summary
    this.overlayService.show({
      type: 'context-summary',
      content: {
        title: context.title,
        summary: context.aiSummary,
        timestamp: context.timestamp,
        files: context.files.length,
        tabs: context.browserTabs.length,
        focusDepth: context.focusDepth
      },
      duration: 10000, // 10 seconds
      position: 'top-right'
    });
  }
}
```

### 6.3 AI Context Assistant

**Feature ID:** F003  
**Priority:** P0 (Critical)  
**Complexity:** High

#### 6.3.1 AI Assistant Implementation

```typescript
class AIAssistantService {
  private openai: OpenAI;
  private conversationHistory: Map<string, ChatMessage[]>;
  private vectorStore: VectorStore;
  
  async chat(
    message: string,
    contextId?: string,
    userId?: string
  ): Promise<AsyncIterableIterator<string>> {
    // Get conversation history
    const history = this.conversationHistory.get(userId || 'default') || [];
    
    // Get current context if provided
    let contextData = null;
    if (contextId) {
      contextData = await this.localDB.getContext(contextId);
    } else {
      // Use active context
      contextData = await this.getActiveContext();
    }
    
    // Build system prompt with context
    const systemPrompt = this.buildSystemPrompt(contextData);
    
    // Prepare messages
    const messages = [
      { role: 'system', content: systemPrompt },
      ...history,
      { role: 'user', content: message }
    ];
    
    // Stream response
    const stream = await this.openai.chat.completions.create({
      model: 'gpt-4-turbo-preview',
      messages,
      stream: true,
      temperature: 0.7,
      max_tokens: 2000
    });
    
    // Track conversation
    history.push({ role: 'user', content: message });
    
    return this.streamWithHistory(stream, history, userId);
  }
  
  private buildSystemPrompt(context: Context | null): string {
    let prompt = `You are FlowVault's AI Assistant, an expert software development companion.

Your role is to:
1. Help developers understand their working context
2. Answer questions about code, files, and browser tabs in the current context
3. Suggest next steps and debugging strategies
4. Explain code patterns and architectural decisions
5. Help restore mental models after interruptions

Guidelines:
- Be concise but thorough
- Use code examples when helpful
- Reference specific files and line numbers from the context
- Proactively suggest relevant actions
- Maintain a friendly, collaborative tone
`;
    
    if (context) {
      prompt += `\n\nCurrent Context:
Title: ${context.title}
Summary: ${context.aiSummary}
Focus Depth: ${context.focusDepth}/100

Open Files (${context.files.length}):
${context.files.slice(0, 10).map(f => `- ${f.path} (${f.language})`).join('\n')}

Browser Tabs (${context.browserTabs.length}):
${context.browserTabs.slice(0, 5).map(t => `- ${t.title} (${t.url})`).join('\n')}

Recent Terminal Commands:
${context.terminalSessions[0]?.history.slice(-5).join('\n') || 'None'}
`;
    }
    
    return prompt;
  }
  
  async* streamWithHistory(
    stream: AsyncIterable<any>,
    history: ChatMessage[],
    userId: string
  ): AsyncIterableIterator<string> {
    let fullResponse = '';
    
    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || '';
      fullResponse += content;
      yield content;
    }
    
    // Save to history
    history.push({ role: 'assistant', content: fullResponse });
    this.conversationHistory.set(userId, history.slice(-20)); // Keep last 20 messages
  }
  
  // Proactive AI suggestions
  async getSuggestions(context: Context): Promise<string[]> {
    const suggestions: string[] = [];
    
    // Analyze context for suggestions
    const analysis = await this.analyzeContext(context);
    
    if (analysis.hasUncommittedChanges) {
      suggestions.push("You have uncommitted changes in 3 files. Would you like to review them?");
    }
    
    if (analysis.hasFailingTests) {
      suggestions.push("I noticed some tests are failing. Want me to help debug?");
    }
    
    if (analysis.hasOpenStackOverflow) {
      suggestions.push("You have Stack Overflow tabs open about async/await. Need help understanding that concept?");
    }
    
    if (analysis.hasLongFocusSession) {
      suggestions.push("You've been in flow for 2+ hours. Great work! Want to capture this context before taking a break?");
    }
    
    return suggestions;
  }
}
```

### 6.4 Team Context Sharing

**Feature ID:** F004  
**Priority:** P1 (High)  
**Complexity:** Medium

#### 6.4.1 Sharing Implementation

```typescript
interface SharedContext {
  id: string;
  contextId: string;
  sharedBy: string;
  sharedWith: string[]; // User IDs or 'team'
  shareType: 'view' | 'clone' | 'collaborate';
  expiresAt?: number;
  accessCount: number;
  comments: ContextComment[];
  reactions: ContextReaction[];
}

class ContextSharingService {
  async shareContext(
    contextId: string,
    shareWith: string[],
    options: ShareOptions
  ): Promise<string> {
    const context = await this.localDB.getContext(contextId);
    
    // Redact sensitive information
    const sanitizedContext = await this.sanitizeContext(context, options);
    
    // Create share record
    const share: SharedContext = {
      id: generateUUID(),
      contextId: context.id,
      sharedBy: this.userId,
      sharedWith: shareWith,
      shareType: options.type,
      expiresAt: options.expiresAt,
      accessCount: 0,
      comments: [],
      reactions: []
    };
    
    // Upload to backend
    const shareUrl = await this.api.post('/contexts/share', {
      context: sanitizedContext,
      share
    });
    
    // Notify recipients
    await this.notifyRecipients(shareWith, {
      senderName: this.getUserName(),
      contextTitle: context.title,
      shareUrl
    });
    
    return shareUrl;
  }
  
  async cloneSharedContext(shareId: string): Promise<Context> {
    // Fetch shared context
    const shared = await this.api.get(`/contexts/shared/${shareId}`);
    
    // Create local copy
    const localContext = {
      ...shared.context,
      id: generateUUID(),
      userId: this.userId,
      type: 'cloned',
      parentContextId: shared.context.id
    };
    
    // Save locally
    await this.localDB.saveContext(localContext);
    
    // Track access
    await this.api.post(`/contexts/shared/${shareId}/access`);
    
    return localContext;
  }
}
```

### 6.5 Focus Mode & Interruption Filtering

**Feature ID:** F005  
**Priority:** P1 (High)  
**Complexity:** Medium

```typescript
class FocusModeService {
  private isActive: boolean = false;
  private startTime: number = 0;
  private blockedNotifications: Notification[] = [];
  
  async enableFocusMode(duration?: number): Promise<void> {
    this.isActive = true;
    this.startTime = Date.now();
    
    // Configure notification filtering
    await this.configureNotificationFilters();
    
    // Set system Do Not Disturb
    await this.setSystemDND(true);
    
    // Show focus mode indicator
    this.overlayService.showFocusIndicator(duration);
    
    // Schedule auto-disable if duration specified
    if (duration) {
      setTimeout(() => this.disableFocusMode(), duration);
    }
    
    // Track focus session
    this.analytics.track('focus_mode_enabled', {
      duration,
      timestamp: this.startTime
    });
  }
  
  async disableFocusMode(): Promise<void> {
    if (!this.isActive) return;
    
    const sessionDuration = Date.now() - this.startTime;
    this.isActive = false;
    
    // Restore notifications
    await this.setSystemDND(false);
    
    // Show blocked notifications summary
    if (this.blockedNotifications.length > 0) {
      this.showBlockedNotificationsSummary();
    }
    
    // Track focus session completion
    this.analytics.track('focus_session_completed', {
      duration: sessionDuration,
      blockedNotifications: this.blockedNotifications.length
    });
    
    // Clear blocked notifications
    this.blockedNotifications = [];
  }
  
  shouldBlockNotification(notification: Notification): boolean {
    if (!this.isActive) return false;
    
    // Always allow critical notifications
    if (notification.priority === 'critical') {
      return false;
    }
    
    // Block based on source
    const blockedSources = this.settings.focusMode.blockedSources;
    if (blockedSources.includes(notification.source)) {
      this.blockedNotifications.push(notification);
      return true;
    }
    
    // Use AI to determine importance
    const importance = this.aiEngine.scoreNotificationImportance(
      notification,
      this.getActiveContext()
    );
    
    if (importance < 0.7) {
      this.blockedNotifications.push(notification);
      return true;
    }
    
    return false;
  }
}
```

---

## 7. Advanced Features {#advanced-features}

### 7.1 Context Search & Discovery

```typescript
class ContextSearchService {
  async search(query: string, filters?: SearchFilters): Promise<SearchResult[]> {
    // Generate query embedding
    const queryEmbedding = await this.embeddings.generate(query);
    
    // Vector similarity search
    const semanticResults = await this.vectorStore.search(
      queryEmbedding,
      filters?.limit || 20
    );
    
    // Traditional keyword search
    const keywordResults = await this.localDB.searchContexts(query, filters);
    
    // Merge and rank results
    const mergedResults = this.mergeResults(semanticResults, keywordResults);
    
    return mergedResults;
  }
  
  async findSimilarContexts(contextId: string): Promise<Context[]> {
    const context = await this.localDB.getContext(contextId);
    const embedding = await this.embeddings.generate(context.aiSummary);
    
    const similar = await this.vectorStore.search(embedding, 10);
    return similar.filter(c => c.id !== contextId);
  }
}
```

### 7.2 Context Analytics & Insights

```typescript
interface ProductivityInsights {
  // Time analytics
  totalWorkTime: number;
  deepWorkTime: number;
  fragmentedTime: number;
  
  // Context metrics
  contextSwitches: number;
  averageContextDuration: number;
  longestFlowSession: number;
  
  // Focus analytics
  focusScore: number; // 0-100
  interruptionRate: number;
  recoveryTime: number;
  
  // Project analytics
  projectDistribution: Record<string, number>;
  topProjects: Array<{ project: string; time: number }>;
  
  // Technology analytics
  languageDistribution: Record<string, number>;
  toolUsage: Record<string, number>;
  
  // Patterns
  peakProductivityHours: number[];
  contextSwitchPatterns: Array<{ from: string; to: string; frequency: number }>;
  
  // Trends
  weekOverWeekChange: number;
  monthOverMonthChange: number;
}

class AnalyticsService {
  async generateInsights(
    userId: string,
    timeRange: TimeRange
  ): Promise<ProductivityInsights> {
    const contexts = await this.localDB.getContextsInRange(userId, timeRange);
    
    // Calculate time metrics
    const timeMetrics = this.calculateTimeMetrics(contexts);
    
    // Calculate focus metrics
    const focusMetrics = this.calculateFocusMetrics(contexts);
    
    // Calculate project distribution
    const projectMetrics = this.calculateProjectMetrics(contexts);
    
    // Calculate technology usage
    const techMetrics = this.calculateTechnologyMetrics(contexts);
    
    // Detect patterns
    const patterns = await this.detectPatterns(contexts);
    
    // Calculate trends
    const trends = await this.calculateTrends(userId, timeRange);
    
    return {
      ...timeMetrics,
      ...focusMetrics,
      ...projectMetrics,
      ...techMetrics,
      ...patterns,
      ...trends
    };
  }
  
  private calculateTimeMetrics(contexts: Context[]): TimeMetrics {
    let totalWorkTime = 0;
    let deepWorkTime = 0;
    let fragmentedTime = 0;
    
    for (const context of contexts) {
      totalWorkTime += context.duration;
      
      if (context.focusDepth > 70) {
        deepWorkTime += context.duration;
      } else if (context.focusDepth < 30) {
        fragmentedTime += context.duration;
      }
    }
    
    return {
      totalWorkTime,
      deepWorkTime,
      fragmentedTime,
      contextSwitches: contexts.length,
      averageContextDuration: totalWorkTime / contexts.length,
      longestFlowSession: Math.max(...contexts.map(c => c.duration))
    };
  }
  
  async detectPatterns(contexts: Context[]): Promise<Patterns> {
    // Analyze context switches
    const switches: Array<{ from: string; to: string }> = [];
    
    for (let i = 1; i < contexts.length; i++) {
      switches.push({
        from: contexts[i - 1].projectId || 'unknown',
        to: contexts[i].projectId || 'unknown'
      });
    }
    
    // Group and count
    const switchFrequency = new Map<string, number>();
    switches.forEach(s => {
      const key = `${s.from}â†’${s.to}`;
      switchFrequency.set(key, (switchFrequency.get(key) || 0) + 1);
    });
    
    // Analyze peak hours
    const hourlyActivity = new Array(24).fill(0);
    contexts.forEach(c => {
      const hour = new Date(c.timestamp).getHours();
      hourlyActivity[hour] += c.duration;
    });
    
    const peakHours = hourlyActivity
      .map((activity, hour) => ({ hour, activity }))
      .sort((a, b) => b.activity - a.activity)
      .slice(0, 5)
      .map(h => h.hour);
    
    return {
      contextSwitchPatterns: Array.from(switchFrequency.entries())
        .map(([pattern, frequency]) => {
          const [from, to] = pattern.split('â†’');
          return { from, to, frequency };
        })
        .sort((a, b) => b.frequency - a.frequency)
        .slice(0, 10),
      peakProductivityHours: peakHours
    };
  }
}
```

### 7.3 Smart Notifications & Suggestions

```typescript
class SmartNotificationService {
  async generateNotifications(): Promise<Notification[]> {
    const notifications: Notification[] = [];
    const activeContext = await this.getActiveContext();
    const insights = await this.analytics.getCurrentInsights();
    
    // Long context without capture
    if (activeContext && Date.now() - activeContext.timestamp > 3600000) {
      notifications.push({
        id: generateUUID(),
        type: 'suggestion',
        priority: 'medium',
        title: 'Capture your progress?',
        message: "You've been working for over an hour. Save this context to preserve your flow state.",
        action: {
          label: 'Capture Now',
          handler: () => this.captureContext()
        }
      });
    }
    
    // Focus session achievement
    if (insights.longestFlowSession > 7200000) { // 2 hours
      notifications.push({
        type: 'achievement',
        priority: 'low',
        title: 'ðŸŽ‰ Flow Master!',
        message: 'You just completed a 2+ hour deep work session!',
        action: {
          label: 'View Stats',
          handler: () => this.showAnalytics()
        }
      });
    }
    
    // Context switch warning
    if (insights.contextSwitches > 20 && insights.deepWorkTime < 3600000) {
      notifications.push({
        type: 'insight',
        priority: 'medium',
        title: 'High context switching detected',
        message: 'You switched contexts 20+ times today with limited deep work. Try Focus Mode?',
        action: {
          label: 'Enable Focus Mode',
          handler: () => this.enableFocusMode()
        }
      });
    }
    
    // Similar past context
    const similar = await this.findSimilarPastContext(activeContext);
    if (similar) {
      notifications.push({
        type: 'suggestion',
        priority: 'high',
        title: 'Related context found',
        message: `You worked on something similar 2 days ago: "${similar.title}"`,
        action: {
          label: 'View Context',
          handler: () => this.viewContext(similar.id)
        }
      });
    }
    
    return notifications;
  }
  
  // Proactive context suggestions
  async suggestContextRestore(): Promise<Context | null> {
    const currentTime = new Date().getHours();
    const currentDay = new Date().getDay();
    
    // Find contexts at similar time/day in the past
    const historicalContexts = await this.localDB.getContextsByTimePattern({
      hour: currentTime,
      dayOfWeek: currentDay,
      limit: 10
    });
    
    if (historicalContexts.length === 0) return null;
    
    // Use AI to pick the most relevant
    const relevanceScores = await Promise.all(
      historicalContexts.map(async c => ({
        context: c,
        score: await this.aiEngine.scoreContextRelevance(c)
      }))
    );
    
    const best = relevanceScores.sort((a, b) => b.score - a.score)[0];
    
    if (best.score > 0.7) {
      return best.context;
    }
    
    return null;
  }
}
```

### 7.4 Collaborative Features

```typescript
interface CollaborationSession {
  id: string;
  contextId: string;
  participants: Participant[];
  startTime: number;
  endTime?: number;
  sharedCursor: CursorPosition[];
  chat: ChatMessage[];
  activities: Activity[];
}

class CollaborationService {
  private websocket: WebSocket;
  
  async startCollaboration(contextId: string): Promise<string> {
    const context = await this.localDB.getContext(contextId);
    
    // Create collaboration session
    const session: CollaborationSession = {
      id: generateUUID(),
      contextId,
      participants: [
        {
          userId: this.userId,
          name: this.userName,
          role: 'host',
          joinedAt: Date.now()
        }
      ],
      startTime: Date.now(),
      sharedCursor: [],
      chat: [],
      activities: []
    };
    
    // Start WebSocket connection
    await this.websocket.send('collab:start', session);
    
    // Share invite link
    const inviteLink = await this.generateInviteLink(session.id);
    
    return inviteLink;
  }
  
  async joinCollaboration(sessionId: string): Promise<void> {
    // Join WebSocket room
    await this.websocket.send('collab:join', {
      sessionId,
      userId: this.userId,
      userName: this.userName
    });
    
    // Listen for events
    this.websocket.on('collab:cursor', (data) => {
      this.updateRemoteCursor(data);
    });
    
    this.websocket.on('collab:activity', (data) => {
      this.handleRemoteActivity(data);
    });
    
    this.websocket.on('collab:chat', (data) => {
      this.handleChatMessage(data);
    });
  }
  
  async shareCursorPosition(position: CursorPosition): Promise<void> {
    await this.websocket.send('collab:cursor', {
      userId: this.userId,
      position
    });
  }
  
  async shareActivity(activity: Activity): Promise<void> {
    await this.websocket.send('collab:activity', {
      userId: this.userId,
      activity
    });
  }
}
```

### 7.5 Context Automation & Workflows

```typescript
interface Workflow {
  id: string;
  name: string;
  trigger: WorkflowTrigger;
  actions: WorkflowAction[];
  enabled: boolean;
}

interface WorkflowTrigger {
  type: 'time' | 'event' | 'condition';
  config: any;
}

interface WorkflowAction {
  type: 'capture' | 'restore' | 'notify' | 'sync' | 'custom';
  config: any;
}

class WorkflowService {
  private workflows: Map<string, Workflow> = new Map();
  
  async createWorkflow(workflow: Workflow): Promise<void> {
    this.workflows.set(workflow.id, workflow);
    
    // Register trigger
    this.registerTrigger(workflow);
    
    await this.localDB.saveWorkflow(workflow);
  }
  
  private registerTrigger(workflow: Workflow): void {
    switch (workflow.trigger.type) {
      case 'time':
        this.registerTimeTrigger(workflow);
        break;
      case 'event':
        this.registerEventTrigger(workflow);
        break;
      case 'condition':
        this.registerConditionTrigger(workflow);
        break;
    }
  }
  
  private registerTimeTrigger(workflow: Workflow): void {
    const { schedule } = workflow.trigger.config;
    
    // Use cron-like scheduling
    cron.schedule(schedule, async () => {
      if (workflow.enabled) {
        await this.executeWorkflow(workflow);
      }
    });
  }
  
  private registerEventTrigger(workflow: Workflow): void {
    const { event } = workflow.trigger.config;
    
    this.events.on(event, async (data) => {
      if (workflow.enabled && this.evaluateConditions(workflow, data)) {
        await this.executeWorkflow(workflow, data);
      }
    });
  }
  
  private async executeWorkflow(
    workflow: Workflow,
    data?: any
  ): Promise<void> {
    this.logger.info(`Executing workflow: ${workflow.name}`);
    
    for (const action of workflow.actions) {
      try {
        await this.executeAction(action, data);
      } catch (error) {
        this.logger.error(`Workflow action failed: ${action.type}`, error);
      }
    }
    
    this.analytics.track('workflow_executed', {
      workflowId: workflow.id,
      workflowName: workflow.name
    });
  }
  
  private async executeAction(action: WorkflowAction, data?: any): Promise<void> {
    switch (action.type) {
      case 'capture':
        await this.contextCapture.captureContext(action.config);
        break;
        
      case 'restore':
        await this.contextRestore.restoreContext(action.config.contextId);
        break;
        
      case 'notify':
        await this.notifications.show(action.config);
        break;
        
      case 'sync':
        await this.sync.syncAll();
        break;
        
      case 'custom':
        await this.pluginManager.executePlugin(
          action.config.pluginId,
          action.config.action,
          data
        );
        break;
    }
  }
}

// Example workflows
const exampleWorkflows: Workflow[] = [
  {
    id: 'auto-capture-eod',
    name: 'Auto-capture at end of day',
    trigger: {
      type: 'time',
      config: { schedule: '0 18 * * *' } // 6 PM daily
    },
    actions: [
      {
        type: 'capture',
        config: { captureDepth: 'comprehensive' }
      },
      {
        type: 'notify',
        config: {
          title: 'Context saved',
          message: 'Your end-of-day context has been captured'
        }
      }
    ],
    enabled: true
  },
  {
    id: 'restore-morning',
    name: 'Restore yesterday\'s context in the morning',
    trigger: {
      type: 'time',
      config: { schedule: '0 9 * * *' } // 9 AM daily
    },
    actions: [
      {
        type: 'restore',
        config: { contextId: 'last' }
      }
    ],
    enabled: true
  },
  {
    id: 'focus-mode-deep-work',
    name: 'Enable focus mode during deep work hours',
    trigger: {
      type: 'time',
      config: { schedule: '0 10-12,14-16 * * *' } // 10 AM-12 PM, 2-4 PM
    },
    actions: [
      {
        type: 'custom',
        config: {
          pluginId: 'focus-mode',
          action: 'enable',
          duration: 7200000 // 2 hours
        }
      }
    ],
    enabled: false
  }
];
```

### 7.6 Context Templates

```typescript
interface ContextTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  icon: string;
  files: string[]; // File paths or patterns
  browserTabs: string[]; // URLs
  terminalCommands: string[];
  ideConfig: any;
  tags: string[];
}

class TemplateService {
  async createFromContext(contextId: string): Promise<ContextTemplate> {
    const context = await this.localDB.getContext(contextId);
    
    const template: ContextTemplate = {
      id: generateUUID(),
      name: `${context.title} Template`,
      description: context.aiSummary,
      category: this.detectCategory(context),
      icon: this.selectIcon(context),
      files: context.files.map(f => this.generalizePath(f.path)),
      browserTabs: context.browserTabs.map(t => t.url),
      terminalCommands: context.terminalSessions[0]?.history.slice(-5) || [],
      ideConfig: context.ideState,
      tags: context.tags
    };
    
    await this.localDB.saveTemplate(template);
    
    return template;
  }
  
  async applyTemplate(templateId: string): Promise<Context> {
    const template = await this.localDB.getTemplate(templateId);
    
    // Create new context from template
    const context: Context = {
      id: generateUUID(),
      userId: this.userId,
      timestamp: Date.now(),
      title: template.name,
      aiSummary: template.description,
      type: 'manual',
      tags: template.tags,
      files: [],
      browserTabs: [],
      terminalSessions: [],
      // ... other fields
    };
    
    // Apply file patterns
    for (const pattern of template.files) {
      const matchedFiles = await this.findMatchingFiles(pattern);
      for (const file of matchedFiles) {
        await this.ideIntegration.openFile(file);
      }
    }
    
    // Open browser tabs
    for (const url of template.browserTabs) {
      await this.browserExtension.openTab(url);
    }
    
    // Execute terminal commands
    if (template.terminalCommands.length > 0) {
      const terminalId = await this.terminalIntegration.createSession();
      for (const command of template.terminalCommands) {
        await this.terminalIntegration.sendCommand(terminalId, command);
      }
    }
    
    // Capture the applied template as a context
    await this.sleep(2000); // Wait for everything to open
    return await this.contextCapture.captureContext({
      includeFiles: true,
      includeBrowser: true,
      includeTerminal: true,
      captureDepth: 'standard',
      aiAnalysis: true
    });
  }
}

// Built-in templates
const builtInTemplates: ContextTemplate[] = [
  {
    id: 'react-dev',
    name: 'React Development',
    description: 'Set up for React component development',
    category: 'frontend',
    icon: 'âš›ï¸',
    files: [
      'src/components/**/*.tsx',
      'src/App.tsx',
      'package.json'
    ],
    browserTabs: [
      'http://localhost:3000',
      'https://react.dev/reference',
      'https://tailwindcss.com/docs'
    ],
    terminalCommands: [
      'npm run dev'
    ],
    ideConfig: {},
    tags: ['react', 'frontend', 'typescript']
  },
  {
    id: 'debugging',
    name: 'Debugging Session',
    description: 'Set up for debugging with logs and breakpoints',
    category: 'debugging',
    icon: 'ðŸ›',
    files: [
      'src/**/*.log',
      'tests/**/*.test.ts'
    ],
    browserTabs: [
      'http://localhost:3000/debug',
      'https://stackoverflow.com'
    ],
    terminalCommands: [
      'npm run test:debug',
      'tail -f logs/error.log'
    ],
    ideConfig: {
      enableBreakpoints: true,
      openDebugConsole: true
    },
    tags: ['debugging', 'testing']
  },
  {
    id: 'api-dev',
    name: 'API Development',
    description: 'Backend API development setup',
    category: 'backend',
    icon: 'ðŸ”Œ',
    files: [
      'src/routes/**/*.ts',
      'src/controllers/**/*.ts',
      'src/models/**/*.ts'
    ],
    browserTabs: [
      'http://localhost:8000/docs',
      'https://expressjs.com/en/api.html'
    ],
    terminalCommands: [
      'npm run dev',
      'curl http://localhost:8000/health'
    ],
    ideConfig: {},
    tags: ['backend', 'api', 'nodejs']
  }
];
```

---

## 8. Data Models & Database Schema {#data-models}

### 8.1 SQLite Schema (Local Database)

```sql
-- Users table
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  avatar_url TEXT,
  settings TEXT, -- JSON
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Contexts table
CREATE TABLE contexts (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  title TEXT NOT NULL,
  ai_summary TEXT,
  type TEXT NOT NULL, -- 'manual', 'auto', 'scheduled'
  tags TEXT, -- JSON array
  project_id TEXT,
  branch TEXT,
  commit_hash TEXT,
  focus_depth INTEGER,
  interruption_count INTEGER DEFAULT 0,
  duration INTEGER DEFAULT 0,
  parent_context_id TEXT,
  related_context_ids TEXT, -- JSON array
  sync_status TEXT DEFAULT 'pending',
  last_sync_time INTEGER,
  excluded_paths TEXT, -- JSON array
  redacted_content INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (parent_context_id) REFERENCES contexts(id)
);

CREATE INDEX idx_contexts_user_id ON contexts(user_id);
CREATE INDEX idx_contexts_timestamp ON contexts(timestamp);
CREATE INDEX idx_contexts_project_id ON contexts(project_id);
CREATE INDEX idx_contexts_sync_status ON contexts(sync_status);

-- Files table
CREATE TABLE files (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  path TEXT NOT NULL,
  content TEXT,
  content_hash TEXT NOT NULL,
  excerpt TEXT,
  language TEXT,
  cursor_line INTEGER,
  cursor_column INTEGER,
  selections TEXT, -- JSON
  scroll_position INTEGER,
  folds TEXT, -- JSON array
  breakpoints TEXT, -- JSON array
  bookmarks TEXT, -- JSON
  file_size INTEGER,
  last_modified INTEGER,
  git_branch TEXT,
  git_changes INTEGER,
  git_staged INTEGER,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_files_context_id ON files(context_id);
CREATE INDEX idx_files_path ON files(path);

-- Browser tabs table
CREATE TABLE browser_tabs (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  url TEXT NOT NULL,
  title TEXT,
  favicon TEXT,
  screenshot TEXT, -- Base64 or URL
  scroll_position INTEGER,
  form_data TEXT, -- JSON
  selected_text TEXT,
  open_time INTEGER,
  last_active_time INTEGER,
  category TEXT,
  relevance_score REAL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_browser_tabs_context_id ON browser_tabs(context_id);

-- Terminal sessions table
CREATE TABLE terminal_sessions (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  working_directory TEXT,
  history TEXT, -- JSON array
  output TEXT,
  environment_variables TEXT, -- JSON
  active_processes TEXT, -- JSON array
  shell TEXT,
  tabs TEXT, -- JSON array
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_terminal_sessions_context_id ON terminal_sessions(context_id);

-- IDE state table
CREATE TABLE ide_states (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  type TEXT NOT NULL,
  open_projects TEXT, -- JSON array
  workspace TEXT, -- JSON
  extensions TEXT, -- JSON array
  debug_sessions TEXT, -- JSON array
  run_configurations TEXT, -- JSON array
  search_history TEXT, -- JSON array
  recent_files TEXT, -- JSON array
  pinned_files TEXT, -- JSON array
  split_layout TEXT, -- JSON
  editor_groups TEXT, -- JSON array
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_ide_states_context_id ON ide_states(context_id);

-- Context embeddings table (for semantic search)
CREATE TABLE context_embeddings (
  id TEXT PRIMARY KEY,
  context_id TEXT NOT NULL,
  embedding BLOB NOT NULL, -- Vector embedding
  created_at INTEGER NOT NULL,
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE
);

CREATE INDEX idx_context_embeddings_context_id ON context_embeddings(context_id);

-- Workflows table
CREATE TABLE workflows (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  trigger_type TEXT NOT NULL,
  trigger_config TEXT, -- JSON
  actions TEXT, -- JSON array
  enabled INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_workflows_user_id ON workflows(user_id);

-- Templates table
CREATE TABLE templates (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  category TEXT,
  icon TEXT,
  files TEXT, -- JSON array
  browser_tabs TEXT, -- JSON array
  terminal_commands TEXT, -- JSON array
  ide_config TEXT, -- JSON
  tags TEXT, -- JSON array
  is_public INTEGER DEFAULT 0,
  usage_count INTEGER DEFAULT 0,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_templates_user_id ON templates(user_id);
CREATE INDEX idx_templates_category ON templates(category);

-- Analytics events table
CREATE TABLE analytics_events (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  event_name TEXT NOT NULL,
  event_data TEXT, -- JSON
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_analytics_events_user_id ON analytics_events(user_id);
CREATE INDEX idx_analytics_events_timestamp ON analytics_events(timestamp);

-- Settings table
CREATE TABLE settings (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  key TEXT NOT NULL,
  value TEXT, -- JSON
  updated_at INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE(user_id, key)
);

CREATE INDEX idx_settings_user_id ON settings(user_id);
```

### 8.2 PostgreSQL Schema (Backend Database)

```sql
-- Users table (backend)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255),
  avatar_url TEXT,
  password_hash VARCHAR(255),
  subscription_tier VARCHAR(50) DEFAULT 'free',
  subscription_status VARCHAR(50),
  stripe_customer_id VARCHAR(255),
  settings JSONB,
  last_login_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_subscription_tier ON users(subscription_tier);

-- Contexts table (cloud storage)
CREATE TABLE contexts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  local_id VARCHAR(255), -- ID from client
  timestamp BIGINT NOT NULL,
  title TEXT NOT NULL,
  ai_summary TEXT,
  type VARCHAR(50) NOT NULL,
  tags JSONB,
  project_id VARCHAR(255),
  branch VARCHAR(255),
  commit_hash VARCHAR(255),
  focus_depth INTEGER,
  interruption_count INTEGER DEFAULT 0,
  duration INTEGER DEFAULT 0,
  parent_context_id UUID,
  related_context_ids JSONB,
  excluded_paths JSONB,
  redacted_content BOOLEAN DEFAULT FALSE,
  data JSONB, -- Full context data
  embedding vector(1536), -- For vector similarity search
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_context_id) REFERENCES contexts(id)
);

CREATE INDEX idx_contexts_user_id ON contexts(user_id);
CREATE INDEX idx_contexts_timestamp ON contexts(timestamp);
CREATE INDEX idx_contexts_project_id ON contexts(project_id);
CREATE INDEX idx_contexts_embedding ON contexts USING ivfflat (embedding vector_cosine_ops);

-- Shared contexts table
CREATE TABLE shared_contexts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  context_id UUID NOT NULL,
  shared_by UUID NOT NULL,
  share_type VARCHAR(50) NOT NULL, -- 'view', 'clone', 'collaborate'
  expires_at TIMESTAMP,
  access_count INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (context_id) REFERENCES contexts(id) ON DELETE CASCADE,
  FOREIGN KEY (shared_by) REFERENCES users(id)
);

CREATE INDEX idx_shared_contexts_context_id ON shared_contexts(context_id);

-- Shared context access table
CREATE TABLE shared_context_access (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  shared_context_id UUID NOT NULL,
  user_id UUID,
  share_token VARCHAR(255),
  accessed_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (shared_context_id) REFERENCES shared_contexts(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Teams table
CREATE TABLE teams (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  owner_id UUID NOT NULL,
  subscription_tier VARCHAR(50) DEFAULT 'team',
  settings JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (owner_id) REFERENCES users(id)
);

-- Team members table
CREATE TABLE team_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  team_id UUID NOT NULL,
  user_id UUID NOT NULL,
  role VARCHAR(50) DEFAULT 'member', -- 'admin', 'member'
  joined_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE(team_id, user_id)
);

-- Subscriptions table
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID,
  team_id UUID,
  stripe_subscription_id VARCHAR(255) UNIQUE,
  plan VARCHAR(50) NOT NULL,
  status VARCHAR(50) NOT NULL,
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,